const translations = {
    shared: {
    next: `继续`,
    start: `开始`,
    copy: `复制`,
    info: `信息`,
    copy_acknowledged: `已复制！`,
    about: `关于`,
    chapter: `章节`,
    chapters: `所有章节`,
    challenge: `挑战`,
    challenges: `挑战关卡`,
    coming_soon: `即将上线`,
    start_chapter: `开始本章`,
    back: `返回`,
    end: `结束`,
    close: `关闭`,
    poweroff: `返回章节选择`,
    loading: `加载中`,
    bitcoin_dev_project: `比特币开发项目`,
    home_tooltip: `别担心，我们已经为你保存了所有进度。`,
    },

  ///ABOUT PAGE
  about: {
    title: `关于`,
    mobile_title: `关于 Saving Satoshi 的全部信息`,
    subtitle: `现在是 2139 年。距离最后一个比特币被挖出只剩两周。过去几个月，佐藤广场上的倒计时一直在滴答作响。`,
    intro: `就在全世界等待这一历史性时刻之际，比特币网络突然停摆。<br><br>你的多功能手表上，你收到一个来自名为中本聪的人发送的 WhiskerWare 全息猫。（它和普通全息图没什么不同，只不过它是一只猫。）你轻点它的鼻子将其打开。`,

    project: {
      title: `比特币是严肃的，但学习它不一定要严肃`,
      paragraph_one: `Saving Satoshi 是一个关于比特币技术的轻松互动 RPG（角色扮演游戏）。它将有趣的新颖挑战、故事叙事和游戏机制结合起来，让任何人都能更轻松进入比特币开发世界。`,
      paragraph_two: `它专为好奇的程序员以及想真正了解比特币如何运作的人设计。适合那些被比特币开源软件（₿OSS）吸引、希望参与贡献的人。`,
      paragraph_three: `每一章都包含代码教学内容、模拟和编程练习，让学习比特币技术的复杂细节变得更有趣。`,
      paragraph_four: `通过简单直接的例子，玩家先打好基础，再逐步累积复杂知识。借助沉浸式体验、丰富视觉和流畅交互，玩家将探索包括：`,
      chapter_topics: {
        list_one: `寻找并解码创世区块中的秘密信息`,
        list_two: `哈希函数与工作量证明`,
        list_three: `矿池挖矿的动态机制`,
        list_four: `椭圆曲线加密基础，以及如何由公私钥推导地址`,
        list_five: `ECDSA 消息签名与验证`,
        list_six: `从零开始构建一笔交易`,
        list_seven: `组合交易以构建区块模板`,
        list_eight: `使用 Bitcoin Core RPC API 并计算区块补贴`,
        list_nine: `比特币脚本（Bitcoin Script）`,
        list_ten: `闪电网络如何运作`,
      },
      paragraph_five: `但游戏不仅仅是课程内容。我们相信比特币教育可以像比特币技术本身一样富有创意和独特。因此游戏也触及比特币文化、历史和设计等迷人元素。`,
      paragraph_six: `在我们看来，比特币是推动世界积极变化的力量。本项目由一群充满热情的贡献者共同打造，遵循最高标准，并且 100% 免费开源（FOSS）。想了解 Saving Satoshi 的制作过程，请查看 Bitcoin Design Guide 中的<Link href="https://bitcoin.design/guide/case-studies/saving-satoshi" className="underline" target="_blank">案例研究</Link>。`,
      paragraph_seven: `无论是玩游戏、举办 workshop、还是作出代码贡献，有许多方式可以加入 Saving Satoshi 社区。我们非常欢迎你！你可以关注 <Link href="https://github.com/saving-satoshi/saving-satoshi" className="underline" target="_blank">GitHub</Link> 并加入 Bitcoin Design 社区 Discord 的 <Link href="https://discord.gg/eBGRaCSjg5" className="underline" target="_blank">#saving-satoshi</Link> 频道。`,
      paragraph_eight: `你也可以在 <Link href="https://x.com/savingsatoshi" className="underline" target="_blank">X</Link>、<Link href="https://njump.me/npub1vy6wcgw6jhhtcmpawvlnsfx7g8qt8r40z7qlks9zwa4ed57vm5eqx527hr" className="underline" target="_blank">nostr</Link> 和 <Link href="https://bsky.app/profile/bitcoindevs.bsky.social" className="underline" target="_blank">Bluesky</Link> 上联系到我们。我们喜欢用户的反馈与打招呼！`,
    },

    contributing: {
      title: `如何贡献`,
      paragraph_one: `我们是一个开源项目，所以所有入口都向你敞开，你可以自由帮助改进它。`,

      feedback: {
        title: `反馈`,
        paragraph_one: `我们非常愿意听到你的声音！无论是哪些做得好、哪些不好、哪些可以改进，你都可以通过<a href="https://docs.google.com/forms/d/e/1FAIpQLSf1xpNqUYJyvYL5IZDnxy78273pkqzfYW2Hf91H4Do4KHgy9g/viewform" target="_blank" rel="noreferrer">这个表单</a>提交反馈。`,
      },

      contribute: {
        title: `贡献内容`,
        paragraph_one: `所有建议都欢迎。我们也一直在寻找协助审查与 QA 代码的人。如果是代码相关的改进，你可以直接在<a href="https://github.com/saving-satoshi/saving-satoshi" target="_blank" rel="noreferrer">GitHub</a>上开 issue 或提交 pull request。`,
        paragraph_two: `如果你想参与设计、故事或其他内容，请加入我们在 <a href="https://discord.gg/B9WURkwF" target="_blank" rel="noreferrer">Bitcoin Design Discord</a> 的 #saving-satoshi 频道。简单说明你想如何贡献，我们会帮助你找到正确方向。`,
      },
    },

    privacy: {
      title: `我们的隐私承诺`,
      paragraph_one: `在 Saving Satoshi，我们非常重视用户的隐私与安全。我们坚持透明原则，希望你理解我们为何以及如何追踪应用使用情况。为此，我们使用了一个强大的工具 <Link href="https://umami.is/" className="underline" target="_blank">Umami</Link>。`,
      sub_heading_one: `什么是 Umami？`,
      paragraph_two: `Umami 是一个开源分析平台，帮助我们收集应用使用的重要洞察。通过这些数据，我们能够做出更好的产品决策，为你持续优化体验。你可以在<Link className="underline" href="https://visits.bitcoindevs.xyz/share/zFmD5WIus09mDxEf/Saving%20Satoshi" target="_blank">这里</Link>查看 Umami 的数据面板。`,
      sub_heading_two: `我们收集哪些数据？`,
      paragraph_three: `请放心，我们只收集非个人的匿名数据，例如：`,
      list_item_one_title: `产品改进：`,
      list_item_one_text: `帮助我们找到应用可以改进的地方，使其更高效、更易用、更安全。`,
      list_item_two_title: `兼容性：`,
      list_item_two_text: `了解你使用的设备与平台，帮助我们优化应用在不同环境下的表现。`,
      sub_heading_three: `你的隐私至关重要`,
      paragraph_four: `我们不会收集任何可识别个人身份的信息，收集的数据仅用于改进应用，不会出售或提供给任何第三方。`,
      paragraph_five: `如果你对我们的数据收集或隐私政策有疑问，请随时联系我们。我们致力于为你提供透明、安全的使用体验。`,
    },

    contributors: {
      title: `尽情享受！`,
      paragraph_one: `Saving Satoshi 的实现离不开过去几年众多人的共同努力。真的是一个“村庄”一起完成的项目！`,
      paragraph_two: `核心团队成员包括 <Link href="https://adamjonas.com/" className="underline" target="_blank">Adam Jonas</Link>、<Link href="https://www.germanysbestkeptsecret.com/" className="underline" target="_blank">Christoph Ono</Link>（设计负责人）、<Link href="https://satsie.dev/" className="underline" target="_blank">Satsie</Link>、<Link href="https://github.com/benalleng" className="underline" target="_blank">BenAllenG</Link>（工程负责人）、<Link href="https://github.com/pinheadmz" className="underline" target="_blank">Matthew Zipkin</Link>（课程内容负责人）、<Link href="https://x.com/TuedonTuoyo" className="underline" target="_blank">Tuedon Tuoyo</Link>、<Link href="https://www.artassoiants.com/" className="underline" target="_blank">Art Assoiants</Link>（产品经理），以及 Spiral 借给我们写故事的 4 只神秘猫咪。`,
      paragraph_three: `除此之外，还有许多贡献者在不同阶段发挥了关键作用，包括但不限于 <Link href="https://x.com/ecurrencyhodler" className="underline" target="_blank">ecurrencyhodler</Link>、<Link href="https://www.jtwoodhouse.com/" className="underline" target="_blank">JT Woodhouse</Link>、<Link href="https://x.com/_Jsms_" className="underline" target="_blank">JSMS</Link>、<Link href="https://github.com/afterburn" className="underline" target="_blank">Kevin Karsopawiro</Link>、<Link href="https://github.com/daviroo" className="underline" target="_blank">daviroo</Link>、<Link href="https://github.com/nully0x" className="underline" target="_blank">nully0x</Link>、<Link href="https://github.com/vinayaksh42" className="underline" target="_blank">Vinayak Sharma</Link>、<Link href="https://github.com/shaavan" className="underline" target="_blank">Shashwat Vangani</Link>、<Link href="https://github.com/aureleoules" className="underline" target="_blank">Aurèle Oulès</Link>、以及 <Link href="https://github.com/sabakhilji" className="underline" target="_blank">sabakhilji</Link>。`,
      paragraph_four: `你可以在 <Link href="https://github.com/saving-satoshi/saving-satoshi/graphs/contributors" className="underline" target="_blank">GitHub</Link> 查看完整代码贡献者列表。`,
    },

    satoshi_needs_you: `快点吧，中本聪需要你。`,
  },

  ///CHAPTERS TITLE PAGE
  chapter_one: {
    title: `隐藏在明处的秘密`,
    paragraph_one: `现在是 2139 年。距离最后一个比特币被挖出只剩两周。过去几个月，佐藤广场上的倒计时一直在滴答作响。在此之前，每个区块都带有一定的比特币奖励（补贴）。这是比特币诞生的唯一方式，但很快情况就要改变了。经过一百多年，比特币发行计划即将结束。全世界都在等待最后一个包含补贴的区块被挖出。这是一个时代的终结。`,
    paragraph_two: `突然，网络停摆了。`,

    ///CHAPTER 1
    intro_one: {
      title: `介绍`,
      nav_title: `矿工抗议`,
      paragraph_one: `几秒钟后，你的悬浮屏幕亮了起来。`,
      paragraph_two: `— Deborah Chunk：“Thomas Vanderpoole，作为 BitRey 的穿着考究的 CEO，你掌管着全球最大的比特币矿池，同时也生产比特币矿机。到底发生了什么？比特币要死了吗？”`,
      paragraph_three: `— Vanderpoole：“让我从头说起。是的，我是，Deborah，而且没错。Vanderpoole 家族——我那穿着考究的父亲，还有他的穿着考究的父亲——从区块 21,000 就开始挖矿。因此我可以肯定地说，全世界的矿工正在关闭他们的矿机造成延迟。这是一场抗议。没人希望比特币在 2100 万枚时停止发行。单靠手续费矿工活不下去。”`,
      start: `继续`,
    },

    intro_two: {
      title: `创世`,
      nav_title: `中本聪的全息猫`,
      paragraph_one: `你的多功能手表上，你收到一个来自名为中本聪的人发来的 WhiskerWare 全息猫。（它和普通电子全息图没什么不同，只不过它是一只猫。）你轻点它的鼻子将其打开。`,
      paragraph_two: `—“比特币没有死，但它需要你的帮助。别忘了带上猫。” — 中本聪`,
      paragraph_three: `— 中本聪？那个中本聪？白皮书的作者？不可能，他已经被认为去世一个多世纪了。`,
      paragraph_four: `真的吗？`,
      paragraph_five: `全息猫：“你最好马上开始工作。我可以帮你，但你必须立刻行动喵。”`,
    },

    genesis_one: {
      title: `创世`,
      nav_title: `创世秘密`,
      heading: `你的第一个挑战`,
      paragraph_one: `比特币是一种抗审查的货币。任何人都可以通过广播一笔交易来发送比特币。广播后，矿工会将交易打包进区块中。矿工之间相互竞争抢夺构建新区块的权利。这保证了比特币的去中心化。`,
      paragraph_two: `比特币的匿名创造者中本聪，也挖出了第一个区块。他在第一笔比特币交易里留下了一条秘密消息。你的第一个挑战就是找到并解码它。`,
    },

    genesis_two: {
      title: `创世`,
      nav_title: `找到消息`,
      heading: `找到隐藏的消息`,
      paragraph_one: `我们来寻找比特币区块链的第一个区块。点击下面的按钮在 <Tooltip id="genesis_two_paragraph_one" content="chapter_one.genesis_two.tooltip_block_explorer" theme="bg-[#30435b]">区块浏览器</Tooltip> 中打开编号为 0 的区块，也就是创世区块。`,
      paragraph_two: `向下滚动并展开该区块中唯一一笔交易的详情。找到名为 “Coinbase” 的输入部分。然后寻找 “SCRIPTSIG (<Tooltip id="genesis_two_paragraph_two" content="chapter_one.genesis_two.tooltip_hex" theme="bg-[#30435b]">HEX</Tooltip>)”。旁边的那串数据就是编码的消息。`,
      paragraph_three: `复制该值并粘贴到代码框中。`,
      tooltip_block_explorer: `所谓 <a href="https://bitcoinops.org/en/topics/block-explorers/" target="_blank" rel="noreferrer">区块浏览器</a> 是查看比特币交易信息的便捷工具。`,
      tooltip_hex: `HEX 是十六进制的简称，一种以 16 为基数的数字系统。`,
      view_block_0: `查看区块 0`,
      placeholder: `将你找到的值粘贴在这里`,
    },

    genesis_three: {
      title: `创世`,
      nav_title: `解码消息`,
      heading: `让我们解码消息`,
      paragraph_one: `你找到的消息是用 HEX（十六进制）编码的。现在我们会运行一条命令将其转为 ASCII，让它变得可读。`,
      paragraph_two: `复制并粘贴下面的命令到代码框中的终端里，然后按 Enter。`,
      terminal_challenge_lines: `在这里输入你的命令并按 Enter...\n 变量 $scriptSigHex 已经为你定义好。\n\n var $scriptSigHex = '04fff...e6b73'`,
      waiting_for_input: `等待你输入并运行脚本……`,
      success: `太棒了！解码出来的消息引用了 2009 年 1 月 3 日的 <Link href="https://en.bitcoin.it/wiki/Genesis_block" target="_blank" className="underline">泰晤士报（The Times）</Link> 头版，那正是中本聪挖出创世区块的同一天。非常酷！这条消息也让我们更理解他创造比特币的动机。\n\n继续前进吧。`,
    },

    genesis_four: {
      title: `创世`,
      nav_title: `你的第一次成功`,
      subtitle: `恭喜！你完成了第一个挑战！`,
      paragraph_one: `你找到了中本聪嵌入创世区块的秘密消息。接下来我们要扩展你刚学到的内容。准备在下一关解读一个与故事相关的重要线索。`,
    },

    transacting_one: {
      title: `交易`,
      nav_title: `交易包含什么`,
      heading: `交易包含什么？`,
      paragraph_one: `一笔交易包含两个主要部分：输入和输出。在上一关我们解码了输入中的秘密消息。这次我们将解码一个属于输出部分的消息。`,
      paragraph_two: `在下面这笔交易中，我们要找到类型为 OP_RETURN 的输出。`,
    },

    transacting_two: {
      title: `交易`,
      nav_title: `寻找 OP_RETURN`,
      heading: `OP_RETURN`,
      paragraph_one: `比特币还有另一种隐藏消息的方式。比特币脚本中有一个特殊的操作符叫 OP_RETURN，它允许用户在交易输出中写入消息。我们来找找看。`,
      paragraph_two: `1. 点击 <Link href="https://blockstream.info/tx/ff9148605a772a51cba39004df5fb042d40515967a3e38ff5294cfd017c452a9" target="_blank" className="underline">这里</Link> 打开特定交易。`,
      paragraph_three: `2. 展开详情，找到类型为 “OP_RETURN” 的部分。`,
      paragraph_four: `3. 找到 “SCRIPTPUBKEY (ASM)” 字段。看到 “OP_RETURN OP_PUSHBYTES_33" 了吗？这些叫操作码（opcode）。我们真正关心的是它后面的那串内容。`,
      paragraph_five: `4. 复制 “OP_RETURN OP_PUSHBYTES_33” 后面的长串数字，并将其粘贴到代码框中。`,
      input_challenge_label: `输入 OP_RETURN 内容`,
    },

    transacting_three: {
      title: `交易`,
      nav_title: `解码 OP_RETURN`,
      heading: `另一条秘密消息`,
      paragraph_one: `我们已经找到了交易输出中保存消息的部分。`,
      paragraph_two: `剩下的只需像上一关一样进行解码即可。你可以在 <Link href="https://blockstream.info/tx/ff9148605a772a51cba39004df5fb042d40515967a3e38ff5294cfd017c452a9?expand" className="underline">这里</Link> 重新查看交易。`,
      terminal_challenge_success: `正确！干得漂亮。\n\n 你可以看到，这条线索是一个地址。前往它吧。\n\n 你的下一个挑战正在那里等你。`,
      terminal_challenge_lines: `在这里输入你的命令并按 Enter...\n\n 命令：\n echo $scriptPubKeyBytes | xxd -r -p \n\n 注意：这次没有为你预设 $scriptPubKeyBytes，你需要将它替换成上一页找到的字符串。`,
      terminal_challenge_error: `差一点！记住，这次 $scriptPubKeyBytes 没有为你定义。`,
    },

    outro_one: {
      title: `结尾`,
      nav_title: `冒险开始`,
      paragraph_one: `你冲向车库，坐进你父亲留下的旧 Budgetcopter 飞行车，输入坐标，驶向 21 区。`,
      paragraph_two: `尽管你对猫过敏（甚至对全息猫也会过敏），但全息猫坚持要跟来。你反对，但猫就是猫。`,
      button_text: `完成第一章`,
    },

    outro_two: {
      title: `你做到了！`,
      nav_title: `章节完成`,
      description: `太棒了！你完成了第一章，并学会了很多关于哈希和交易的知识。感觉如何？`,
    },

    end: {
      save: `保存我的进度`,
      next: `继续，不保存`,
      feedback: `提交反馈`,
    },
    resources: {
      genesis_two: {
        scriptsig_heading: `ScriptSig`,
        scriptsig_paragraph: `“scriptSig” 是你在创建新交易输入时提供的脚本。它本质上是你的“解锁脚本”，用于证明你有权花费被引用的 UTXO。“scriptSig” 就是填入交易输入 ScriptSig 字段的数据。`,
        block_explorer_heading: `区块浏览器`,
        block_explorer_paragraph: `区块浏览器是探索与理解区块链网络的重要工具。它提供用户友好的界面，方便查看交易记录、余额，以及追踪每个区块与交易的进度。`,
        tip: `展开区块中的交易后，在 coinbase 输入中寻找 scriptSig（HEX）字段。`,
      },
      genesis_three: {
        bash_heading: `Bash 命令`,
        bash_paragraph: `我们使用一些基本 bash 命令来逆转中本聪对创世区块文本进行的压缩处理。`,
        tip: `xxd 命令的主要功能是将二进制文件转为 HEX。加上 -r 选项时则反向操作，把 HEX 转为二进制。对于 ASCII 字符串，转换后的内容是可读的。“-p” 会以连续 HEX 格式输出，使读取结果更清晰。`,
      },
      transacting_two: {
        transactions_heading: `交易`,
        transactions_paragraph: `在加密货币世界中，一笔交易就像一次原子级支付，它通过销毁旧币并生成新币来完成转账。当用户发起交易时，其实是在告诉区块链：把旧币从一个钱包“销毁”，并在另一个钱包“创建”新币，从而更新账本。`,
        bitcoin_script_heading: `比特币脚本`,
        bitcoin_script_paragraph: `比特币脚本是一种简单的基于栈的脚本语言，用于定义比特币在什么条件下可以被花费。它由一系列操作码（opcode）组成，用来指示对脚本数据执行的操作。`,
        asm_heading: `ASM`,
        asm_paragraph: `当你看到 scriptSig 或 scriptPubKey 旁边写着 “ASM”，表示其内容以汇编格式展示，这是一种更易阅读的脚本指令形式。`,
        tip: `给定 OP_Pushbytes_33，我们寻找的是一个长度 33 字节（共 66 个十六进制字符）的字符串。`,
      },
      transacting_three: {
        secrets_heading: `比特币中的秘密`,
        secrets_paragraph: `如前一关所示，将秘密嵌入比特币脚本从创世区块开始就是比特币历史的一部分。人们将内容写入区块链的目的多种多样——存储信息、传递价值、甚至传递消息。`,
        tip: `使用 xxd 解码时，记得这次你需要直接输入整段 HEX 字符串，而不是变量。`,
      },
    },
  },

chapter_two: {
    title: `制定哈希计划`,
    paragraph_one: `中本聪给你的坐标果然没有让你失望，只是有点不幸：那是一座仓库，而且还是阴沉、被遗弃的那种。`,
    paragraph_two: `你驾驶着你的预算直升机围着仓库绕了不下三圈。是啊，唉，看样子你还是得进去。你的预算热感探测器除了黑暗什么都探测不到。如果有人知道这个地方存在，那他们上一次来这里恐怕只存在于记忆里。`,

    intro_one: {
      title: `介绍`,
      nav_title: `仓库`,
      paragraph_one: `—HOLOCAT：“天啊，这是什么破地方。这里最好至少存着点电子凤尾鱼。我甚至愿意凑合吃点赛博猫粮……”`,
      paragraph_two: `你降落，稳住身形，寻找一个可以进入的地方。那边，破掉的窗户应该能用。你拿砖头把剩下的玻璃敲掉，跳了进去。整栋建筑里摆满了成千上万台积灰但保存良好的比特币矿机。`,
      paragraph_three: {
        a: `—HOLOCAT：“这可不是仓库；这是博物馆。我觉得这些是范德普尔家族的旧式挖矿设备。在比特币早期，矿工会用通用电脑来挖矿。但几年后矿工们意识到，他们可以使用带一种特殊芯片的机器，这种芯片叫应用专用集成电路，简称 `,
        b: `。这些芯片只做一件事：挖比特币。它们专注单一任务，因此效率极高，让矿工能花更少的能量获得优势。你能相信人们曾经用笔记本电脑挖矿吗？"` ,
      },
      paragraph_four: `这就解释了为什么范德普尔家族的收藏里会有这么多机器。`,
      tooltip_one: {
        question: `什么是 ASIC 矿机？`,
        link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=What%2520is%2520an%2520ASIC%2520miner%253F`,
        highlighted: `ASIC`,
      },
    },

    intro_two: {
      title: `制定哈希计划`,
      nav_title: `打开电脑`,
      paragraph_one: `角落里有一台昏暗、几乎快坏掉的电脑显示器，上面贴着一张纸条在闪烁。纸条上写着：“把它们打开，笨蛋。”`,
      paragraph_two: `—HOLOCAT：“真没礼貌。哇；机械键盘。我听说过这种东西。据说它们吵得足以让人听力受损，最后被禁用了。”`,
      paragraph_three: `Holocat 跳到键盘上并走来走去，告诉你需要按哪些键。`,
    },

    hashing_one: {
      title: `零`,
      nav_title: `电脑开始运转`,
      paragraph_one: `也不知道是凑巧，还是 Holocat 真的知道自己在做什么，她踩出的随机字母和数字变成了……更多的随机字母和数字？`,
      list_one: `> QX23Y6VGECTUKSNIEUTUB[P[pihof`,
      list_two: `> 1c31d1d9fb848a505fc0cdbea848ff1bdd46a9ed4d639d413d3a93035194eedf`,
      paragraph_two: `显示器显示：“哈希错误。请重试。”`,
      paragraph_three: `Holocat 随便乱按当然不会是对的。她只是只傲娇的全息猫！`,
      paragraph_four: `如果你输入别的东西，会发生什么？`,
    },

    hashing_two: {
      title: `零`,
      nav_title: `尝试哈希点什么`,
      heading: `输入任意内容`,
      return_hash: `下面你会看到输入被转换成哈希`,
      progress_message: `继续……`,
      success_message: `好，玩得不错。我们继续吧。`,
    },

    hashing_three: {
      title: `零`,
      nav_title: `SHA256 的力量`,
      heading: `你有没有注意到哈希有什么特别之处？`,
      list_one: `就像指纹一样，哈希是唯一的。除了一些极端罕见的情况，两份不同的数据永远不应该生成相同的哈希。`,
      list_two: `哈希函数是单向的。你无法从哈希反推出原始数据。`,
      list_three: `哈希非常可靠，因为它是确定性的。你可以反复对同一份数据做哈希，每次都会得到完全相同的结果。`,
      paragraph_one: {
        a: `这里用到的函数叫 `,
        b: `，这是非常流行的一种选择。`,
      },
      paragraph_two: `现在，让我们看看你能不能找到一个特定的哈希。`,
      paragraph_three: `找到一个以“0”开头的哈希。继续尝试不同输入直到找到我们要的哈希。`,
      tooltip_one: {
        question: `SHA-256 在比特币中是如何使用的？ `,
        link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=how%2520is%2520SHA-256%2520used%2520in%2520bitcoin%253F`,
        highlighted: `SHA-256`,
      },
    },

    hashing_four: {
      title: `零`,
      nav_title: `找到一个以零开头的哈希`,
      heading: `不断输入，直到你找到一个以零（“0”）开头的哈希`,
      hint_prompt: `需要一个 <Tooltip id="hint_prompt" position="bottom" theme="bg-[#5e212a]" offset="-1" content="chapter_two.hashing_four.hint_tooltip">提示</Tooltip> 吗？`,
      hint_tooltip: `<span className="text-m whitespace-nowrap leading-none text-white/50">试试输入：</span> <span className="whitespace-nowrap text-white">popcorn</span>`,
    },

    hashing_five: {
      title: `零`,
      nav_title: `加大难度`,
      heading: `这不算太难吧！`,
      paragraph_one: `我们再来点挑战。试着找到一个以两个零（“00”）开头的哈希。`,
    },

    hashing_six: {
      title: `零`,
      nav_title: `找到一个以两个零开头的哈希`,
      heading: `不断输入，直到你找到一个以两个零（“00”）开头的哈希`,
      hint_prompt: `需要一个 <Tooltip id="hint_prompt" position="bottom" theme="bg-[#5e212a]" offset="-1" content="chapter_two.hashing_six.hint_tooltip">提示</Tooltip> 吗？`,
      hint_tooltip: `<span className="text-m whitespace-nowrap leading-none text-white/50">试试输入：</span> <span className="whitespace-nowrap text-white">trigonometry</span>`,
    },

    scripting_one: {
      title: `自动化`,
      nav_title: `为 nonce 做哈希`,
      heading: `让电脑替你完成这件事。`,
      paragraph_one: `好吧，这一步可能花了你不少时间。现在想象一下，如果要找一个以五个或十个零开头的哈希。这就是比特币网络给矿工出的难题：当他们想提交带有交易的新区块时，必须完成这种工作。`,
      paragraph_two: `矿工会把他们想写进区块的所有信息——例如前一区块头哈希、区块中要包含的交易的哈希（包括 coinbase 交易）、时间——以及一个随机数，称为 nonce（只使用一次的数字）组合起来。然后把这些东西输入哈希函数，用来生成所谓的区块哈希。`,
      paragraph_three: `在比特币刚发布时，矿工只需在区块头里把 32 位 nonce 字段不断加 1 来循环尝试。但随着矿工变得更强大、更高效，难度变得更高。很快，常常出现把 32 位字段所有可能值跑完也找不到一个低于目标难度的解的情况。`,
      paragraph_four: `为此，矿工开始尝试改动区块头的其他部分，例如时间或者要包含的交易。`,
      paragraph_five: `比特币网络有一个难度设定，只接受以特定数量的零开头的区块哈希。我们称之为“难度”，每 2016 个区块调整一次。`,
      paragraph_six: `下一个任务：写个脚本，找到一个以五个零（00000）开头的哈希。`,
      tooltip_one: {
        question: `什么是目标难度？ `,
        link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=what%2520is%2520target%2520difficulty%253F`,
        highlighted: `target difficulty`,
      },
    },

scripting_two: {
  title: `自动化`,
  nav_title: `构建哈希函数`,
  paragraph_one: `好的，现在是时候编写并运行你自己的代码了。写一个脚本，生成一个以五个零（"00000..."）开头的 sha256 哈希。你的代码应该反复调用 sha256 函数，并使用不同的输入，直到输出满足这个要求。你应该尝试在循环中递增一个整数来获得不同的输入。在密码学中，这个数字通常被称为 "nonce" 或“一次性使用的数字（number used once）”。`,
  python: {
    paragraph_two: `当你找到一个哈希以五个零开头的 nonce 时，从函数中返回该 nonce。我们使用 python 的 hashlib 库来帮助你编写这个函数，如果需要，你可以使用以下外部资源：`,
    list_one: `<Link href="https://docs.python.org/3/library/hashlib.html" target="_blank" className="underline">hashlib 文档</Link>`,
    list_two: `<Link href="https://datagy.io/python-sha256/" target="_blank" className="underline">Python 教程函数</Link>`,
  },
  javascript: {
    paragraph_two: `当你找到一个以五个零开头的哈希时，返回该 nonce。我们使用 JavaScript 的 crypto 库来帮助你编写这个函数，如果需要，你可以使用以下外部资源：`,
    list_one: `<Link href="https://www.geeksforgeeks.org/node-js-crypto-createhash-method/" target="_blank" className="underline">crypto 文档</Link>`,
    list_two: `<Link href="https://www.educative.io/answers/what-is-node-cryptocreatehashalgorithm-options" target="_blank" className="underline">JavaScript 教程函数</Link>`,
  },
},

mining_one: {
  title: `进入矿场`,
  nav_title: `挖矿区块`,
  heading_one: `既然我们知道挖矿如何运作，让我们看看它的实际运作`,
  heading_two: `你现在正在挖矿`,
  heading_three: `干得漂亮！`,
  heading_four: `让我们挖到 100 个区块`,
  heading_five: `你做到了！`,
  paragraph_one: `现在，比特币网络要求区块的哈希必须以十个前导零开头。让我们开始吧！`,
  paragraph_two: `在这个简单的模拟中，我们假设每个区块包含 3,500 笔交易，以及 0.061 BTC 的奖励和手续费。`,
  paragraph_two_one: `看看你能否启动这些矿机。`,
  paragraph_three: `你在上一课中编写的用于不断计算哈希的代码正在运行。`,
  paragraph_four: `一旦找到一个以十个零开头的哈希，它就会停止。`,
  paragraph_five: `看到 nonce 字段在递增了吗？那表示你已经尝试了多少次哈希！`,
  paragraph_six: `以下是该 nonce：`,
  paragraph_seven: `得到的哈希是：`,
  paragraph_eight: `它具有所有新区块所需的十个前导零。让我们再挖几个区块。`,
  paragraph_eight_one: `重新启动矿机。`,
  paragraph_nine: `这可能需要一点时间。但这展示了挖掘区块与确认交易到底有多困难。`,
  paragraph_ten: `哇！为了完成所有这些哈希计算花了不少算力。看看试了多少个 nonce！提升算力（也就是你每秒能尝试多少个哈希）真的很有帮助。`,
  paragraph_eleven: `如预期所示，由于每个区块包含 3,500 笔交易，挖出的 100 个区块共确认了 350,000 笔交易。`,
  paragraph_twelve: `看起来你也为所有这些挖矿获得了不错的奖励！除了区块补贴（网络为每个区块提供的奖励）外，你还获得了额外的交易手续费收入。`,
  paragraph_thirteen: `记住，这只是一个模拟，理论上每个区块平均需要 10 分钟。`,
  paragraph_fourteen: `另外，如果我们真的在当前主网挖矿，挖这些区块将需要数量级更高的算力。`,
  progress_bar_title: `区块数量`,
  progress_bar_one: `Nonce`,
  progress_bar_two: `每秒哈希数`,
  progress_bar_three: `已确认交易数`,
  progress_bar_four: `获得的比特币`,
  button_hash: `提升十倍算力`,
  ten_x_hint: `点一下 100x 按钮来提升哈希速度！`,
},
outro_one: {
  title: `结尾`,
  nav_title: `章节完成`,
  heading: `干得好！`,
  paragraph_one: `机器轰然启动。一切似乎都在正常运作。旧显示器上出现一张地图，显示全球其他装满 Vanderpoole 家族旧矿机的仓库位置。看起来，当你完成挖矿挑战时，它们都被激活了！`,
  paragraph_two: `—HOLOCAT：“看，有一条消息。”`,
  paragraph_three: `“干得好。这将帮助比特币回到每十分钟一个区块。” —— 中本聪`,
  paragraph_four: `他又来了？`,
},
resources: {
  hashing_two: {
    hash_functions_heading: `哈希函数`,
    hash_functions_paragraph: `哈希函数是任何能够将任意大小的数据映射到固定大小数值的函数。哈希函数返回的数值被称为哈希值、哈希代码、摘要，或简称哈希。这些值通常用于索引固定大小的表，称为哈希表。使用哈希函数索引哈希表被称为哈希或散列存储。`,
    tip: `继续输入！由于 SHA-256 算法，任何新的输入都会产生完全随机的哈希，即使输入非常相似。`,
    spoiler: `试试 8 个字符的内容。`,
  },
  hashing_four: {
    power_of_random_heading: `随机性的力量`,
    power_of_random_paragraph: `就像一个完全随机的场景一样，在概率意义上，SHA-256 对每次新增的数据都是完全随机的。如果你对小说《战争与和平》进行哈希，再在原文中加入一个字母，结果会是完全不同的哈希。每个新字符都会以完全随机的方式改变哈希。考虑到十六进制系统中有 16 种可能字符（0-9 和 a-f），找到一个以 '0' 开头的哈希的概率是多少？`,
    tip: `你能算出来吗？每位字符有 16 种可能，那么找到以 '00' 开头的哈希几率是多少？那 '000' 呢？`,
    spoiler: `试试以字母 's' 开头的词。`,
  },
  hashing_six: {
    collision_resistance_heading: `SHA256 与抗碰撞性`,
    collision_resistance_paragraph: `SHA-256 返回一个 256 位（64 字符）的哈希值，它是输入数据的唯一表示。它属于基于 Merkle–Damgård 结构的一类哈希函数，这种结构通过将输入消息划分为固定大小的块，并使用链式机制迭代处理这些块，将每个块的输出与前一个块的结果组合，直到处理完整条消息，以生成最终哈希值。SHA-256 的强安全性与抗碰撞性使其成为现代密码学中确保数据完整性和认证的基石。`,
    tip: `本课没有真正的提示。随着你在 Saving Satoshi 中继续前进，我们会越来越少地牵着你的手，让你更自主地找出答案。`,
    spoiler: `既然每个新字符都会重新计算一个完全随机的哈希，你可以不断添加新字符直到得到以 '00' 或更多零开头的哈希……或者试试单词 trigonometry。`,
  },
  scripting_one: {
    hash_libraries_heading: `哈希函数`,
    hash_libraries_paragraph: `Node.js 的 crypto 库和 Python 的 hashlib 库是实现这些算法的代码库，它们为开发者提供了有用的工具。这些库经过严格审查，以确保其准确性和安全性，因为许多人依赖它们来保护重要系统。`,
    nonce_heading: `Nonce`,
    nonce_paragraph: `Nonce，意为“一次性使用的数字（number used once）”，是用于各种密码学与计算过程中的随机或半随机数。它的主要作用是引入不可预测性，确保某个操作或计算不能轻易被重复或预测。nonce 对比特币挖矿的安全性至关重要，但我们将在之后进一步了解……`,
    tip_one: `确保你正确解码输入。哈希算法通常返回字节编码的对象，但我们希望以 hex 格式阅读它！`,
    tip_two: `想一想如何创建一个函数，让它一直运行直到答案等于特定值。`,
    tip_three: `记得使用 <span className="p-1 font-mono bg-[#0000004D] m-1">console.log()</span> 或 <span className="p-1 font-mono bg-[#0000004D] m-1">print()</span> 输出你的答案。这是我们的 IDE 验证你的答案的唯一方式。`,
  },
  mining_one: {
    mining_heading: `挖矿`,
    mining_paragraph: `挖矿是这些概念结合之处。比特币挖矿是创造新比特币并将交易添加到区块链的过程。矿工们通过寻找每个区块中唯一有效的 “nonce” 来竞争解决复杂的数学难题。这个工作量证明过程需要大量计算能力和能源，使得它成为一种安全、去中心化的交易验证方式。成功的矿工将获得新生成的比特币以及交易手续费，他们在维护比特币网络的完整性中扮演关键角色。`,
    difficulty_heading: `难度`,
    difficulty_paragraph: `挖矿难度使得区块能保持平均每 10 分钟产生一个新区块。`,
    spoiler: `没有可剧透的内容！阅读完本课即可。在未来课程中，你将有更多机会展示你的挖矿知识！`,
  },
},
},
chapter_three: {
  title: `51% 攻击`,
  paragraph_one: `你打开区块浏览器地址，看到区块回到了每十分钟一个。奇怪的是，Holocat 在所有 ASIC 的噪声中竟然睡着了。`,
  paragraph_two: `猫啊，你还能怎么办呢？`,
  paragraph_three: `然而，有些不对劲。区块是空的，交易没有处理。你出错了吗？还是巧合？电脑屏幕上又弹出一条消息，把 Holocat 吵醒了。`,
  paragraph_four: `这不是巧合。`,

  intro_one: {
    title: `简介`,
    nav_title: `哈希分析`,
    paragraph_one: `—中本聪：“嘿，你！对，你！记得我吗？比特币现在正遭受 51% 攻击！当你上线那些矿机后，Vanderpoole 又重新启动了 BitRey 的 ASIC 并开始挖空区块。问题是，这不仅仅是他的机器。他利用标准 ASIC 固件的后门感染了现有矿机，使它们只能挖空区块。他试图挟持比特币生态系统，迫使人们支持增加比特币供应。快做点什么，笨蛋！”`,
    paragraph_two: `老旧的电脑咳出一阵灰尘，然后生成一个名为“电子表格”的数据包，包含一些最大比特币矿工的联系方式以及病毒补丁。你越早把补丁传给其他矿工，他们就越早能重新控制自己的矿机，并加入对抗 BitRey 的行动。`,
    paragraph_three: `—HOLOCAT：“我们还有工作要做。嗯，其实是你做。我得穿墙吓吓老鼠。”`,
  },

  solo_one: {
    title: `你 vs. BitRey`,
    nav_title: `单独挖矿`,
    step_zero_heading: `试一试`,
    step_zero_paragraph_one: `在等待你联系的矿工时，你决定看看能否单独抵挡 BitRey。也许你可以在没有任何帮助的情况下结束空区块。你的哈希率情况如下。你觉得会怎么样？`,
    step_one_heading: `开始比赛`,
    step_one_paragraph_one: `现在我们要挖 100 个区块，看看你能在 BitRey 面前堆积多少区块。`,
    step_two_heading: `不太顺利！`,
    step_two_paragraph_one: `糟糕，我们的算力不足以与 BitRey 和病毒控制的矿机竞争。让我们看看能否和其他矿工一起在接下来的 100 个区块中击败 BitRey。比特币已经运行了一个多世纪，它不会轻易倒下。`,
  },

  pool_one: {
    title: `矿池 vs. BitRey`,
    nav_title: `寻找伙伴`,
    waiting_screen_heading: `我们需要支援！`,
    waiting_screen_paragraph_one: `你仓库里的矿机没戏。如果你把算力与其他矿工结合，或许可以抵挡住 BitRey 的攻击。`,
    waiting_screen_paragraph_two: `我们先等其他人加入你的行动，好让我们合力作战。`,
    waiting_button: `等待中...`,
    continue_button: `出发吧`,
  },

  pool_two: {
    title: `矿池 vs. BitRey`,
    nav_title: `一起挖矿`,
    step_zero_heading: `出发`,
    step_zero_paragraph_one: `通过将你的哈希率与其他矿工合并，你能抵挡住 BitRey 吗？`,
    step_two_heading: `又失败了！`,
    step_two_paragraph_one: `出了点问题。只有 Hashrate Hoppers 找到了区块。你觉得这是为什么？`,
  },

  coop_one: {
    title: `合作 vs. BitRey`,
    nav_title: `出现问题`,
    heading: `事情还不完全对劲。`,
    paragraph_one: `拥有最多算力的 Hashrate Hoppers 找到了所有你的区块，但其他矿工什么都没找到。`,
    paragraph_two: `问题在于大家在挖矿时都检查相同的 nonce。怎样才能更好地协调？`,
    paragraph_three: `你决定在准备区块数据时为每个人在 “extraNonce” 中放入唯一标识，以防止重复劳动。`,
  },

  coop_two: {
    title: `合作 vs. BitRey`,
    nav_title: `extraNonce`,
    heading: `什么是 extraNonce？`,
    paragraph_one: `对于 Stratum 挖矿池协议（非比特币协议），coinbase 交易还有一个叫“extra nonce”的字段。提供矿工区块数据时，矿池会将 extra nonce 分成两部分：“extranonce1”和“extranonce2”。`,
    paragraph_two: `将 extra nonce 分成两部分有几个好处：`,
    list_one: `防止矿池参与者做重复工作。`,
    list_two: `允许矿池将相同的交易列表发送给所有联合挖矿的矿工。这意味着矿工只需更新 “extranonce2”，而无需更改区块中包含的交易。`,
    list_three: `“extranonce1” 让矿池能够识别并确定每个矿工的贡献，因为每个矿工都有自己的 “extranonce1”。`,
    paragraph_three: `参与矿池的矿工更新 “extranonce2” 并循环尝试区块头中的 nonce。如果没有找到解决方案，他们会用不同的 “extranonce2” 重复此过程，直到成功为止。`,
    paragraph_four: `让我们再次尝试使用这种方法分配工作。`,
  },

  coop_three: {
    title: `合作 vs. BitRey`,
    nav_title: `团队挖矿`,
    step_zero_heading: `再来一次...`,
    step_zero_paragraph_one: `现在我们使用改进后的策略分配 nonce 空间，看看是否有机会抵挡 BitRey。`,
    step_two_heading: `你做到了！`,
    step_two_paragraph_one: `你和其他矿工一起成功抵挡了 BitRey 对网络的接管企图。`,
  },

  split_one: {
    title: `奖励分配`,
    nav_title: `公平分配`,
    heading: `干得漂亮。`,
    paragraph_one: `不仅你防御了网络免受 BitRey 的攻击，你还获得了比特币作为奖励！`,
    paragraph_two: `每挖出一个区块，矿工都会获得比特币奖励。如果多人参与同一个区块的挖矿，矿工群体（矿池）会获得奖励并进行分配。`,
    paragraph_three: `这个奖励由两部分组成：`,
    list_one: `区块中所有交易的手续费`,
    list_two: `区块补贴`,
    paragraph_four: `你和你的矿工朋友总共获得了 7.41 个比特币，现在需要找一个合理的方式分配。应该根据每个人投入的工作量来分配。`,
    paragraph_five: `矿池通过跟踪每个矿工生成的部分解数量来解决这个问题。矿池根据矿工算力为每个矿工分配一个最小难度（低于区块难度）。每隔几秒，矿工找到一个较容易的解并通知矿池。矿池记录所有提交的份额，并据此分配区块奖励。`,
    paragraph_six: `让我们来看看实际操作效果。`,
  },

  split_two: {
    title: `奖励分配`,
    nav_title: `计算奖励`,
    step_zero_heading: `回顾大家的努力`,
    step_zero_paragraph: `我们将重新运行战斗。这次只关注我们矿池，特别是每个矿工找到的部分解数量。`,
    step_two_heading: `来算算看`,
    step_two_paragraph: `看看上面的数字，试着找出一种公平的奖励分配方式。想好了？让我们一步步讲解。`,
    step_three_heading: `哈希率百分比`,
    step_three_paragraph: `正如你所知，这表示每个矿工为找到区块贡献的工作量。但矿池无法知道或测量这个数字，因为矿工只会转发成功解。`,
    step_four_heading: `找到区块的百分比`,
    step_four_paragraph: `找到区块的机会很低，很大程度上取决于运气。尤其在有极高算力矿工的场景下，算力小的矿工可能贡献了工作但从未找到区块。`,
    step_five_heading: `部分解百分比`,
    step_five_paragraph: `现在这个数字可行。矿工定期将解决较容易问题的部分解报告给矿池，这让矿池能够相对准确地测量每个矿工提供了多少工作量。`,
    step_six_heading: `分配奖励`,
    step_six_paragraph: `现在我们可以将 7.41 个比特币根据每个矿工的部分解百分比分配。恭喜！`,
  },

outro_one: {
  title: `结尾`,
  nav_title: `章节完成`,
  heading: `干得漂亮，Vanderpoole！`,
  paragraph_one: `干得好！你和其他矿工通过联合资源，成功抵御了 Vanderpoole 的 51% 攻击。空区块不再被提交，看起来他已经放弃了。`,
  paragraph_two: `现在是收获奖励的时候了！进入下一章来提取你的比特币吧。`,
},
resources: {
  solo: {
    hashrate_heading: `挖矿算力`,
    hashrate_paragraph: `单个矿工的算力是指他们为比特币网络挖矿过程贡献的计算能力。这是他们的挖矿硬件执行必要数学计算以尝试挖掘新区块的速率。单个矿工的算力通常以每秒哈希数（hashes per second, H/s）来衡量，或在大规模情况下以太哈希每秒（TH/s，一万亿次哈希每秒）衡量，这取决于矿工的挖矿规模和硬件能力。`,
  },
  pool: {
    pool_heading: `矿池`,
    pool_paragraph: `矿池在加密货币挖矿中发挥关键作用，为个人矿工提供多项重要好处。通过汇聚众多参与者的计算能力和资源，矿池提高了成功挖掘新区块的概率，从而获得更可预测和稳定的收益。矿池还提供矿工访问先进设备和专业支持的平台，降低了参与门槛，创造公平竞争环境。此外，矿池有效分配奖励，确保矿工按贡献获得应得份额，使加密货币挖矿对更广泛的参与者群体既可行又稳定且有回报。`,
  },
  coop: {
    distribution_heading: `工作分配`,
    distribution_paragraph: `矿池采取措施确保参与者不会为同一个区块挖掘相同的 nonce。这很重要，因为在比特币挖矿过程中，矿工竞争寻找能产生有效区块的 nonce。如果同一矿池的两名矿工同时处理相同 nonce，将效率低下，且只有一人获得区块奖励。为防止这种情况，矿池使用“工作分配”或“任务分配”流程来高效分配工作。矿池会将工作分配给个人矿工或参与者。当需要挖掘新区块时，矿池服务器（或矿池运营者）会为矿工创建一个独特的“任务”。该任务包含挖掘区块所需的所有信息，例如当前未确认交易列表、上一区块头和目标难度。`,
    shares_heading: `提交份额`,
    shares_paragraph: `矿工在分配的任务上工作，并不断尝试找到正确的 nonce。当矿工认为自己找到了解时，会将所谓的“份额”提交给矿池服务器。份额表明矿工正在积极参与解决问题。份额比实际解更容易找到，但它们证明了矿工的努力。`,
  },
  split: {
    payout_heading: `奖励分配方案`,
    payout_subheading: `矿池可以通过几种方式分配区块奖励，这些方式在某些细节上有所不同：`,
    pps_heading: `按份额支付 (PPS)`,
    pps_paragraph: `在 PPS 中，矿工每提交一个有效份额都会获得固定支付，无论矿池是否成功挖出区块。此系统为矿工提供稳定且可预测的收入，是追求收益稳定的矿工的首选。PPS 减少了奖励波动，因为矿工按份额获得报酬，即使加密货币挖矿波动较大，也能提供可靠收入。但如果矿池未能成功挖出区块，PPS 可能会从矿工收益中扣除一定费用，以覆盖运营成本并降低矿池风险。在传统 PPS 中，当矿池遇到困难时，矿工的支付会相应减少。`,
    pplns_heading: `按最近 N 份额支付 (PPLNS)`,
    pplns_paragraph: `PPLNS 考虑矿工在最近 N 份额窗口内的贡献。矿工根据他们在该窗口提交的份额数量和难度获得报酬。PPLNS 鼓励矿工保持活跃，因为它奖励持续参与，并帮助减少矿池跳跃策略的风险。当矿池成功挖出区块时，奖励按最近贡献比例分配，为矿工提供公平、基于表现的收益方式。`,
    pps_plus_heading: `按份额支付 + (PPS+)`,
    pps_plus_paragraph: `PPS+ 为矿工贡献给矿池挖矿的每个份额提供固定支付。但通常 PPS+ 会包含额外奖金或奖励，激励矿工保持活跃并确保矿池稳定可靠。此奖励旨在鼓励矿工长期参与矿池。PPS+ 为矿工提供稳定可预测的收入，同时额外奖励使其成为追求可靠性和额外收益的矿工的理想选择。`,
    fpps_heading: `完全按份额支付 (FPPS)`,
    fpps_paragraph: `在 FPPS 中，矿工为提交的每个份额获得固定支付，无论矿池是否成功挖出区块。这种方法为矿工提供稳定可预测的收入，是追求可靠收益矿工的理想选择。与传统 PPS 不同，FPPS 确保矿工为其贡献获得全额报酬，即使矿池偶尔遇到困难，也不会扣除。它是一种稳定、直接的分配方式，适合寻求稳定收入的矿工。`,
  },
},
},

chapter_four: {
  title: `领取你的 1.61 个比特币`,
  paragraph_one: `呼，好险！你还在因与 BitRey 的战斗而发抖，但胜利的喜悦让你松了一口气。`,
  paragraph_two: `你坐在办公桌前，深呼吸，闭上眼睛，回想着今天的事件。`,

  intro_one: {
    title: `简介`,
    nav_title: `保住奖励`,
    paragraph_one: `—HOLOCAT：“我们中的一个最好先休息。你需要开始联系其他矿工。他们会比世界还想知道得更多。”`,
    paragraph_two: `你坐在 ButtLift 悬浮办公桌前，回放今天的事件。Vanderpoole。BitRey。矿工们从未同意关闭抗议的事实。这一切可能都是真的吗？这一切是安排好的吗？而且你还要照顾这只猫多久？（远处，传来喵声。）`,
    paragraph_three: `无论接下来发生什么，你都需要资金。等一下！你还没领取与 BitRey 竞争所得的挖矿奖励！你决定现在提取它们。`,
  },

  public_key_one: {
    title: `公钥`,
    nav_title: `密钥对`,
    heading: `关于密钥对`,
    paragraph_one: `根据矿池信息，你可以领取 1.61 个比特币，这是你之前挖矿所得的奖励。`,
    list_one: ` 私钥`,
    list_two: `公钥`,
    paragraph_two: `等等，你甚至还没有钱包！你可能想知道在哪里可以买到钱包。虽然你可以购买硬件来建立某些类型的钱包，但实际上你也可以用电脑或移动设备自己创建一个。来动手吧！`,
    paragraph_three: `如果你曾经注册过账户，你会得到一个个人代码。在密码学中，这被称为“私钥”，它通常属于一对密钥：`,
    paragraph_four: `创建钱包并控制其中资金只需要一个密钥对。当你想花费比特币时使用私钥；当你想接收比特币时使用公钥。`,
  },

  public_key_two: {
    title: `公钥`,
    nav_title: `椭圆曲线密码学`,
    paragraph_one: `我们已有私钥，这是你注册账户时获得的个人代码。如何由它生成公钥呢？`,
    paragraph_two: `为此，我们需要了解密码学的一个有趣分支——椭圆曲线。这就是椭圆曲线密码学（Elliptic Curve Cryptography, ECC）。`,
    paragraph_three: `ECC 涉及在椭圆曲线上选择特定点并对这些点执行加法和乘法运算。`,
    paragraph_four: `比特币使用特定曲线 secp256k1。图中展示的是简化版本，便于可视化，但遵循相同的数学规则。`,
    paragraph_five: `我们从曲线上一个特定点开始，称为`,
    tooltip_one: {
      highlighted: `生成点`,
      question: `生成点是什么？`,
      link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=What%2520is%2520the%2520Generator%2520point%253F`,
    },
  },

  public_key_three: {
    title: `公钥`,
    nav_title: `计算公钥`,
    paragraph_one: `要从私钥导出公钥，我们使用生成点在椭圆曲线上重复进行运算。生成点是曲线上的一个特定点，其值属于 secp256k1 标准，始终相同：`,
    paragraph_two: `椭圆曲线上的数学运算类似加法，因此重复运算类似乘法。我们用 * 表示算法，其中 'k' 是私钥，'P' 是对应的公钥：`,
    paragraph_three: `类型转换提示`,
    python: {
      paragraph_three: `完成函数 <span className="text-green">privatekey_to_publickey()</span>，它接受十六进制编码的私钥字符串并返回对应的 GE (Group Element) 对象公钥。`,
    },
    javascript: {
      paragraph_three: `完成函数 <span className="text-green">privateKeyToPublicKey()</span>，它接受十六进制编码的私钥字符串并返回对应的 GE (Group Element) 对象公钥。`,
    },
    paragraph_four: `以下是一些类型转换提示供参考：`,
    success: `干得好！这个公钥挺长的。接下来我们尝试压缩它！`,
  },

  public_key_four: {
    title: `公钥`,
    nav_title: `压缩公钥`,
    paragraph_one: `公钥包含 x 和 y 坐标，总共 64 字节。通过移除 y 坐标并在前面添加一个元数据字节，可以将其压缩为 33 字节。该字节指示 y 坐标是偶数还是奇数。由于椭圆曲线方程只有两个变量，验证者可以仅使用 x 和元数据稍后计算出完整公钥：`,
    paragraph_two_javascript: `如果 y 为偶数，元数据字节应为 '2'；如果 y 为奇数，应为 '3'。完成函数 <span className="text-green">compressPublicKey()</span>，它接受公钥并返回表示压缩公钥的 33 字节十六进制字符串。`,
    paragraph_two_python: `如果 y 为偶数，元数据字节应为 '2'；如果 y 为奇数，应为 '3'。完成函数 <span className="text-green">compress_publickey()</span>，它接受公钥并返回表示压缩公钥的 33 字节十六进制字符串。`,
    success: `太棒了。现在我们有了压缩公钥。接下来需要对它进行哈希并编码为用户友好的格式。`,
  },

address_one: {
  title: `地址`,
  nav_title: `单行道`,
  heading: `干得漂亮！`,
  paragraph_one: `就是这样！你的压缩公钥完成了！我们可以用它做很多有趣的事情，包括生成钱包地址。下一次挑战中我们会学习如何生成地址。`,
  paragraph_two: `注意，生成公钥是单向的。你无法通过公钥推导出生成它的私钥，除非解决一个著名的数学难题，称为`,
  tooltip_one: {
    question: `离散对数问题与比特币有什么关系？`,
    link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=how%2520is%2520the%2520discrete%2520log%2520problem%2520relevant%2520to%2520bitcoin%253F`,
    highlighted: `离散对数问题`,
  },
},

address_two: {
  title: `地址`,
  nav_title: `对压缩公钥进行哈希`,
  paragraph_one: `你还记得哈希挑战吗？事实证明，可以通过对压缩公钥进行哈希生成最简单的比特币地址。比特币使用两种不同的哈希算法：SHA-256 和 RIPEMD-160。`,
  paragraph_two: `步骤：`,
  paragraph_three: `<span className="indent-48">1. 对压缩公钥执行 SHA-256 哈希。</span>`,
  paragraph_four: `<span className="indent-48">2. 对 SHA-256 输出结果执行 RIPEMD-160 哈希。最终结果为 20 字节，以十六进制字符串表示。</span>`,
  paragraph_five: `完成一个函数，该函数接受 33 字节的压缩公钥（十六进制字符串）并返回 20 字节的公钥哈希（十六进制字符串）。`,
  paragraph_six:
    `以下是为你导入的哈希库文档：\n` +
    '<Link href="https://nodejs.org/api/crypto.html#class-hash" target="_blank" className="underline">JavaScript: crypto</Link>\n' +
    '<Link href="https://docs.python.org/3/library/hashlib.html#usage" target="_blank" className="underline">Python: hashlib</Link>',
  success: `太棒了。再一步，你就有钱包地址了。`,
},

address_three: {
  title: `地址`,
  nav_title: `获取 P2WPKH 地址`,
  paragraph_one: `比特币地址有多种类型。在上一个练习中，我们生成了一个 20 字节的压缩公钥哈希。现在，我们希望将该哈希编码为测试网（Testnet）上的 Pay-to-Witness-Public-Key-Hash（p2wpkh）地址。`,
  paragraph_two: `首先需要在哈希前添加见证版本号 '0'。这 21 字节的结果称为 <span className="font-bold">witness program</span>。`,
  paragraph_three: `然后，将 witness program 编码为人类可读的格式，称为 <Link href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#user-content-Specification" target="_blank" className="underline">bech32</Link>。此操作会为数据添加人类可读前缀和校验和。`,
  paragraph_four: `前缀由网络决定：`,
  table_heading: {
    item_one: `网络`,
    item_two: `人类可读前缀`,
  },
  table_rows: {
    key_one: `主网`,
    value_one: `bc`,
    key_two: `测试网`,
    value_two: `tb`,
    key_three: `回归测试`,
    value_three: `bcrt`,
  },
  paragraph_five: `由于我们要创建的是测试网地址，所以使用 'tb' 前缀。`,
  paragraph_six: `数据编码为 bech32 后，我们就得到了一个比特币地址！`,
  paragraph_seven: `完成函数以从压缩公钥哈希创建 bech32 地址。首先生成 witness program，然后使用已导入的 bech32 库将其转换为地址。`,
  paragraph_eight: `你可能需要深入研究 bech32 库并查看代码以找到正确的函数：\n`,
  paragraph_eight_javascript: `<Link href="https://github.com/saving-satoshi/bech32js/blob/main/bech32.js" target="_blank" className="underline">JavaScript: @savingsatoshi/bech32js</Link>\n`,
  paragraph_eight_python: `<Link href="https://github.com/saving-satoshi/bech32py/blob/main/bech32py/bech32.py" target="_blank" className="underline">Python: savingsatoshi_bech32py</Link>`,
  success: `现在你有了一个可以接收比特币的地址。`,
},

tabconf_clue_one: {
  title: `2025 年`,
  nav_title: `Tabconf 2025`,
  paragraph_one: `在废弃仓库深处，你的扫描仪捕捉到一个奇怪的信号。这是世界的碎片化代码，散发着奇特的量子特征。你解码后，得到的不是信息，而是一个 bug 报告——一个紧急邀请。`,
  paragraph_two: `Holocat 出现，眼睛睁大。“就是它，‘故障’。这个 bug……感觉是故意的，就像量子干扰。”`,
  paragraph_three: `Holocat 指示道：“修复这个损坏的脚本。我想知道这是否与 <a target="_blank" href="https://7.tabconf.com/">TABConf</a> 有关，那场 Capture The Bitcoin 的大会。”`,
  paragraph_four: `"复制哈希……" Holocat 催促道，“那就是我们的关键。”`,
},
outro_one: {
  title: `结尾`,
  nav_title: `章节完成`,
  heading: `成功！`,
  paragraph_one: `你创建了属于自己的比特币钱包！`,
  paragraph_two: `你将矿池里的比特币提取到刚创建的钱包中。现在你资金充足，准备迎接 Vanderpoole 和 BitRey 接下来的挑战。`,
},
resources: {
  public_key_three: {
    generator_point_heading: `生成点`,
    generator_point_paragraph: `secp256k1 曲线上的一个特定点。它的值是 secp256k1 标准的一部分，始终相同。这个点与曲线上的其他点没有不同，但被约定为计算的标准起点。没人真正知道为什么选择了这个点。`,
    elliptic_curve_operations_heading: `椭圆曲线运算`,
    elliptic_curve_operations_paragraph: `椭圆曲线有自己的数学规则，因此简单运算如加法和乘法工作方式不同。为了简便起见，通常使用已建立的符号，例如用 “*” 表示类似乘法的运算。`,
    discrete_log_heading: `离散对数`,
    discrete_log_paragraph: `一种数学系统，例如可以进行乘法但不能直接除法。一个简单的比喻是看时钟：11 点过了 3 小时是 2 点，所以可以说“11+3=2”。但是如果想进行“2-x=11”并求 x，会有无限可能答案（3, 15, 27, 39…）。更多信息见 <Link href="https://en.wikipedia.org/wiki/Discrete_logarithm" className="underline">维基百科</Link>。`,
    tip_one: `椭圆曲线点的乘法与普通数字的乘法不同。那么如何进行乘法？注意生成点 <span className="p-1 font-mono bg-[#0000004D] m-1">G</span> 是类型 <span className="p-1 font-mono bg-[#0000004D] m-1">secp256k1.GE</span>。查看该类，了解可以调用的方法。`,
    tip_two: `私钥虽然以十六进制格式提供，但在与生成点相乘前需要转换为数字（JS 中为 BigInt）。`,
  },
  public_key_four: {
    y_coordinate_compression_heading: `公钥压缩`,
    y_coordinate_compression_paragraph: `在椭圆曲线上计算点加法时，你用两个点的坐标找到第三个点的坐标。然而，对于给定的 x 坐标，通常会有两个可能的 y 坐标（某些特殊情况除外）。压缩公钥时，选择其中一个 y 坐标，并只保留 x 坐标，同时附加一个元数据以指示选择了哪个 y 坐标。`,
    tip: `这个挑战其实很简单，我们只需要确定 y 坐标是偶数还是奇数，然后将该元数据添加到公钥前面即可。`,
  },
  address_two: {
    hash_algo_heading: `SHA-256, RIPEMD-160`,
    hash_algo_paragraph: `哈希函数可以处理任意大小的数据，并总是返回固定大小的结果。SHA-256 输出 32 字节，RIPEMD-160 输出 20 字节。输出是确定性的（相同输入总是得到相同输出），但看起来像随机值。哈希函数实际上将数据压缩为小而一致的指纹。`,
    tip_one: `计算 SHA-256 哈希时，确保将压缩公钥作为字节而非十六进制字符串进行哈希。如果使用 JavaScript，需要将十六进制字符串转换为 buffer。`,
    tip_two: `确保按正确顺序执行哈希算法！`,
  },
  address_three: {
    wpkh_heading: `Witness 公钥哈希 (wpkh) 地址`,
    wpkh_paragraph: `比特币地址是为用户设计的字符串，简短、易于复制粘贴，并带有内置校验和以确保复制正确。它安全地编码了比特币输出脚本，接收方可以花费。输出脚本和编码机制有多种类型。在此挑战中，我们使用 bech32 对压缩公钥进行编码，生成所谓的 witness 公钥哈希地址。`,
    network_heading: `主网、测试网、Signet 和回归测试`,
    network_paragraph: `开发比特币软件时，重要的是在使用真钱前测试代码！最简单的方式之一是使用一个新的区块链，生成新的创世区块，币值无关，挖矿免费且容易，并且可随时重置。这些链由独特的节点网络维护，不干扰主网的真实币和节点。Testnet 和 Signet 是两个与主网平行的全球替代比特币链。Regtest 是开发模式，可在本地运行，不需要网络连接。`,
    tip: `仔细查看 bech32 库，找到可使用的确切方法。`,
  },
},
},

chapter_five: {
  title: `真正的中本聪，请站出来`,
  paragraph_one: `夜已深，你很疲惫，但当你闭上眼睛片刻时，又迎来了双重坏消息。`,
  paragraph_two: `1) Vanderpoole 又出现在电视上。`,
  paragraph_three: `2) 他声称自己是中本聪的曾孙。`,
  paragraph_four: `他看起来睡眠不足。`,

  intro_one: {
    title: `介绍`,
    nav_title: `不信任，验证`,
    paragraph_one: `—DEBORAH CHUNK: “Vanderpoole 先生，您最近在反社交媒体上做出了令人震惊的声明，声称自己是中本聪的曾孙。请问这是真的吗？”`,
    paragraph_two: `—VANDERPOOLE: “当然是真的，Deborah。我已经保守这个秘密很久了。你看，我家族几代人都保存着一个不起眼的 CD-ROM。为了保密，我们给它贴上了 <span className="italic">Creed – My Own Prison</span> 标签。它包含我曾祖父中本聪庞大比特币财产的私钥。所以当我代表矿工发言时，也代表中本聪发言。”`,
    paragraph_three: `—DEBORAH CHUNK: “有没有办法验证您真的拥有中本聪比特币的私钥呢？”`,
    paragraph_four: `—VANDERPOOLE: “当然可以。这只是公钥密码学的简单应用。”`,
    paragraph_five: `—DEBORAH CHUNK: 但为什么要等这么久才公开这一惊天秘密呢？`,
  },
  intro_two: {
    nav_title: `Vanderpoole 的大胆宣言`,
    paragraph_one: `—VANDERPOOLE: “我之前没有勇气。一直有关于我家族历史的传言，我本可以轻易证实。但我还没准备好面对那么大的公众关注。毕竟，我住在自己最喜欢的私人岛屿上的一个 14 世纪城堡里的牧场，每周从我的热水浴缸接受 5–6 次类似这样的采访。”`,
    paragraph_two: `—VANDERPOOLE: “但现在比特币的未来悬而未决，我知道是时候面对现实了，特别是 Creed 首张专辑《My Own Prison》里的音乐。” *Vanderpoole 哼唱这张 20 世纪专辑同名曲的旋律*`,
    paragraph_three: `—VANDERPOOLE: “我只能说很抱歉没早点站出来，因为 CD-ROM 还包含了中本聪修改后的比特币计划。你看，我的曾祖父一直后悔将比特币总量限制在 2100 万枚，这也是我计划实现曾祖父梦想、通过硬分叉增加比特币永续发行的原因。”`,
  },
  intro_three: {
    nav_title: `中本聪的消息`,
    paragraph_one: `你的 TXM4H-A 漂浮屏响了起来。你收到一条新消息。`,
    paragraph_two: `—HOLOCAT: 别忘了戳一下我的鼻子。`,
    paragraph_three: `你戳了她的鼻子`,
    paragraph_four: `—SATOSHI NAKAMOTO: “Vanderpoole 并非他所声称的那样。你可以揭穿他。让他使用那个钱包的私钥签署消息，以证明他真的拥有中本聪的比特币。”`,
  },
  derive_message_one: {
    title: `推导消息`,
    nav_title: `消息内容`,
    heading: `Vanderpoole 说他用中本聪的私钥签署了一条消息：`,
    code_one: `-----BEGIN BITCOIN SIGNED MESSAGE----- \n \n 我是 Vanderpoole，我掌控着中本聪用来签署首笔比特币交易（#170 区块确认）的私钥。这条消息由同一私钥签署。 \n \n -----BEGIN BITCOIN SIGNATURE----- \n \n`,
    code_two: `<span className="break-all"> H4vQbVD0pLK7pkzPto8BHourzsBrHMB3Qf5oYVmr741pPwdU2m6FaZZmxh4ScHxFoDelFC9qG0PnAUl5qMFth8k= </span>`,
    code_three: `\n \n-----END BITCOIN SIGNATURE-----`,
    paragraph_two: `这是什么意思呢？`,
  },
  derive_message_two: {
    nav_title: `寻找公钥`,
    paragraph_one: `我们在第 4 章学到，私钥是由生成它的人保密的大随机数。我们可以用椭圆曲线数学从私钥推导出公钥。`,
    paragraph_two: `公钥可作为唯一标识分享，私钥用于证明某人对该标识有控制权。这种证明称为签名（SIGNATURE）。创建签名需要消息和私钥。任何人都可以使用消息副本和对应公钥验证签名。`,
    paragraph_three: `Vanderpoole 提供了签名和消息。那么公钥在哪里？`,
  },
  derive_message_three: {
    nav_title: `找到中本聪的签名`,
    heading: `先找到中本聪的签名`,
    paragraph_one: `#170 区块包含 <link href="https://bitcointalk.org/index.php?topic=155054.0" target="_blank" className="underline">中本聪发给 Hal Finney 的第一笔比特币交易</link>。该交易仅有 <Link href="https://blockstream.info/tx/f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16?expand" target="_blank" className="underline">一个输入</Link>。获取该输入的 scriptSig，它包含中本聪的签名！`,
    placeholder: `在此粘贴数据`,
    success: `很好！这就是中本聪的签名，用于授权将比特币转给 Hal Finney。`,
  },
  derive_message_four: {
    nav_title: `找到中本聪的公钥`,
    heading: `公钥在哪？`,
    paragraph_one: `实际上，它存储在中本聪通过挖掘 #9 区块生成的比特币中。`,
    paragraph_two: `<Link href="https://blockstream.info/tx/0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9?output:0&expand" target="_blank" className="underline">点击链接</Link>访问输入 #0 部分顶部的源交易。这是中本聪通过挖 #9 区块生成的交易。交易生成 50 BTC，并将其锁定到一个公钥下！在 scriptPubKey 中找到以 0411... 开头的数据。`,
    paragraph_three: `公钥位于 script 命令 OP_PUSHBYTES 和 OP_CHECKSIG 之间。粘贴在下方：`,
    placeholder: `在此粘贴数据`,
    success: `就是这样！`,
  },
  derive_message_five: {
    nav_title: `接下来验证签名`,
    paragraph_one: `在上一步中我们看到，中本聪挖 #9 区块获得 50 BTC。他用它作为交易输入（#170 区块）发送 10 BTC 给 Hal Finney 的公钥，并将 40 BTC 返回自己作为找零。中本聪的私钥用于创建签名，授权资金转移。`,
    paragraph_two: `接下来我们需要学习如何验证签名。但还有一个问题……中本聪签署的消息内容是什么？`,
  },
  derive_message_six: {
    nav_title: `推导消息`,
    heading: `从交易中推导消息`,
    paragraph_one: `只看区块浏览器网页就可以看出，比特币交易包含许多不同部分。有些部分是小数字，有些部分是较大数据块。比特币协议有特定算法将交易生成可被私钥签署的消息。`,
    paragraph_two: `我们将总结 <Link href="https://en.bitcoin.it/wiki/OP_CHECKSIG" target="_blank" className="underline">这里</Link 提出的流程。它巧妙地使用 <Link href="https://en.bitcoin.it/wiki/OP_CHECKSIG#Code_samples_and_raw_dumps" target="_blank" className="underline">#170 区块的同一交易</Link> 作为示例。`,
    paragraph_three: `首先，我们需要构建完整交易的原始字节。<Link href="https://blockstream.info/api/tx/f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16/hex" target="_blank" className="underline">我们的区块浏览器</Link>可以帮忙。使用 "hex" API 端点并粘贴整个数据块。`,
    input_challenge_label: `粘贴交易数据块`,
    success_message_line_one: `这是原始交易及其各组件标注：`,
    success_message_line_two: `版本：`,
    success_message_line_three: `输入数量：`,
    success_message_line_four: `输入 #0 来自哪笔交易的哈希：`,
    success_message_line_five: `输入 #0 在资金交易中的索引：`,
    success_message_line_six: `授权花费输入 #0 的 scriptSig：`,
    success_message_line_seven: `输入 #0 序列号：`,
    success_message_line_eight: `输出数量：`,
    success_message_line_nine: `输出 #0 数值（10 BTC 或 1,000,000,000 satoshis）：`,
    success_message_line_ten: `输出 #0 scriptPubKey（Hal Finney 的公钥加 OP_CHECKSIG）：`,
    success_message_line_eleven: `输出 #1 数值（40 BTC 或 4,000,000,000 satoshis）：`,
    success_message_line_twelve: `输出 #1 scriptPubKey（中本聪自己的公钥，用作找零）：`,
    success_message_line_thirteen: `锁定时间：`,
  },
  derive_message_seven: {
    nav_title: `构建签署消息`,
    paragraph_one: `消息中包含自身签名是无法签署的，所以需要移除 scriptSig。在比特币协议中，它实际上被替换为我们花费的交易输出的 scriptPubKey。`,
    paragraph_two: `我们在前一步找到了 scriptPubKey，可以粘贴在第一个空格中。`,
    paragraph_three: {
      a: `我们交易消息最后需要的部分是`,
      b: `。我们将在下一章详细讲解，但现在只需在消息末尾添加值 <span className="font-bold">01000000</span> 即可。`,
    },
    tooltip_one: {
      question: `什么是 sighash 标志？`,
      link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=what%2520are%2520sighash%2520flags%253F`,
      highlighted: `sighash 类型标志`,
    },
    success: `太好了！你已构建出可签署的消息。`,
  },
verify_signature_one: {
  title: `验证签名`,
  nav_title: `验证签名`,
  heading: `终于有了消息！`,
  paragraph_one: `我们还有一个已知由中本聪使用他自己的私钥创建的签名，以及他的公钥。让我们学习如何验证签名，然后我们可以尝试验证 Vanderpoole 的签名。`,
},
verify_signature_two: {
  title: `验证签名`,
  nav_title: `哈希消息`,
  heading: `哈希交易摘要`,
  paragraph_one: `我们在上一步整理的序列化交易数据实际上太长，无法用 ECDSA 直接签署或验证。`,
  paragraph_two: `有没有办法将大块数据压缩为更一致、可管理的形式？当然有：哈希。`,
  paragraph_three: {
    a: `比特币协议使用`,
    b: `将交易压缩为可签署的消息。`,
  },
  paragraph_four: `一旦得到 32 字节的哈希，这些数据就会被重新解释为整数。是的，32 字节的整数（那可是一个非常巨大的数字）！`,
  tooltip_one: {
    question: `为什么比特币中所有地方都使用双哈希 (HASH256)？`,
    link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=Why%2520does%2520everything%2520in%2520bitcoin%2520use%2520double%2520hash%2520%28HASH256%29%253F`,
    highlighted: `双重 SHA256 摘要`,
  },
  success: `干得漂亮！`,
},
verify_signature_three: {
  nav_title: `解码签名`,
  heading: `解码签名`,
  label_one: `粘贴 R 值`,
  label_two: `粘贴 S 值`,
  paragraph_one: `中本聪的签名采用 DER 编码，这是 ASN.1 的一个子集。`,
  paragraph_two: `我们需要提取两个 32 字节数字，分别称为 R 和 S，它们在 DER 序列中各自以 0220 字节前缀开头。无需完整解码 DER blob，只需查找前缀并粘贴 R 和 S 值即可。`,
  paragraph_three: `# 中本聪的签名，来自 #170 区块发送给 Hal Finney 的输入 scriptSig`,
},
verify_signature_four: {
  nav_title: `解码公钥`,
  heading: `解码公钥`,
  label_one: `粘贴 x 坐标`,
  label_two: `粘贴 y 坐标`,
  paragraph_one: `我们在第 4 章学到，公钥实际上是 ECDSA 曲线上的点，意味着它有 x 和 y 坐标。首字节 04 表示“未压缩”（与第 4 章学到的 02 和 03 相对）。去掉首字节，剩下的数据即为 32 字节的 x 和 y 坐标。复制粘贴即可。`,
  paragraph_two: `# 中本聪的公钥，来自 #9 区块 coinbase 输出 scriptPubKey`,
},
verify_signature_five: {
  title: `验证签名`,
  nav_title: `测试签名`,
  heading: `验证签名！`,
  success: `你成功了！你已验证中本聪的签名！`,
  paragraph_one: `此时我们已具备进行 ECDSA 运算的一切要素。`,
  paragraph_two: `ECDSA 签名验证算法详见 <Link className="underline" href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#Signature_verification_algorithm" target="_blank">这里</Link> 和 <Link className="underline" href="https://www.secg.org/sec1-v2.pdf#page=52" target="_blank">这里</Link>。`,
  paragraph_three: `我们已为你创建了一个包含公钥 X 和 Y 元素的 Group Element 对象。你需要完成 ECDSA 签名验证函数 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">verify()</span>，仅当所有条件有效时返回 True！`,
  paragraph_four: `我们知道中本聪的签名是有效的，自 2010 年起每个比特币全节点都已验证过！如果你的程序未返回 True，则说明有问题。`,
  python: {
    paragraph_five_part_one: `提示：<span className="text-green">pow()</span>`,
    paragraph_five_part_two: `方法可接受负指数和模参数。详情见 <Link className="underline" href="https://docs.python.org/3/library/functions.html#pow" target="_blank">文档</Link>。`,
  },
  javascript: {
    paragraph_five_part_one: `我们提供了辅助函数 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">invert()</span>`,
    paragraph_five_part_two: `，在 JavaScript 中可用于替代原生模幂运算函数。`,
  },
},
validate_signature_one: {
  title: `验证签名`,
  nav_title: `准备消息`,
  heading: `准备 Vanderpoole 的消息以进行验证`,
  paragraph_one: `Vanderpoole 用于作秀的签名使用了 <Link href="https://github.com/bitcoin/bips/blob/master/bip-0137.mediawiki" target="_blank" className="underline">比特币消息签名协议</Link>。计算算法与我们已定义的一样，但数据准备略有不同。`,
  paragraph_two: `首先，我们需要将他的消息编码为字节数组，遵循以下模板：`,
  paragraph_three: {
    pre_link: `然后我们将对该数据进行`,
    highlighted: `双重 SHA-256 哈希`,
    question: `为什么比特币要双哈希？`,
    post_link: `，并将哈希转换为整数。完成函数 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">encode_message()</span>，应返回 32 字节的 hex 值。`,
  },
  success: `干得漂亮`,
},
validate_signature_two: {
  nav_title: `准备签名`,
  heading: `准备 Vanderpoole 的签名以进行验证`,
  paragraph_one: `Vanderpoole 使用的比特币消息签名协议要求签名为 base64 编码。我们需要将该 base64 字符串解码为 65 字节序列。暂时可忽略第一个字节的元数据，其余部分为我们在第 6 步学到的 32 字节 r 和 s 值。`,
  javascript: {
    paragraph_two: {
      post_link: `完成函数 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">decode_sig()</span>。`,
      return: `应返回一个包含 [r, s] BigInt 值的数组。`,
    },
  },
  python: {
    paragraph_two: {
      post_link: `完成函数 <span className="text-green">decode_sig()</span>。`,
      return: `应返回一个包含 (r, s) 值的元组。`,
    },
  },
  success: `干得漂亮`,
},
validate_signature_three: {
  title: `验证签名`,
  nav_title: `看看 Vanderpoole 是否在撒谎`,
  heading: `那么，Vanderpoole 是骗子吗？！`,
  paragraph_one: `让我们收集程序所需的所有组件，并验证 Vanderpoole 的签名是否确实来自与中本聪公钥关联的私钥！请填入缺失的参数，以使用提供的代码执行 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">verify()</span> 函数。`,
  paragraph_two: `然后我们运行程序，看看 Vanderpoole 是否在撒谎。鼓声……`,
  success: `此消息表明签名并非来源于中本聪的公钥，验证失败。`,
},
validate_signature_four: {
  title: `验证签名`,
  nav_title: `找到正确的密钥`,
  heading: `Vanderpoole 是怎么生成那个签名的？`,
  paragraph_one: `Holocat 插话说，BitRey 中有一名叛逃者向我们提供了一份 Vanderpoole 常用公钥列表，也许他用其中一个公钥签署了这条消息。`,
  paragraph_two: `请提供能够成功完成验证的密钥，以便我们确定 Vanderpoole 用哪个公钥签署了这条消息。`,
  paragraph_three: `让我们看看你是否能用这些公钥之一验证 Vanderpoole 的消息和签名？`,
  success: `这个签名对 Vanderpoole 的这个公钥有效，这并不是中本聪！`,
},
outro_one: {
  title: `结尾`,
  nav_title: `章节完成`,
  heading: `Vanderpoole 撒谎了！`,
  paragraph_one: `你学到了比特币最重要的教训之一。你没有盲信，而是进行了验证。<br><br>通过验证，你发现 Vanderpoole 并没有使用中本聪的密钥来签署消息，这大大削弱了他的家族故事、他的可信度，以及 BitRey 的可信度。<br><br>现在，如果你能把那首歌从脑海中清除就好了。`,
},
resources: {
  derive_message_three: {
    op_pushdata_heading: `OP_PUSHDATA`,
    op_pushdata_paragraph_one: `比特币脚本中的 OP_PUSHDATA 在将任意数据插入区块链中起着关键作用。它实际上是一类操作码，允许包含不同大小的数据元素，使比特币脚本语言更灵活。这个操作码对实现各种智能合约功能和自定义交易类型尤其重要。我们知道这应该将 71 字节的数据推送到堆栈上，你能算出这个操作码在十六进制中如何表示吗？你可以在 <Link href="https://en.bitcoin.it/wiki/Script#Constants" target="_blank" className="underline">这里</Link> 阅读更多关于 OP_CODE 的内容。`,
  },
  derive_message_four: {
    op_checksig_heading: `OP_CHECKSIG`,
    op_checksig_paragraph_one: `比特币脚本中的 OP_CHECKSIG 对确保正确的私钥能够花费给定交易至关重要。几乎每个比特币脚本中都会有 OP_CHECKSIG，以确保尝试花费比特币的人能使用给定的密钥进行操作。你可以在 <Link href="https://en.bitcoin.it/wiki/Script#Constants" target="_blank" className="underline">这里</Link> 了解更多 OP_CODE。`,
  },
  derive_message_six: {
    transaction_parts_heading: `交易组成部分`,
    transaction_parts_one: `版本：指示交易的组织方式。`,
    transaction_parts_two: `输入数量：此交易中输入的数量。`,
    transaction_parts_three: `输入 #0 TXID：输入 #0 花费的交易哈希。`,
    transaction_parts_four: `输入 #0 索引：上述 TXID 指定的交易输出索引，提供资金来源。`,
    transaction_parts_five: `Scriptsig：用于授权花费上述输出的数据，通常包含签名。`,
    transaction_parts_six: `输入 #0 序列号：用于花费该输入的序列号。`,
    transaction_parts_seven: `输出数量：指示该交易有多少输出。`,
    transaction_parts_eight: `输出 #0 数额：第一个输出花费的金额，以小端整数表示。`,
    transaction_parts_nine: `输出 #0 scriptPubKey：确定花费资金所需条件的脚本，通常由公钥和其他操作码组成挑战。`,
    transaction_parts_ten: `输出 #1 数额：第二个输出花费的金额，以小端整数表示。`,
    transaction_parts_eleven: `输出 #1 scriptPubKey：确定花费资金所需条件的脚本，通常由公钥和其他操作码组成挑战。`,
    transaction_parts_twelve: `锁定时间：此交易在达到该区块高度前不可确认。`,
  },
  derive_message_seven: {
    sighash_type_flag_heading: `SigHash 类型标志`,
    sighash_type_flag_paragraph_one: `SigHash 标志定义了交易中哪些部分会包含在私钥签名的哈希中。它决定了签名者对交易数据特定部分的承诺范围。SigHash 标志是附加在每个签名末尾的单字节值，并可在同一交易的不同输入间变化。你可以在 <Link href="https://river.com/learn/terms/s/sighash-flag" target="_blank" className="underline">这里</Link> 了解不同类型的 SigHash 标志。`,
  },
  verify_signature_two: {
    tip_one: `JavaScript 提示：你可以使用 <span className="p-1 font-mono bg-[#0000004D] m-1">Buffer.from(someString, 'hex');</span> 将十六进制字符串转换为字节缓冲区`,
    signature_verification_heading: `签名验证`,
    signature_verification_paragraph_one: `签名验证是一种数学算法，一方提供签名数据，该签名仅在知道秘密数字（私钥）的情况下生成。验证过程将签名、公钥和消息进行比较。如果算法输出 TRUE，则签名被认为是有效的。`,
  },
  verify_signature_three: {
    signature_encoding_heading: `签名编码`,
    signature_encoding_paragraph_one: `DER（Distinguished Encoding Rules）签名是一种在比特币中对 ECDSA 签名进行编码的格式。ECDSA 签名由私钥和消息哈希生成，包含两个 32 字节的数字 (r, s)。更多组件可在 <Link href="https://technicaldifficulties.io/2020/07/22/bip-66-unpacking-der-signatures/" target="_blank" className="underline">这里</Link> 了解。`,
  },
  verify_signature_four: {
    eliptic_curve_heading: `椭圆曲线数字签名算法 (ECDSA)`,
    eliptic_curve_paragraph_one: `ECDSA 是比特币使用的加密算法，确保资金只能被合法拥有者花费。公钥由私钥通过椭圆曲线乘法得到，计算简单，但反向推导私钥几乎不可行。这种单向函数是比特币安全的基石。`,
    public_private_key_heading: `公钥与私钥`,
    public_private_key_paragraph_one: `在比特币中，一对密钥用于保证交易安全。私钥保密，用于签名交易并证明地址所有权。公钥由私钥生成，可公开，用于验证签名而不泄露私钥。`,
  },
  verify_signature_five: {
    finite_field_arithmetic_heading: `有限域算术`,
    finite_field_arithmetic_paragraph_one: `ECDSA 中使用有限域算术，操作数字在固定范围内。加减乘及求模逆运算均在该域内进行，这对于比特币椭圆曲线计算至关重要。`,
    ge_and_fe_heading: `群元素 (GE) 与域元素 (FE)`,
    ge_and_fe_paragraph_one: `在椭圆曲线加密中，群元素通常表示曲线上的点。挑战中的 GE 指具有特定 x 和 y 坐标的点。FE 表示有限域元素，用于域内计算。`,
    modular_inverse_heading: `模逆`,
    modular_inverse_paragraph_one: `一个数字 a 的模 m 逆为 b，使得 (a * b) % m = 1。求模逆是 ECDSA 验证过程中的关键步骤，用于计算 u1 和 u2。`,
  },
  validate_signature_one: {
    message_verification_heading: `消息验证的重要性`,
    message_verification_paragraph_one: `消息验证增强比特币生态系统通信的安全性。它允许各方验证消息的真实性和完整性，在 P2P 交易或智能合约通信中尤其重要。此外，消息验证为身份验证和地址所有权证明等应用提供基础，加密保障强化了比特币网络的去信任和去中心化特性。`,
  },
  validate_signature_two: {
    base64_encoding_heading: `Base64 编码`,
    base64_encoding_paragraph_one: `Base64 是一种基本的字节到文本编码方案，可将数据转换为字节，再从字节转换为文本，避免 URL 路径和查询参数问题。与 Base58 编码不同，它仍包含类似字符（0、大写 O、大写 I、小写 l），复制或口述时可能引起混淆。`,
  },
  validate_signature_three: {
    signing_and_ownership_heading: `消息签名与所有权`,
    signing_and_ownership_paragraph_one: `由于比特币的伪匿名性，我们只能有限地证明签名者身份。密钥拥有者可以拒绝签名或故意使用错误的密钥签名。我们唯一能证明的是，创建无效签名的密钥并非能正确签名消息的密钥。`,
  },
  validate_signature_four: {
    one_for_one_heading: `一一对应`,
    one_for_one_paragraph_one: `为了确保 ECDSA 的可靠性和安全性，由私钥创建的签名只能通过对应公钥验证。如果不同私钥能生成相同公钥或签名，将破坏 ECDSA 的安全性。通过这种机制，我们可以知道能够签署该消息的公钥确实拥有对应比特币。`,
  },
},
},

chapter_six: {
  title: `钥匙持有者`,
  paragraph_one: `啊啊！因为你揭露了他的欺诈行为，Vanderpoole 想找你麻烦。不过，尽管 Holocat 的秘密已经暴露，许多害怕的人仍然紧抓着 Vanderpoole 为自己、家族及所谓的祖先编造的神话不放。时代很可怕，人们需要一个英雄。不幸的是，对于许多人来说，他是他们能得到的“最好选择”。`,
  
  intro_one: {
    title: `引言`,
    nav_title: `那真的是中本聪吗`,
    paragraph_one: `—中本聪: ”干得好。现在全世界都能亲眼看到 Vanderpoole 是个骗子。即使有人还不相信，他们在我们的工作完成之前也会明白。”`,
    paragraph_two: `你停顿了一下，意识到到目前为止的每条消息都是以“中本聪”签名的。你之前以为这是一个遵循比特币核心原则的人的化名。他们不可能是真正的中本聪。但你最终决定，值得一问。`,
    paragraph_three: `—”这可能听起来很傻，但你是真正的中本聪吗？”`,
  },

  intro_two: {
    title: `引言`,
    nav_title: `支付 Mika 3000`,
    paragraph_one: `—Holocat: “这可不是最近唯一让你显得傻的事情。”`,
    paragraph_two: `—中本聪: “多年前，比特币就已经远远超出了其创作者的控制。无论 Vanderpoole 还是我，或者我们的后代是谁都无所谓。比特币由社区定义，无法被单个个人或实体——包括中本聪——劫持。证明这一点才是真正的战斗。我希望你不介意，我请你的古怪自由记者朋友联系你。”`,
    paragraph_three: `—他什么？`,
    paragraph_four: `—叮。`,
    paragraph_five: `—Holocat: 别忘了戳我。`,
    paragraph_six: `—Mika 3000: “你很有胆量，但光有胆量是不够的。你发现的只是开始。故事还有更多，我们需要去 Vanderpoole 的私人岛屿才能确切知道‘更多’是什么。这会花费不少，所以我希望你帮忙从你之前帮我设置的多重签名钱包中调出资金。你还留着我的一把钥匙，对吧？”`,
  },
  in_out_one: {
    title: `收支概览`,
    nav_title: `未花费的 UTXO`,
    paragraph_one: `Mika 3000 需要 1 BTC 用于购买去 Vanderpoole 私人岛屿的装备。你决定从第三章的挖矿奖励中给她发送 1 BTC，这些奖励已由矿池发送到你在第四章创建的地址。`,
    paragraph_two: `你打开比特币全节点并执行命令查看你的资金在区块链上的位置。`,
    paragraph_three: `这就是未花费交易输出（UTXO）。你可能认出第四章的压缩公钥哈希和地址。金额也正确：1.61 BTC。`,
  },
  in_out_two: {
    title: `收支概览`,
    nav_title: `接收地址`,
    paragraph_one: `Mika 3000 给了你一个地址来接收你的 1 BTC 捐赠：`,
    paragraph_two: `嗯，这个地址比你的长多了！我想知道为什么……`,
    paragraph_three: `我们需要创建并签署一笔交易，将你的 1.61 BTC 中的一部分发送到该地址。我们在第五章看过中本聪的交易结构，但你的交易会略有不同。如今有更新的创建交易的方法，我们将使用一种叫做隔离见证（Segregated Witness）的协议，将交易版本设为 2。`,
  },
  in_out_three: {
    title: `收支概览`,
    nav_title: `交易步骤`,
    paragraph_one: `隔离见证交易与其旧版交易类似。存在一些全局值，例如版本和锁定时间（locktime）。有一个输入数组（我们要花费的 UTXO）和输出数组（我们想创建的新 UTXO，供他人未来花费）。还有一个 witness 数组，每个输入对应一个 witness，用于放置签名和脚本，而不是 scriptSig。`,
    paragraph_two: `所有这些组件的消息序列化方式在 <Link href="https://en.bitcoin.it/wiki/Protocol_documentation#tx" target="_blank" className="underline">这里</Link> 和 <Link href="https://github.com/bitcoinbook/bitcoinbook/blob/6d1c26e1640ae32b28389d5ae4caf1214c2be7db/ch06_transactions.adoc" target="_black" className="underline" >这里</Link> 有文档说明。`,
  },
  in_out_four: {
    normal: {
      title: `收支概览`,
      nav_title: `Input 类`,
      heading: `查看 Input 类实现`,
      paragraph_one: `这里有两个类的代码：一个是 <span className="font-bold">Input</span> 类，另一个是 <span className="font-bold">Outpoint</span> 类（不是 "output"！）。`,
      paragraph_two: `输入来源于未花费交易输出。如果你将输出描述提供给 <span className="text-green p-1 font-mono bg-[#00000033] m-1 text-base">from_output()</span> 方法，它会创建一个 Input 类实例：`,
      paragraph_three: `前两个参数是：`,
      paragraph_four: `1. <span className="font-bold">txid: </span>生成该输出的交易 ID，和`,
      paragraph_five: `2. <span className="font-bold">vout: </span>该交易输出在交易输出列表中的索引`,
      paragraph_six: `这两部分信息共同构成一个 <span className="font-bold">Outpoint</span>。最终我们会传入从上一步 listunspent 命令获得的 txid 和 vout。`,
      paragraph_seven: `后两个参数是我们要花费的输出的金额（以聪为单位）和一个叫 scriptcode 的数据。这个数据暂时不用，可以先用空字节数组代替。`,
      paragraph_eight: {
        a: `比特币中的哈希是`,
        b: {
          text: `反序的`,
          question: `为什么比特币中的哈希要反序？`,
          href: `https://chat.bitcoinsearch.xyz/?author=holocat&question=why%2520are%2520hashes%2520reversed%2520in%2520bitcoin`,
        },
        c: `，但仅在呈现给用户或用户输入时如此。当哈希以十六进制格式提供时，在存储或传输为原始字节之前，必须反转字节顺序。`,
      },
      paragraph_nine: `你可以在 <span className="text-green p-1 font-mono bg-[#00000033] m-1 text-base">from_output()</span> 方法中看到 txid 参数处理的例子。`,
      paragraph_ten: `我们还需要一个 <span className="text-green p-1 font-mono bg-[#00000033] m-1 text-base">serialize()</span> 方法，将交易序列化为字节数组，这是交易在网络节点间传输以及在区块中表示的方式：`,
      heading_three: `Outpoint`,
      table_one: {
        heading: {
          one: `描述`,
          two: `名称`,
          three: `类型`,
          four: `大小`,
        },
        row_one: {
          column: {
            one: `被花费交易的哈希`,
            two: `txid`,
            three: `字节`,
            four: `32`,
          },
        },
        row_two: {
          column: {
            one: `输出在交易输出数组中的位置`,
            two: `index`,
            three: `整数`,
            four: `4`,
          },
        },
      },
      heading_four: `Input`,
      table_two: {
        row_one: {
          column: {
            one: `被花费的 txid 和输出索引`,
            two: `outpoint`,
            three: `字节`,
            four: `36`,
          },
        },
        row_two: {
          column: {
            one: `ScriptSig 长度（SegWit 永远为 0）`,
            two: `length`,
            three: `整数`,
            four: `1`,
          },
        },
        row_three: {
          column: {
            one: `SegWit 永远为空`,
            two: `script`,
            three: `字节`,
            four: `0`,
          },
        },
        row_four: {
          column: {
            one: `默认值为 0xffffffff，可用于相对时间锁`,
            two: `sequence`,
            three: `整数`,
            four: `4`,
          },
        },
      },
      paragraph_eleven: {
        a: `记住：比特币中的整数序列化为`,
        b: {
          text: `小端序`,
          question: `什么是字节序（endianness）？`,
          href: `https://chat.bitcoinsearch.xyz/?author=holocat&question=What%2520is%2520endianness%253F`,
        },
      },
      success: `Input 类看起来不错，干得好！`,
    },
    hard: {
      title: `收支概览`,
      nav_title: `构建 Input 类`,
      heading: `完成 Input 类实现`,
      paragraph_one: `它应该具有以下方法：`,
      paragraph_two: `前两个参数是交易 ID 和你要花费的交易输出索引。`,
      paragraph_three: `最终我们会传入上面从 listunspent 获得的 txid 和 vout。注意，比特币中的哈希是小端序，这意味着你需要反转 txid 字节顺序！`,
      paragraph_four: `后两个参数是要花费的输出金额（聪）和 scriptcode。暂时将它们存储为 Input 类的属性，后续步骤再使用。`,
      paragraph_five: `我们还需要一个 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">serialize()</span> 方法，将数据序列化为字节数组：`,
      heading_two: `Outpoint`,
      table_one: {
        heading: {
          one: `描述`,
          two: `名称`,
          three: `类型`,
          four: `大小`,
        },
        row_one: {
          column: {
            one: `被花费交易的哈希`,
            two: `txid`,
            three: `字节`,
            four: `32`,
          },
        },
        row_two: {
          column: {
            one: `输出在交易输出数组中的位置`,
            two: `index`,
            three: `整数`,
            four: `4`,
          },
        },
      },
      heading_three: `Input`,
      table_two: {
        row_one: {
          column: {
            one: `被花费的 txid 和输出索引`,
            two: `outpoint`,
            three: `字节`,
            four: `36`,
          },
        },
        row_two: {
          column: {
            one: `ScriptSig 长度（SegWit 永远为 0）`,
            two: `length`,
            three: `整数`,
            four: `1`,
          },
        },
        row_three: {
          column: {
            one: `SegWit 永远为空`,
            two: `script`,
            three: `字节`,
            four: `0`,
          },
        },
        row_four: {
          column: {
            one: `默认值为 0xffffffff，可用于相对时间锁`,
            two: `sequence`,
            three: `整数`,
            four: `4`,
          },
        },
      },
      success: `Input 类看起来不错，干得好！`,
    },
  },
in_out_five: {
  title: `收支概览`,
  nav_title: `构建 Output 类`,
  heading: `完成 Output 类实现`,
  paragraph_one: `像 Input 类一样，它需要一个方法 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">from_options()</span>，用来从用户提供的数据构建 Output 对象：`,
  paragraph_two: `它接受一个比特币地址字符串（比如来自 Mika 3000 的地址）和一个整数值。值以聪（satoshis）表示！记住，1 BTC = 100000000 satoshis。你需要再次使用我们的 bech32 库，将地址解码为版本（version）和数据（data）组件。  
    这个类还需要一个 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">serialize()</span> 方法，将数据按照规范序列化为字节数组：`,
  heading_two: `Output`,
  table: {
    heading: {
      one: `描述`,
      two: `名称`,
      three: `类型`,
      four: `大小`,
    },
    row_one: {
      column: {
        one: `发送的聪数`,
        two: `value`,
        three: `字节`,
        four: `8`,
      },
    },
    row_two: {
      column: {
        one: `接下来脚本（即“witness program”）的总长度`,
        two: `length`,
        three: `整数`,
        four: `1`,
      },
    },
    row_three: {
      column: {
        one: `隔离见证版本，从 bech32 地址中导出`,
        two: `version`,
        three: `整数`,
        four: `1`,
      },
    },
    row_four: {
      column: {
        one: `接下来 witness program 数据的长度`,
        two: `length`,
        three: `整数`,
        four: `1`,
      },
    },
    row_five: {
      column: {
        one: `从 bech32 地址导出的数据组件`,
        two: `index`,
        three: `字节`,
        four: `(var)`,
      },
    },
  },
  paragraph_three: `别忘了：比特币中的整数序列化为小端序！`,
  success: `Output 类看起来不错，干得好！`,
},
put_it_together_one: {
  title: `整合交易`,
  normal: {
    title: `整合交易`,
    nav_title: `构建交易摘要`,
    heading: `交易摘要`,
    paragraph_one: `在第五章中我们学到，要签署交易，首先需要将其数据重新排列并哈希成一个消息，这个消息成为签名算法的原始输入之一。由于我们现在使用隔离见证，我们还需要实现更新后的交易摘要算法，该算法在 <Link href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki" target="_blank" className="underline">BIP 143</Link> 中有说明。`,
    paragraph_two: `记住，每个交易输入都需要自己的签名，所以摘要算法的某些组件可以缓存和重用，但其他组件会根据当前签名的输入而不同！完成交易方法 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">digest(input_index)</span>，它会计算用于签名输入的 32 字节消息。`,
    list_heading: `注意事项：`,
    list_one: `"Double SHA-256" 或 dSHA256 = sha256(sha256(data))`,
    list_two: `value 是被花费输出的聪数。我们在步骤 2 中已经加入 Input 类并保存至类属性中直到现在。`,
    list_three: `scriptcode 是正在被评估的原始比特币脚本。我们也在步骤 2 中加入了 Input 类。`,
    list_four: `所有整数都采用小端序编码！`,
    paragraph_three: `下一节我们会深入探讨，但为了从你的 P2WPKH 地址支出，你的 scriptcode 会是：`,
    paragraph_four: `...解码后得到以下比特币脚本。`,
    paragraph_five: `更多关于 scriptcode 的信息请见 <Link href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki" target="_blank" className="underline">BIP 143</Link>。`,
    paragraph_six: `原始交易有一个前置数据（preimage），它是以下部分的序列化：`,
    headings: {
      item_one: `描述`,
      item_two: `名称`,
      item_three: `类型`,
      item_four: `大小`,
    },
    table: {
      row_one: {
        item_one: `交易版本，默认 2`,
        item_two: `version`,
        item_three: `整数`,
        item_four: `4`,
      },
      row_two: {
        item_one: `所有输入的 outpoint 的 dSHA256，序列化`,
        item_two: `bytes`,
        item_three: `字节`,
        item_four: `32`,
      },
      row_three: {
        item_one: `所有输入的 sequence 值的 dSHA256，序列化`,
        item_two: `sequences`,
        item_three: `字节`,
        item_four: `32`,
      },
      row_four: {
        item_one: `正在签名的单个输入的序列化 outpoint`,
        item_two: `outpoint`,
        item_three: `字节`,
        item_four: `36`,
      },
      row_five: {
        item_one: `正在被花费的输出脚本`,
        item_two: `scriptcode`,
        item_three: `字节`,
        item_four: `(var)`,
      },
      row_six: {
        item_one: `正在签名的单个输入被花费的聪数`,
        item_two: `value`,
        item_three: `整数`,
        item_four: `8`,
      },
      row_seven: {
        item_one: `正在签名的单个输入的 sequence 值`,
        item_two: `sequence`,
        item_three: `整数`,
        item_four: `4`,
      },
      row_eight: {
        item_one: `所有输出的 dSHA256，序列化`,
        item_two: `outputs`,
        item_three: `字节`,
        item_four: `32`,
      },
      row_nine: {
        item_one: `交易锁定时间，默认 0`,
        item_two: `locktime`,
        item_three: `整数`,
        item_four: `4`,
      },
      row_ten: {
        item_one: `签名哈希类型，我们使用 1 表示 "ALL"`,
        item_two: `sighash`,
        item_three: `整数`,
        item_four: `4`,
      },
    },
    paragraph_seven: `最后，我们要签名的消息就是对所有这些序列化数据进行双重 SHA-256。`,
    success: `digest() 方法看起来不错，干得好！`,
  },

  hard: {
    title: `整合交易`,
    nav_title: `构建 Witness 类`,
    heading: `完成 Witness 类实现`,
    paragraph_one: `它应该有一个方法，接受一个字节数组，并将该项添加到 witness 栈中。`,
    paragraph_two: `它还需要一个 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">serialize()</span> 方法，将 witness 栈序列化。`,
    subheading_one: `Witness 栈`,
    headings: {
      item_one: `描述`,
      item_two: `名称`,
      item_three: `类型`,
      item_four: `大小`,
    },
    table_one: {
      row_one: {
        item_one: `witness 栈中的项数`,
        item_two: `count`,
        item_three: `整数`,
        item_four: `1`,
      },
      row_two: {
        item_one: `序列化后的栈项`,
        item_two: `items`,
        item_three: `(items)`,
        item_four: `(var)`,
      },
    },
    subheading_two: `Witness 栈项`,
    table_two: {
      row_one: {
        item_one: `栈项的总长度`,
        item_two: `length`,
        item_three: `整数`,
        item_four: `1`,
      },
      row_two: {
        item_one: `栈项的原始字节`,
        item_two: `data`,
        item_three: `字节`,
        item_four: `(var)`,
      },
    },
    success: `Witness 类看起来不错，干得好！`,
  },
},
put_it_together_two: {
  normal: {
    title: `整合交易`,
    nav_title: `构建 Witness 类`,
    heading: `签名并填充 Witness！`,
    paragraph_one: `在上一章，我们编写了一些重要的 ECDSA 签名验证代码。现在，为了生成有效签名，我们将对代码稍作调整。`,
    paragraph_two: `在本练习中，我们将实现 ECDSA 签名算法背后的部分数学逻辑。想了解更多信息，请参考以下资源：`,
    paragraph_three: `• 维基百科页面：<Link href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" target="_blank" className="underline">椭圆曲线数字签名算法 (ECDSA)</Link>`,
    paragraph_four: `• <Link href="https://www.secg.org/sec1-v2.pdf#subsubsection.4.1.3" target="_blank" className="underline">SEC 1 标准（Standards for Efficient Cryptography 1）</Link>：第 44 页，4.1.3 节`,
    heading_one: `步骤 1`,
    paragraph_five: `在 Transaction 类中，有一个方法 <span className="text-green p-1 text-base font-mono bg-[#0000004D] m-1">compute_input_signature(index, key)</span>，它接受输入索引和私钥（32 字节整数，在 JavaScript 中为 BigInt）。完成此方法，使其计算所选输入的消息摘要。使用上一步的 <span className="text-green p-1 text-base font-mono bg-[#0000004D] m-1">digest()</span> 方法，然后返回一个 ECDSA 签名，由两个 32 字节整数组成：<span className="italic">r</span> 和 <span className="italic">s</span>。`,
    heading_two: `步骤 2`,
    paragraph_six: `对于签名算法，比特币协议要求 <span className="italic">s</span> 值必须是“低位”（low），即小于曲线的阶除以 2。将此检查加入 <span className="text-green p-1 text-base font-mono bg-[#0000004D] m-1">compute_input_signature()</span>。`,
    paragraph_seven: `详细说明请参见 <Link href="https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki#low_s" target="_blank" className="underline">BIP 146</Link>。`,
    heading_three: `步骤 3`,
    paragraph_eight: `完成方法 <span className="text-green p-1 text-base font-mono bg-[#0000004D] m-1">sign_input(index, key)</span>，调用 <span className="text-green p-1 text-base font-mono bg-[#0000004D] m-1">compute_input_signature(index, key)</span>。处理返回值时，<span className="italic">r</span> 和 <span className="italic">s</span> 需要使用我们提供的 DER 算法进行编码。`,
    heading_four: `步骤 4`,
    paragraph_nine: `比特币要求在 DER 签名末尾附加一个额外字节，该字节表示“sighash 类型”。目前我们始终使用字节 <span className="p-1 text-base font-mono bg-[#0000004D] m-1">0x01</span>，表示 "SIGHASH ALL"。`,
    heading_five: `步骤 5`,
    paragraph_ten: `最后一步是创建一个 Witness 对象，包含两个栈项：刚生成的 DER 编码签名 blob 和压缩公钥。先压入签名，再压入公钥。`,
    paragraph_eleven: `将 witness 栈对象添加到 Transaction 对象的 witnesses 数组中。`,
    success: `compute_input_signature() 和 sign_input() 方法看起来不错，干得好！`,
  },
  hard: {
    title: `整合交易`,
    nav_title: `序列化交易`,
    heading: `完成 Transaction 类实现`,
    paragraph_one: `Transaction 类应包含全局属性 locktime 和 version，以及 inputs、outputs 和 witness 栈数组。`,
    paragraph_two: `需要一个 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">serialize()</span> 方法，将整个交易序列化为比特币 P2P 网络可广播的字节格式。`,
    headings: {
      item_one: `描述`,
      item_two: `名称`,
      item_three: `类型`,
      item_four: `大小`,
    },
    table: {
      row_one: {
        item_one: `当前为 2`,
        item_two: `version`,
        item_three: `整数`,
        item_four: `4`,
      },
      row_two: {
        item_one: `隔离见证需为 0x0001`,
        item_two: `flags`,
        item_three: `字节`,
        item_four: `2`,
      },
      row_three: {
        item_one: `输入数量`,
        item_two: `in count`,
        item_three: `整数`,
        item_four: `1`,
      },
      row_four: {
        item_one: `所有交易输入，已序列化`,
        item_two: `inputs`,
        item_three: `Inputs[]`,
        item_four: `(var)`,
      },
      row_five: {
        item_one: `输出数量`,
        item_two: `out count`,
        item_three: `整数`,
        item_four: `1`,
      },
      row_six: {
        item_one: `所有交易输出，已序列化`,
        item_two: `outputs`,
        item_three: `Outputs[]`,
        item_four: `(var)`,
      },
      row_seven: {
        item_one: `所有 witness 栈，已序列化`,
        item_two: `witness`,
        item_three: `Witnesses[]`,
        item_four: `(var)`,
      },
      row_eight: {
        item_one: `设置为 0 表示最终状态`,
        item_two: `locktime`,
        item_three: `整数`,
        item_four: `4`,
      },
    },
    paragraph_three: `注意，witnesses 没有“count”字段，因为 witness 栈数量必须始终等于输入数量。`,
    success: `serialize() 方法看起来不错，干得好！`,
  },
},
put_it_together_three: {
  normal: {
    title: `整合交易`,
    nav_title: `签署交易`,
    heading: `完成 Transaction 类实现`,
    paragraph_one: `为了完成交易，我们需要一个 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">serialize()</span> 方法，将整个交易序列化为可广播的字节。`,
    paragraph_two: `脚本应创建并签署一个 Transaction 对象。它包含一个输入（在 <span className="underline">The input class</span> 中识别的 UTXO）和两个输出：`,
    paragraph_three: `我们已知输入和输出。准备好构建并签署交易了吗？还不完全。我们有 1.61 BTC 的输入和 1 BTC 的输出……那么剩下的 0.61 BTC 呢？大部分是“找零”，需要发送回我们自己的地址！`,
    paragraph_four: `注意，witnesses 没有“count”字段，因为 witness 栈数量必须始终等于输入数量。`,
    paragraph_five: `另外，我们需要包含“手续费”。我们将从找零输出中扣除少量聪，以激励矿池将我们的交易包含在区块中。将找零从 61,000,000 调整为 60,999,000 satoshis。`,
    paragraph_six: `最后，交易完成。脚本应返回 transaction.serialize() 的结果。这就是一个有效签名的比特币交易，我们可以广播到网络，将资金发送给 Mika 3000！`,
    headings: {
      item_one: `描述`,
      item_two: `名称`,
      item_three: `类型`,
      item_four: `大小`,
    },
    table: {
      row_one: {
        item_one: `当前为 2`,
        item_two: `version`,
        item_three: `整数`,
        item_four: `4`,
      },
      row_two: {
        item_one: `隔离见证需为 0x0001`,
        item_two: `flags`,
        item_three: `字节`,
        item_four: `2`,
      },
      row_three: {
        item_one: `输入数量`,
        item_two: `in count`,
        item_three: `整数`,
        item_four: `1`,
      },
      row_four: {
        item_one: `所有交易输入，已序列化`,
        item_two: `inputs`,
        item_three: `Inputs[]`,
        item_four: `(var)`,
      },
      row_five: {
        item_one: `输出数量`,
        item_two: `out count`,
        item_three: `整数`,
        item_four: `1`,
      },
      row_six: {
        item_one: `所有交易输出，已序列化`,
        item_two: `outputs`,
        item_three: `Outputs[]`,
        item_four: `(var)`,
      },
      row_seven: {
        item_one: `所有 witness 栈，已序列化`,
        item_two: `witness`,
        item_three: `Witnesses[]`,
        item_four: `(var)`,
      },
      row_eight: {
        item_one: `设置为 0 表示最终状态`,
        item_two: `locktime`,
        item_three: `整数`,
        item_four: `4`,
      },
    },
    bullet_one: `Mika 3000 收到 100,000,000 satoshis 到地址 bc1qgghq08syehkym52ueu9nl5x8gth23vr8hurv9dyfcmhaqk4lrlgs28epwj`,
    bullet_two: `你收回 61,000,000 satoshis 到地址 bc1qm2dr49zrgf9wc74h5c58wlm3xrnujfuf5g80hs`,
    success: `完成！你已经成功构建了交易！`,
  },
  hard: {
    title: `整合交易`,
    nav_title: `构建交易摘要`,
    heading: `交易摘要`,
    paragraph_one: `在第五章中，我们学到，要签署交易，首先需要将数据重新排列并哈希成一个消息，这个消息成为签名算法的原始输入。由于我们现在使用隔离见证，需要实现 BIP 143 指定的更新交易摘要算法 <Link href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki" target="_blank" className="underline">BIP 143</Link>。`,
    paragraph_two: `记住，每个交易输入都需要自己的签名，所以摘要算法的某些部分可以缓存和重用，而其他部分会根据当前签名的输入不同而变化！完成方法 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">digest(input_index)</span>，计算签名输入的 32 字节消息。`,
    list_heading: `注意事项：`,
    list_one: `"Double SHA-256" 或 dSHA256 = sha256(sha256(data))`,
    list_two: `value 是被花费输出的聪数，已在步骤 2 中加入 Input 类并保存至类属性。`,
    list_three: `scriptcode 是被评估的原始比特币脚本，也已加入 Input 类。`,
    paragraph_three: `下一节我们会深入探讨，但 P2WPKH 地址的 scriptcode 如下：`,
    paragraph_four: `解码后得到以下比特币脚本。`,
    paragraph_five: `更多信息请参见 <Link href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki" target="_blank" className="underline">BIP 143</Link>。`,
    paragraph_six: `原始交易前置数据（preimage）序列化如下：`,
    headings: {
      item_one: `描述`,
      item_two: `名称`,
      item_three: `类型`,
      item_four: `大小`,
    },
    table: {
      row_one: {
        item_one: `交易版本，默认 2`,
        item_two: `version`,
        item_three: `整数`,
        item_four: `4`,
      },
      row_two: {
        item_one: `所有输入 outpoint 的 dSHA256，序列化`,
        item_two: `bytes`,
        item_three: `字节`,
        item_four: `32`,
      },
      row_three: {
        item_one: `所有输入 sequence 值的 dSHA256，序列化`,
        item_two: `sequences`,
        item_three: `字节`,
        item_four: `32`,
      },
      row_four: {
        item_one: `正在签名的单个输入的序列化 outpoint`,
        item_two: `outpoint`,
        item_three: `字节`,
        item_four: `36`,
      },
      row_five: {
        item_one: `正在被花费的输出脚本`,
        item_two: `scriptcode`,
        item_three: `字节`,
        item_four: `(var)`,
      },
      row_six: {
        item_one: `正在签名的单个输入被花费的聪数`,
        item_two: `value`,
        item_three: `整数`,
        item_four: `8`,
      },
      row_seven: {
        item_one: `正在签名的单个输入 sequence 值`,
        item_two: `sequence`,
        item_three: `整数`,
        item_four: `8`,
      },
      row_eight: {
        item_one: `所有输出的 dSHA256，序列化`,
        item_two: `outputs`,
        item_three: `字节`,
        item_four: `32`,
      },
      row_nine: {
        item_one: `交易锁定时间，默认 0`,
        item_two: `locktime`,
        item_three: `整数`,
        item_four: `4`,
      },
      row_ten: {
        item_one: `签名哈希类型，使用 1 表示 "ALL"`,
        item_two: `sighash`,
        item_three: `整数`,
        item_four: `4`,
      },
    },
    paragraph_seven: `最后，我们要签名的消息就是对所有这些序列化数据进行双重 SHA-256。`,
    success: `digest() 方法看起来不错，干得好！`,
  },
},
put_it_together_four: {
  hard: {
    title: `把一切组合起来`,
    heading: `签名！`,
    nav_title: `签署交易`,
    paragraph_one: `我们在上一章编写了 ECDSA 签名验证代码，现在我们需要稍作调整以创建有效签名。向你的 Transaction 类中添加一个名为 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">计算输入签名(index: int, key: int)</span> 的方法，它接受输入索引号和私钥（32 字节整数！）。它应使用第 6 步中的 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">digest()</span> 方法计算所选输入的消息摘要，并返回形式为两个 32 字节整数 r 和 s 的 ECDSA 签名。`,
    paragraph_two: `请参阅 <Link href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" target="_blank" className="underline">此页面</Link> 了解 ECDSA 签名算法。同时参考 <Link href="https://www.secg.org/sec1-v2.pdf#subsubsection.4.1.3" target="_blank" className="underline">此 PDF</Link>（第 44 页，第 4.1.3 节）。`,
    paragraph_three: `比特币协议要求签名算法增加一步，要求 s 值为“低值”，即小于曲线阶的一半。了解更多请参阅 <Link href="https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki#low_s" target="_blank" className="underline">BIP 146</Link>。`,
    success: `compute_input_signature() 方法完成。干得好！`,
  },
},
put_it_together_five: {
  hard: {
    title: `把一切组合起来`,
    heading: `填充见证`,
    nav_title: `填充见证`,
    paragraph_one: `完成方法 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">签署输入(index: int, key: int)</span>，调用第 7 步的方法 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">计算输入签名(index, key)</span> 并处理返回值。r 和 s 数值需要用我们实现的 DER 算法编码。`,
    paragraph_two: `比特币要求在 DER 签名末尾附加一个字节，表示“签名哈希类型”。目前我们始终使用字节 0x01，表示 “SIGHASH ALL”。`,
    paragraph_three: `一旦得到签名 blob，我们需要创建一个 Witness 对象，包含两个栈项：签名 blob 和压缩公钥。先压入签名，再压入公钥。`,
    paragraph_four: `然后可以将 witness 栈对象添加到交易对象的 witnesses 数组中。`,
    success: `sign_input() 方法完成。干得好！`,
  },
},
put_it_together_six: {
  hard: {
    title: `把一切组合起来`,
    heading: `把一切组合起来`,
    nav_title: `把一切组合起来！`,
    paragraph_one: `我们知道输入，也知道输出。准备好构建并签署交易了吗？还不行。我们有 1.61 BTC 的输入和 1 BTC 的输出……剩下的 0.61 BTC 去哪里？大部分将作为“找零”，需要返回到我们自己的地址！`,
    paragraph_two: `编写一个脚本，创建并签署一个 Transaction 对象。它应有一个输入（第 1 步中识别的 UTXO）和两个输出：`,
    paragraph_three: `等等！我们还需要包括“手续费”。我们会从找零输出中略微扣除一小部分，以激励矿池将交易包含到区块中。将找零从 61,000,000 减少到 60,999,000 satoshis。`,
    paragraph_four: `最后，工作完成。脚本应返回交易的 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">序列化()</span> 方法结果。这是一个有效签名的比特币交易，可以广播到网络，将资金发送给 Mika 3000！`,
    bullet_one: `Mika 3000 收到 100,000,000 satoshis 到 bc1qgghq08syehkym52ueu9nl5x8gth23vr8hurv9dyfcmhaqk4lrlgs28epwj`,
    bullet_two: `你收回 61,000,000 到你的地址 bc1qm2dr49zrgf9wc74h5c58wlm3xrnujfuf5g80hs`,
    success: `完成！你已经构建了一个交易！`,
  },
},
outro_one: {
  title: `结尾`,
  nav_title: `章节完成`,
  heading: `你做到了！`,
  paragraph_one: `你成功从零构建了交易，以支付 Mika 3000 的帮助。现在完成这里的内容，我们看看 Vanderpoole 岛上还能找到什么。`,
},
book_a_call_one: {
  title: '预约 BDP 咨询',
  nav_title: '预约 BDP 咨询',
  heading: '想和比特币开发项目通话吗？',
  paragraph_one:
    '—MIKA 3000：“从零开始构建交易的工作令人印象深刻。从创建你自己的比特币地址及公私钥对，到证明 Vanderpoole 的签名是伪造的，很明显你很懂行。”',
  paragraph_two:
    '“有机会更深入聊聊整个比特币开源软件（BOSS）吗？我认识一些比特币开发项目 <Link className="!underline" target="_blank" href="https://bitcoindevs.xyz" /> 的人，可以介绍给你。他们总是寻找像你这样的优秀开发者，帮助构建、强化和保障比特币，使其不仅仅是货币的未来。”',
  paragraph_three:
    '这里会带你进入日历页面，预约与比特币开发项目成员的视频通话，讨论如何更深入参与比特币开源软件及相关职业机会。这完全独立于 Saving Satoshi 游戏，拒绝不会影响你的游戏进度。',
  button_text_one: '安排通话',
  button_text_two: '继续游戏',
},
resources: {
  in_out: {
    input_class_heading: `输入类`,
    input_class_paragraph_one: `占位资源`,
    output_class_heading: `输出类`,
    output_class_paragraph_one: `占位资源`,
  },
  put_it_together: {
    building_a_transaction_heading: `构建交易`,
    building_a_transaction_paragraph_one: `占位资源`,
  },
},
},
chapter_seven: {
  title: `进攻是最好的防御`,
  paragraph_one: `你和 Mika 3000 先乘飞机和降落伞到达 Vanderpoole 的私人岛屿，然后开沙滩车，再乘自动划桨的小船。`,
  intro_one: {
    title: `介绍`,
    nav_title: `潜入基地`,
    paragraph_one: `你问你的同伴们是否担心 Vanderpoole 的安全无人机军队。`,
    paragraph_two: `—HOLOCAT：“给我 15 分钟。他们基本上是鸟，而我是猫。他们没有机会。”`,
    paragraph_three: `Holocat 伸出爪子，一次次扑向 Vanderpoole 的无人机军队。Mika 3000 递给你一件黑色高领毛衣、手套和一副夜视镜。`,
    paragraph_four: `—MIKA 3000：“你不能穿夏威夷衬衫做间谍。你在想什么？这不是另一个废弃仓库，这是堡垒。差点忘了，拿上这个抓钩。”`,
    paragraph_five: `好奇自己陷入了什么境地，你和 Mika 3000 攀上了 Vanderpoole 主要住宅的城墙。令你惊讶的是，他的家中充满了支持比特币的艺术品、书籍和纸质杂志。他曾经是真正的比特币拥护者。一批距今 125 年的矿机被保存于玻璃展示柜中。就在这时，你看到了它：Vanderpoole 的工作室。`,
  },
  intro_two: {
    nav_title: `控制室`,
    paragraph_one: `这个巨大的房间很乱，但布局井然有序。还记得矿工曾用空区块堵塞比特币网络吗？你在打开的笔记本中发现了 Vanderpoole 为后门设计的详细草图。你是对的：这全是谎言，但不是由阴险的坏人讲的，而是由一个绝望的比特币信徒讲的，他的公司已经无法竞争。为了保护他的遗产，Vanderpoole 在矿工中植入了病毒。`,
    paragraph_two: `病毒替换了所有矿工使用的部分代码，无论他们是否属于矿池。这是区块构建逻辑，将交易组装到区块模板的算法。模板仍然传递给合法的哈希代码进行工作量证明。在寻找有效哈希时，模板会与无数不同的 nonce 结合，但在找到有效哈希之前，损害——区块模板中没有任何交易——已经发生。`,
    paragraph_three: `—HOLOCAT：“真是个损失。他的家族曾经很伟大。看到 Vanderpoole 家族沦落成这样，真令人悲伤。”`,
  },
  intro_three: {
    nav_title: `修复软件`,
    paragraph_one: `但你不能就这样把损坏的矿工代码留在 Vanderpoole 的服务器上。它会继续感染矿工。你必须修复它！当你阅读代码时，Holocat 给你展示了一个 mempool 显示，里面充满了未确认的交易。代码越快修复越好。`,
  },
  mempool_transaction_one: {
    title: `构建区块`,
    nav_title: `组装区块`,
    heading: `代码挑战`,
    python: {
      paragraph_one: `这是你在 Vanderpoole 服务器上找到的代码。它从 JSON 文件导入当前 mempool，并将所有未确认的交易存储在内存中，作为 MempoolTransaction 类的实例。Vanderpoole 弱化的函数是 <span className="text-green">assemble_block()</span>。如果你按 Vanderpoole 留下的代码运行，你会立刻看到问题。`,
    },
    javascript: {
      paragraph_one: `这是你在 Vanderpoole 服务器上找到的代码。它从 JSON 文件导入当前 mempool，并将所有未确认的交易存储在内存中，作为 MempoolTransaction 类的实例。Vanderpoole 弱化的函数是 <span className="text-green">assembleBlock()</span>。如果你按 Vanderpoole 留下的代码运行，你会立刻看到问题。`,
    },
    paragraph_two: {
      a: `你需要修复区块组装函数，不仅要构建有效区块，还要最大化区块中的手续费，让矿工在遵循共识规则的前提下获得最大利润。最关键的共识规则需要注意限制总`,
      b: {
        text: `交易权重 `,
        href: `https://chat.bitcoinsearch.xyz/?author=holocat&question=what%2520are%2520weighted%2520units`,
        question: `什么是权重单位？`,
      },
      c: ` 和 `,
      d: {
        text: `交易顺序 `,
        href: `https://chat.bitcoinsearch.xyz/?author=holocat&question=what%2520order%2520do%2520transactions%2520need%2520to%2520be%2520in%2520a%2520block`,
        question: `交易在区块中需要遵循什么顺序？`,
      },
      e: `。`,
    },
    paragraph_three: `你可以做以下假设来完成任务：`,
    bullet_one: `mempool 中的所有交易已被验证为有效。`,
    bullet_two: `Coinbase 交易及其对区块的权重可以忽略。`,
    paragraph_four: `你可以在 <Link href="https://github.com/saving-satoshi/resources/blob/main/chapter-7/mempool.json" target="_blank" className="underline">这里</Link> 查看完整原始 mempool JSON 文件。`,
    paragraph_five: `或者在下表中浏览文件摘录，了解一些基本模式：`,
    headings: {
      item_one: `交易 ID`,
      item_two: `手续费`,
      item_two_b: `Satoshis`,
      item_three: `权重`,
      item_three_b: `权重单位 (WU)`,
      item_four: `祖先交易`,
    },
    table_one: {
      footer: `查看 JSON 文件 <Link href="https://github.com/saving-satoshi/resources/blob/main/chapter-7/mempool.json" target="_blank" className="underline">这里</Link> 获取其余交易数据`,
    },
    poor: `这是一个有效区块，但你能做得更好吗？尝试收集更多手续费。`,
    good: `这是一个有效区块，但你还没有收集到最多的手续费。继续努力或选择继续，随你。`,
    success: `这是一个有效区块，你已经优化了手续费。不错！`,
  },
  outro_one: {
    title: `结尾`,
    nav_title: `章节完成`,
    heading: `你做到了！`,
    paragraph_one: `你逃离了基地并回到家。当故事发布时，投资者纷纷抛售 BitRey 股票，Vanderpoole 的净资产大幅下降。`,
  },
  resources: {
    mempool_transaction_one: {
      bytes_v_weight_heading: `字节 vs 权重单位`,
      bytes_v_weight_paragraph_one: `在比特币区块构建中，“权重单位”(WU) 和 “字节”是衡量交易和区块大小的两种不同指标。`,
      bytes_v_weight_subheading_bytes: `字节`,
      bytes_v_weight_paragraph_two: `字节指交易或区块的原始大小，以实际数据表示。即交易序列化（转换为可存储或传输的格式）后的字节大小。在 Segregated Witness (SegWit) 实施前，区块大小限制为 1 兆字节 (1 MB)。`,
      bytes_v_weight_subheading_wu: `权重单位`,
      bytes_v_weight_paragraph_three: `权重单位是一种更复杂的指标，由 SegWit 在比特币改进提案 141 中引入 <Link href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#user-content-Other_consensus_critical_limits" target="_blank" className="undeline">BIP 141</Link>。该系统旨在通过分别考虑见证数据的影响，更公平地分配区块空间。`,
      bytes_v_weight_paragraph_four: `在本课中，只需注意我们使用权重单位来计算最大区块大小及每笔交易的权重，确保你的区块不超过最大 4000000 权重单位即可。`,
    },
  },
},

chapter_eight: {
  title: `二千一百万`,
  paragraph_one: `多亏了你的调查，人们非常想听你的消息，所以你轻触 Holocat 的鼻子，发现了一封 Deborah Chunk 的邀请函，她邀请你亲自前往 LARGE BIG NEWS Studios 办公室出席采访。将这个故事公之于众很重要，因此你再次跳上了 Budgetcopter。`,
  intro_one: {
    title: `介绍`,
    nav_title: `Vanderpoole 的欺骗`,
    paragraph_one: `—DEBORAH CHUNK：“这些文件以历史性的、甚至是丑闻般的方式揭露了 Thomas Vanderpoole 的所谓谎言。人们最想知道的第一件事是你是否单独行动。第二件事是你从哪里获得的信息。”`,
    paragraph_two: `你只告诉她关于 Holocat 的事情。你说信息是由自称 Satoshi Nakamoto 的人直接传递给你和 Mika 3000 的，而你怀疑那实际上是一个黑客组织。最后一点导致 Thomas Vanderpoole 直接打电话到节目中。`,
  },
  intro_two: {
    title: `介绍`,
    nav_title: `Vanderpoole 的愤怒`,
    paragraph_one: `—THOMAS VANDERPOOLE：“我家族才是 Satoshi Nakamoto！你看到这混乱局面说了什么吗？他刚承认与黑客合作，一个只使用 Satoshi Nakamoto 名号来声称本该属于我的遗产的组织。这个混蛋在撒谎，以破坏比特币持有者对区块奖励消失的不满！”`,
    paragraph_two: `Vanderpoole 继续对你大喊百年老辱，他称你为害虫、无赖、胆小鬼、新手等。你几乎对他感到同情。他的家族无可否认地对比特币历史很重要，即便他关于 Satoshi Nakamoto 的说法显而易见是假的。`,
  },
  intro_three: {
    intro: `介绍`,
    nav_title: `对 Vanderpoole 的指控`,
    paragraph_one: `—DEBORAH CHUNK：“Vanderpoole 先生，如果可以的话。人们对比特币供应是否被篡改感到困惑和不确定。你能证明自己没有参与所谓篡改吗？神秘黑客和他的 Holocat，你能证明 Vanderpoole 曾试图对比特币犯罪吗？”`,
  },
  building_blocks_one: {
    title: `构建区块`,
    nav_title: `寻找链尖`,
    paragraph_one: {
      a: `你知道 Vanderpoole 一直试图通过挖掘生成比允许数量更多比特币的区块来混淆人们，从而膨胀货币供应。这些区块是无效的，因为它们违反了硬编码协议规则，但它们可能仍然会欺骗一些运行有缺陷或恶意软件的人，或者`,
      b: {
        text: `轻客户端`,
        href: `https://chat.bitcoinsearch.xyz/?author=holocat&question=what%2520are%2520light%2520clients%253F`,
        question: `什么是轻客户端？`,
      },
      c: `，这些客户端没有完全验证网络数据。`,
    },
    paragraph_two: `你还知道，在网络中某处有一条从创世区块到今天“链尖”的有效区块链，其中每笔交易和区块都遵循规则。这条链是唯一的<span className="italic">真实</span>链，唯一重要的链，也是比特币 2100 万原始比特币供应完整的唯一链。`,
    paragraph_three: `现在，在全球直播电视前，你需要找到最长的有效区块链并验证币的供应完整性。与此同时，你还可以证明 Vanderpoole 已将比特币网络变成了一个无效区块的雷区。`,
  },
  building_blocks_two: {
    title: `构建区块`,
    nav_title: `比特币区块树`,
    paragraph_one: `每个区块只有一个前置区块，但可能有多个后继区块。因此，比特币区块更像形成树而非链。一些分支是死胡同，正如你必须证明的，有些分支由于 Vanderpoole 的恶作剧是无效的。`,
    paragraph_two: `在这个迷宫中有一条从创世区块到今天最新区块的路径。你必须找到它，并告诉 Deborah Chunk 哪个区块是树中最长有效链的尖端……在下一个广告之前。啊啊！`,
    paragraph_three: `这幅比特币区块链“树”的艺术化示意图显示，每个区块只有一个父区块，但可能有多个子区块。每个区块标记其哈希，以及父区块的哈希 (<span className="p-1 font-mono m-0.5 text-sm">prev</span>)。`,
    paragraph_four: `一些区块是红色的，因为它们无效。从创世区块开始的最长区块路径为绿色，表示“最多工作量”或“最有效”链。这些区块中的交易是唯一真正“已确认”的交易。其他有效区块，蓝色的，后代不如“最多工作量”链多，它们终止于所谓的 <span className="italic">陈旧尖端</span>。`,
  },
  building_blocks_three: {
    title: `构建区块`,
    nav_title: `探索比特币 API`,
    heading: `比特币 API`,
    paragraph_one: `要回答这些问题，你需要通过 JSON-RPC API 与比特币全节点交互。我们为你导入了一个库 <span className="p-1 font-mono bg-[#0000004D] m-1">bitcoin_rpc</span>，它处理从你的脚本到全节点的安全 HTTP 连接，执行命令并返回响应。你的全节点正在“修剪”，只保留最近 300 个区块，但这足够包含 Vanderpoole 最近行为的整个时间跨度。`,
    paragraph_two: `让我们先熟悉 API。该库有一个函数接受一个必需参数 <span className="p-1 font-mono bg-[#0000004D] m-1">method</span>（字符串）和一个可选参数 <span className="p-1 font-mono bg-[#0000004D] m-1">params</span>（字符串或数字）：`,
    paragraph_three: `该 API 还提供方便的“help”方法！向它请求帮助以了解可用命令，然后打印当前网络难度以通过挑战。`,
    success: `成功探索 API！我们继续下一步。`,
  },
  building_blocks_four: {
    title: `构建区块`,
    nav_title: `找到最小交易区块`,
    heading: `区块数据`,
    paragraph_one: `每个比特币全节点都有一个数据库，用于存储区块并按哈希索引。全节点通过第二个索引跟踪每个高度的候选区块，索引映射 height -> [block hashes]。`,
    paragraph_two: `JSON-RPC API 返回的区块数据是 JSON 对象，其中包含一个属性 <span className="p-1 font-mono bg-[#0000004D] m-1">txs</span>，它是交易对象数组。`,
    paragraph_three: `获取高度为 6929996 的所有区块候选，并打印交易最少区块的哈希。`,
    success: `干得漂亮`,
  },
  building_blocks_five: {
    title: `构建区块`,
    nav_title: `获取交易手续费`,
    heading: `交易数据`,
    paragraph_one: `区块中确认的交易对象是 JSON 对象，其中包含 "inputs" 和 "outputs" 数组。它们描述了交易花费的旧交易输出（UTXO）以及交易创建的新交易输出（UTXO）。每个 UTXO 对象有一个 "value" 属性，以 satoshis 表示。`,
    paragraph_two: `"inputs" 数组是交易花费（销毁）的交易输出（UTXO），"outputs" 数组是交易创建的交易输出（UTXO）。你可能还记得第 6 章，交易总是支付手续费以激励矿工将其包含在区块中。手续费正好是交易总输入值与总输出值之间的差额。`,
    paragraph_three: `换句话说，矿工可以保留交易中发送进来的比特币，而不是发送给交易接收者的比特币。`,
    paragraph_four: `有一笔交易的 txid 是：`,
    paragraph_five: `所在区块的哈希是：`,
    paragraph_six: `打印该交易的手续费（以 satoshis 为单位）。`,
    success: `干得漂亮`,
  },
  building_blocks_six: {
    title: `构建区块`,
    nav_title: `确定区块奖励`,
    heading: `Coinbase 交易`,
    paragraph_one: `每个区块的第一笔交易称为 coinbase，也称作“第 0 笔交易”（即 txs[0]），具有一些特殊属性。首先，它没有输入！因为它不花费任何现有交易输出（UTXO）。其次，其输出值严格由协议定义（不管 Vanderpoole 怎么说！）。这是矿工既收取交易手续费，又生成新比特币的机制。`,
    paragraph_two: `理解区块中总交易手续费的累加相对容易，但区块奖励值从哪里来？比特币网络的每个参与者如何准确确定矿工在任意时间允许生成的新比特币数量？`,
    paragraph_three: `这是 Satoshi Nakamoto 编写的算法，自比特币诞生以来一直是系统不可变的核心属性：`,
    list_one: `从 2009 年挖掘的第 #1 个区块开始，区块奖励为 50 BTC（即 5,000,000,000 satoshis）`,
    list_two: `每 210,000 个区块奖励减半一次。`,
    paragraph_four: `在高度 209,999 的区块，奖励为 50 BTC。在下一个高度 210,000 的区块，奖励为 25 BTC，如此类推。经过 63 次“减半”后，奖励将降为 1 satoshi。最后一次减半会将奖励降为零。`,
    paragraph_five: `而最后一次减半就在昨天！`,
    paragraph_six: `完成以下函数的实现，该函数接受区块高度作为参数，并返回奖励值（以 satoshis 为单位）。`,
    success: `get_subsidy 函数看起来很棒。干得漂亮！`,
  },
  building_blocks_seven: {
    title: `构建区块`,
    nav_title: `获取有效区块`,
    heading: `那个可恶的家伙！`,
    paragraph_one: `高度 6929851 有四个区块候选。只有一个是有效区块，其余三个是 Vanderpoole 的团伙为了膨胀比特币供应而鲁莽挖掘的。`,
    paragraph_two: `使用你在前一个挑战中编写的区块奖励函数和 JSON-RPC API，编写一个函数检查区块候选的有效性。通过检查 coinbase 输出是否正确来判断。如果区块有效，函数应返回 true。`,
    paragraph_three: `以下是如何使用你的代码找到高度 6929851 的唯一有效区块：`,
    success: `validate block 函数看起来很棒。干得漂亮！`,
  },
building_blocks_eight: {
  title: `构建区块`,
  nav_title: `表演时间！`,
  heading_one: `表演时间！`,
  paragraph_one: `摄像机正在拍摄，全球二十亿人正在观看直播。距离下一个广告只有几分钟了。Deborah Chunk 满头大汗。不知怎的，Holocat 也在出汗。在通话的另一端，Vanderpoole 也一定在出汗。这是你的时刻。`,
  paragraph_two: `从你找到的高度 6929851 前一个有效区块开始，找到你能找到的最长有效区块链。将链存储为区块哈希数组。同时，维护一个包含所有无效区块的数组，以向全世界展示 Vanderpoole 是如何努力破坏比特币的。无效区块哈希的顺序无关紧要，但你的有效链必须以 6929850 区块的哈希开始，并在每个高度上依次延伸至链尖。`,
  paragraph_three: `Vanderpoole 很狡猾！他在无效区块之上挖掘有效区块，也在短有效链之上挖掘无效区块！这是一片迷宫和雷区。你可能需要在遍历树时跟踪几个有效分支。会有父区块有效但不在最长链上的有效区块！最终，只有一个有效叶子区块的高度高于所有其他区块。`,
  paragraph_four: `记住：JSON API 返回的区块对象具有 "prev" 属性，用于标识该区块的父区块哈希：`,
  heading_two: `一个区块只有在以下情况下才是有效的：`,
  paragraph_five: `它的 coinbase 输出值等于预期的区块奖励加上该区块中所有交易的总手续费。`,
  heading_three: `并且`,
  paragraph_six: `该区块是另一个有效区块的子区块。这确保了链是有效的。`,
  paragraph_seven: `返回一个包含两个数组的 JSON 对象，分别标记为 "valid" 和 "invalid"：`,
  success: `showtime 函数看起来很棒。干得漂亮！`,
},
outro_one: {
  title: `结尾`,
  nav_title: `章节完成`,
  heading: `我们正在现场直播！`,
  paragraph_one: `你找到了最长链，并向所有人证明了它！你找到的无效区块列表令人印象深刻。Vanderpoole 尽力让人们接受包含奖励的区块，但他无法改变比特币的规则。正如我们观察到的，仅因为一个区块是链的一部分，并不意味着它是有效的。现在，你离揭穿 Vanderpoole 又近了一步。不用说，他没有回答 Chunk 女士剩下的问题。`,
},

resources: {
  building_blocks_three: {
    tip: `先尝试这个命令，以了解可用的命令。`,
    rpc_heading: `RPC 命令`,
    rpc_paragraph_one: `RPC 命令是一种接口命令，允许客户端向程序发送请求，在客户端和服务器之间创建交互。这些请求由客户端或请求者发送，并带有客户端需要修改请求的任何参数。`,
  },
  building_blocks_four: {
    block_data_heading: `区块数据`,
    block_data_paragraph_one: `从本质上讲，比特币是一个账本，一个列表，记录了自诞生以来的所有交易。每笔交易按区块组织，每个区块按从创世区块开始的顺序组织。`,
  },
  building_blocks_five: {
    transaction_data_heading: `交易数据`,
    transaction_data_paragraph_one: `每笔交易包含自身的一组信息，以区别于其他交易，并清楚地说明转移了多少比特币以及使用了哪些输入和输出。`,
  },
  building_blocks_six: {
    block_subsidy_heading: `区块奖励`,
    block_subsidy_paragraph_one: `区块奖励是每个新区块的 coinbase 中释放到流通的比特币数量。由于总共只能创建约 2100 万枚比特币，因此必须有一个递减公式来使 coinbase 奖励总量达到 2100 万。下方的公式可视化了比特币中的机制。`,
    block_subsidy_paragraph_two: `这个公式的作用是什么？我们知道创世区块的 coinbase 奖励是 50 个比特币，这在公式右侧的分子中表示。分母表示每次减半奖励会减少多少，这里为 2，即减半。我们还知道比特币只按时间顺序处理各个区块，因此每次减半为 210,000 个区块。最后，我们希望每次减半的奖励递减翻倍，因此将 2 提到当前减半次数 'i' 的幂，直到最终减半周期 32 次迭代。`,
  },
  building_blocks_seven: {
    validating_heading: `验证区块`,
    validating_paragraph_one: `验证区块对网络的安全性至关重要，因为每个区块都是基于前一区块的交易构建的。如果发现过去的某个区块无效，可能会导致整条区块链受到质疑，带来巨大的连锁影响。`,
  },
  building_blocks_eight: {
    showtime_heading: `验证区块链`,
    showtime_paragraph_one: `在比特币中验证区块链对于维护整个网络的完整性和安全性至关重要。每笔交易必须由矿工验证，以确保其合法且遵循网络建立的共识规则。该验证过程防止双重支付和欺诈，使用户无需中央权威即可信任系统。此外，它增强了透明度，因为所有已验证交易都会记录在公共账本中，使任何人都可以审计交易历史。`,
  },
},
},

chapter_nine: {
  title: `不信任，自己验证。`,
  paragraph_one: `及时地，你向世界证明了 Vanderpoole 一直试图用无效区块混淆比特币网络。在广告播出时，演播室的电视工作人员为下一环节做准备。`,
  intro_one: {
    title: `简介`,
    nav_title: `威胁`,
    paragraph_one: `大家都在庆祝，人人都在微笑。但有一个人在现场不高兴：一位高个子、衣着考究、灰发的男子，你立刻认出了他。人群让开，你第一次面对面见到他：Vanderpoole！`,
    paragraph_two: `他的拳头紧握。你毁掉了他的生意，并揭露了他家族的长期骗局。他脱口而出的第一句话就是威胁要对你进行“无限天数”的诉讼。`,
  },
  intro_two: {
    title: `简介`,
    nav_title: `达成协议`,
    paragraph_one: `当 Vanderpoole 咆哮时，一名制片人走进来告诉你，来自世界各地的观众希望通过捐赠比特币和卡尔佐内支持你的事业……出于某种原因！Deborah 要求你向观众提供一个钱包地址。`,
    paragraph_two: `这让 Vanderpoole 更加愤怒。他要求你与他分成收到的捐款，否则他将用更多诉讼淹没你，仿佛可以有超过无限的诉讼。`,
    paragraph_three: `与 Vanderpoole 分享捐款没有多大意义。钱来自那些想要感谢你揭露 Vanderpoole 破坏比特币努力的人。你意识到，这个要求更多的是关于他输掉了而非想要钱。你甚至一度对他产生同情。他已将自己逼入绝境，无法脱身。`,
    paragraph_four: `仿佛她能读懂你的心思，Deborah Chunk 介入了。她询问 Vanderpoole 是否希望将部分捐款捐给某个慈善机构。令你惊讶的是，他热情地提到了 Lil Bits Foundation，这是一个致力于帮助儿童的非营利组织。`,
    paragraph_five: `Vanderpoole 的脸色从萝卜红平息到甜菜紫。你开始在你和 Vanderpoole 之间创建比特币脚本合约。他负责将资金交给 Lil Bits Foundation。这个脚本合约将用于推导捐赠地址。它会将 Vanderpoole 视为不可靠的交易对手，并确保你们双方可以按照约定的方式和时间使用资金。`,
  },
  opcodes_one: {
    title: `操作码`,
    nav_title: `比特币脚本`,
    heading: `比特币脚本`,
    paragraph_one: `我们在第 6 章提到过比特币脚本，但没有深入讲解，因为你花费的交易输出（UTXO）是通过一个简单机制锁定的：单个签名和一个隐式脚本，通过公钥验证该签名。现在情况将变得更有趣。`,
    paragraph_two: `花费比特币输出有两个重要部分：脚本和栈。`,
    paragraph_three: `我们先从高层次了解这两个概念。`,
  },
  opcodes_two: {
    title: `操作码`,
    nav_title: `比特币栈`,
    heading: `栈`,
    paragraph_one: `想象一叠书 📚。如果你想放一本书，你必须将其放在书堆顶端。没有其他位置可放。如果你想读书，你唯一能接触到的就是顶部的那本书。即使你想取多本书，也必须从顶部开始，一层层向下取。在计算机术语中，栈就像一个数据项数组，有两个操作：`,
    paragraph_two: `<span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_PUSH</span> 将一个元素添加到栈的“顶端”。`,
    paragraph_three: `<span className="text-[#3DCFEF] w-fit rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_POP</span> 从栈顶移除元素以进行处理。`,
    subheading_one: `示例：`,
    stack_list_one: `这是一个栈: <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">[]</span>`,
    stack_list_two: `压入数字 1: <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">[1]</span>`,
    stack_list_three: `压入数字 2: <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">[1, 2]</span>`,
    stack_list_four: `弹出栈顶元素: <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">[1]</span>`,
    paragraph_four: `注意，最先压入栈的元素将最后弹出，因此它是脚本处理时最后处理的元素。因此栈有一种“倒置”或“反向”的感觉，你在栈上看到的第一个元素很可能就是脚本处理结束时所需的解决方案。`,
    paragraph_five: `在花费比特币交易输出时，花费者所需的元素会放在交易输入的见证部分（参见第 6 章），这些元素在任何脚本处理开始前被压入栈。我们称这些元素为初始栈 (INITIAL STACK)。它们非常重要，因为它们实际上就是解锁脚本并让交易输出（UTXO）得以被花费的数据！`,
  },
  opcodes_three: {
    title: `操作码`,
    nav_title: `操作码`,
    heading: `操作码`,
    paragraph_one: `脚本是一系列线性命令，按顺序执行，操作栈上的元素。当脚本结束时，栈上必须恰好剩下一个非零（非 FALSE）元素，否则整个操作无效，你的比特币交易也无效。比特币脚本语言中有 100 多个命令，称为“操作码”。在此挑战中，我们只会使用其中一小部分。`,
    paragraph_two: `让我们演示一个示例：用数学问题 1 + 2 = ? 锁定一笔比特币输出。谁知道这个数学题的答案，谁就可以花费这笔输出（UTXO）。`,
    paragraph_three: `脚本如下：`,
    paragraph_four: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_1 OP_2 OP_ADD OP_EQUAL</span>`,
    paragraph_five: `这个脚本会被哈希并进行 bech32 编码，生成一个地址，别人可以向该地址发送比特币。`,
  },
  opcodes_four: {
    title: `操作码`,
    nav_title: `栈解决方案`,
    heading: `栈解决方案`,
    paragraph_one: `栈解决方案如下，花费交易必须包含所有这些元素。它们放在尝试花费这笔输出（UTXO）的输入的见证部分。让我们逐步说明：`,
    table_one: {
      headings: {
        item_one: `步骤`,
        item_two: `栈`,
        item_three: `脚本执行`,
      },
    },
    subheading_one: `解释`,
    stack_list_one: `初始化：资金交易输出和支出交易输入被组合在一起。`,
    stack_list_two: `步骤 1: <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_1</span> 将 "1" 压入堆栈。`,
    stack_list_three: `步骤 2: <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_2</span> 将 "2" 压入堆栈。`,
    stack_list_four: `步骤 3: <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ADD</span> 弹出堆栈顶部两个元素，将它们相加，然后将和压回堆栈。`,
    stack_list_five: `步骤 4: <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_EQUAL</span> 弹出堆栈顶部两个元素，比较它们是否相等，并将布尔结果压回堆栈。`,
    paragraph_two: `现在脚本已经执行到末尾，堆栈中只剩下一个 TRUE 元素——这笔输出（UTXO）已被花费！`,
    paragraph_three: `如果我们在开始这个示例时堆栈上有 4，那么我们将无法花费这笔输出（UTXO），因为 OP_EQUAL 的结果为 FALSE。在这些练习中，我们将使用非常有限的操作码集合，并按类别进行介绍。`,
  },
opcodes_five: {
  title: `操作码`,
  nav_title: `计算基础算术`,
  heading: `基础算术`,
  paragraph_one: `比特币脚本可以执行简单的数学运算。你可以用简单的数学锁定一笔输出（UTXO），但这样任何会算数的人都可以花费它！换句话说，不要在主网尝试。`,
  subheading_one: `将整数或任意数据压入堆栈的操作码`,
  opconstants_list_one_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_0</span>`,
  opconstants_list_one_paragraph: `将数字 0 压入堆栈。`,
  opconstants_list_two_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_1</span>`,
  opconstants_list_two_paragraph: `将数字 1 压入堆栈。`,
  opconstants_list_three_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_2</span>`,
  opconstants_list_three_paragraph: `将数字 2 压入堆栈。`,
  opconstants_list_four_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_3</span>`,
  opconstants_list_four_paragraph: `将数字 3 压入堆栈。`,
  opconstants_list_five_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_DUP</span>`,
  opconstants_list_five_paragraph: `将堆栈顶部元素复制一份并压入堆栈。`,
  opconstants_list_six_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_PUSH</span>`,
  opconstants_list_six_paragraph: `将接下来的脚本值压入堆栈。例如：SIG(alice)、PUBKEY(alice)、HASH256(secret)、secret。小写字符串表示现实世界的数据，其他操作码在此解释器中会将它们处理为实际密钥、签名、哈希摘要或原像。`,
  subheading_two: `执行算术运算的操作码`,
  oparithmetic_list_one_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ADD</span>`,
  oparithmetic_list_one_paragraph: `弹出堆栈顶部两个元素，将它们相加，然后将和压回堆栈。`,
  oparithmetic_list_two_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_EQUAL</span>`,
  oparithmetic_list_two_paragraph: `弹出堆栈顶部两个元素，比较它们是否相等，将布尔值压回堆栈。`,
  oparithmetic_list_three_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_EQUALVERIFY</span>`,
  oparithmetic_list_three_paragraph: `与 OP_EQUAL 类似，但如果两个元素不相等，会立即报错并停止脚本执行。`,
  paragraph_two: `提供用于支出脚本的初始堆栈。`,
},
opcodes_six: {
  title: `操作码`,
  nav_title: `使用密码学解码`,
  heading: `简单密码学`,
  paragraph_one: `我们在前面的章节中探索过 "支付到公钥哈希"。这是在隔离见证出现前，数百万交易输出中显式编写的比特币脚本。交易输出由公钥的哈希锁定。支出者必须揭示与该哈希匹配的公钥，并提供该公钥验证的签名。`,
  subheading_one: `执行简单密码学的操作码`,
  opcryptography_list_one_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm h-fit">OP_HASH256</span>`,
  opcryptography_list_one_paragraph: `弹出堆栈顶部一个元素，计算双 SHA256 摘要，并将结果压回堆栈。在练习中，该操作用字符串表示。例如：脚本 OP_1 OP_HASH256 会生成堆栈 [HASH256(1)]`,
  opcryptography_list_two_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm h-fit">OP_CHECKSIG</span>`,
  opcryptography_list_two_paragraph: `弹出堆栈顶部两个元素。第一个必须是 PUBKEY(...) 格式的公钥，第二个必须是 SIG(...) 格式的签名。如果两者括号内的字符串相等，则视为有效的 ECDSA 签名，并将 TRUE 压回堆栈，否则压回 FALSE。`,
  paragraph_two: `提供用于支出脚本的初始堆栈。`,
},
opcodes_seven: {
  title: `操作码`,
  nav_title: `多重签名`,
  heading: `多重签名`,
  paragraph_one: `多重签名策略提供一个公钥列表和一个有效支出所需的签名数量。它可以描述为 "m-of-n"，表示从 n 个公钥列表中需要 m 个签名。公钥及 m、n 值通常包含在锁定脚本中，支出者只需提供正确数量的签名即可。`,
  paragraph_two: `Holocat 出现，并播放 Satoshi Nakamoto 的预录信息！`,
  paragraph_three: `嗨。我在实现 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_CHECKMULTISIG</span> 时意外写了个 bug。它会额外弹出一个堆栈元素，根本没用。所以，呃，抱歉。该代码是共识关键的，所以比特币历史、现在和未来的每个 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_CHECKMULTISIG</span> 操作都必须包含一个“虚拟”元素。别忘了，否则无法花费你的多签输出（UTXO）！`,
},
opcodes_eight: {
  title: `操作码`,
  nav_title: `多重签名签署`,
  heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-1">OP_CHECKMULTISIG</span>`,
  subheading_one: `通过以下算法处理 m-of-n 多重签名。`,
  multisig_list_one: `从堆栈弹出一个整数。这是 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">n</span> 值。`,
  multisig_list_two: `从堆栈弹出 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">n</span> 个元素，这些元素应为 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">PUBKEY(...)</span> 格式的公钥。`,
  multisig_list_three: `从堆栈弹出一个整数。这是 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">m</span> 值。`,
  multisig_list_four: `从堆栈弹出 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">m</span> 个元素，这些元素应为 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">SIG(...)</span> 格式的签名。`,
  multisig_list_five: `额外从堆栈弹出一个元素，完全没有理由。`,
  multisig_list_six: `遍历每个公钥：验证公钥是否对应堆栈顶部签名。如果有效，移除公钥和签名，然后继续下一个公钥。如果无效，只移除公钥，然后继续检查同一堆栈顶部签名。`,
  multisig_list_seven: `如果所有公钥都已验证，但仍有剩余签名，则操作失败。`,
  multisig_list_eight: `一旦所有签名都被移除，操作可以提前成功结束，即使还有剩余公钥。`,
  paragraph_one: `注意 m <= n。公钥数量可以多于签名，但签名数量永远不会超过公钥数量。并且公钥和签名必须顺序一致，即使某些公钥未被用于签名。`,
  paragraph_two: `提供用于支出脚本的初始堆栈。`,
},
opcodes_nine: {
  title: `操作码`,
  nav_title: `等待解锁`,
  heading: `时间锁`,
  paragraph_one: `早在上世纪，一份名为 BIP 65 的文档提出了比特币的新操作码，最终被纳入共识规则。它用于要求交易的 nLocktime 必须大于或等于脚本指定的值。比特币共识规则已经禁止在区块高度大于交易 nLocktime 时包含该交易。换句话说，该操作码使交易在未来区块达到指定高度前不可花费。由于它是通过软分叉加入的，它实际上不会弹出堆栈元素，因此大多数用法还需要 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_DROP</span>。如果操作码判断交易太早无法包含在区块中，脚本立即停止并报错。`,
  subheading_one: `执行区块时间锁的操作码`,
  optimelock_list_one_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_DROP</span>`,
  optimelock_list_one_paragraph: `弹出堆栈顶部一个元素，忽略它。`,
  optimelock_list_two_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_CHECKLOCKTIMEVERIFY</span>`,
  optimelock_list_two_paragraph: `读取（不弹出）堆栈顶部元素，并将其解释为区块高度。如果操作码消耗的高度参数小于下一个区块高度，操作无效。`,
  paragraph_two: `提供用于支出脚本的初始堆栈。`,
},
opcodes_ten: {
  title: `操作码`,
  nav_title: `构建逻辑`,
  heading: `条件语句`,
  paragraph_one: `就像任何优秀的编程语言一样，比特币脚本也有逻辑分支！路径通常由支出者选择，以满足所需的认证条件组合。`,
  paragraph_two: `<span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_IF</span> <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ELSE</span> <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ENDIF</span> 逻辑分支。`,
  paragraph_three: `<span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_IF</span> 弹出一个堆栈元素，并将其作为布尔值计算。如果为 TRUE，代码执行到 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ELSE</span>，然后跳到 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ENDIF</span>；否则跳到 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ELSE</span> 并执行到 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ENDIF</span>。逻辑分支可以嵌套，但每个 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_IF</span> 必须有对应的 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ENDIF</span>，否则解释器会报错，脚本执行失败。`,
  paragraph_four: `提供用于支出脚本的初始堆栈。`,
},
proposal_one: {
  title: `高级`,
  nav_title: `回到故事`,
  heading: `回到故事！`,
  paragraph_one: `干得好！我们已经了解了构建基础交易脚本所需的大多数操作码。现在让我们来测试一下。`,
  paragraph_two: `对于每个讨论的合约提案，提供一个比特币脚本和一个有效的支出堆栈。`,
},
proposal_two: {
  title: `2 对 2 多重签名`,
  nav_title: `协作签署`,
  heading: `2 对 2 多重签名`,
  paragraph_one: `Vanderpoole 建议先使用 2 对 2 多重签名。所有捐款将由你和 Lil Bits 基金会 50/50 分配。每笔支出交易都需双方签署。`,
  paragraph_two: `Vanderpoole 给你他的公钥 PUBKEY(vanderpoole)，你的公钥是 PUBKEY(me)。`,
  paragraph_three: `提供用于支出脚本的初始堆栈。`,
  next_step_message: `看起来不错！现在试试使用你自己的签名。`,
},
proposal_three: {
  title: `条件时间锁交易`,
  nav_title: `让他等待`,
  heading: `条件时间锁交易`,
  paragraph_one: `等等，这不合理——你不会想一直处理他！新的安排是你在接下来的两小时内获得所有捐款，而 Lil Bits 基金会获得之后的捐款。你看了工作室墙上的比特币区块，并同意区块高度 6930300 大约两小时后会被挖出。`,
  paragraph_two: `记住 Vanderpoole 的公钥是 PUBKEY(vanderpoole)，你的公钥是 PUBKEY(me)。`,
  paragraph_three: `提供用于支出脚本的初始堆栈。`,
  next_step_message: `看起来不错！现在试试使用你自己的签名。`,
},
proposal_four: {
  title: `秘密原像锁定交易`,
  nav_title: `与预言机合作`,
  heading: `秘密原像锁定交易`,
  paragraph_one: `Vanderpoole 再次改变主意。他不喜欢这个安排，因为存在未知因素。他决定让 Lil Bits 基金会获得前 1.0 BTC 的捐款，你可以在之后花费剩余部分。`,
  paragraph_two: `比特币脚本无法跨多个 UTXO 检查总余额，所以你们选择一个公正的第三方预言机：Deborah Chunk！她将监控区块链上的总捐款，当捐款累计至少达到 1.0 BTC 时，她将在电视上公布原像的哈希值，你需要在脚本中承诺该值。`,
  paragraph_three: {
    a: `她在私下生成一个安全随机数，然后交给你哈希摘要：<span className="text-[#3DCFEF] w-fit rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">HASH256(FD3771E8)</span>。一旦她揭示这个秘密，你就可以花费收到的所有捐款（比特币），而不是提前一 `,
    b: ` 秒！`,
  },
  paragraph_four: `记住 Vanderpoole 的公钥是 PUBKEY(vanderpoole)，你的公钥是 PUBKEY(me)。`,
  paragraph_five: `提供用于支出脚本的初始堆栈。`,
  tooltip_one: {
    question: `什么是 satoshi？`,
    link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=What%2520is%2520a%2520satoshi%253F`,
    highlighted: `聪`,
  },
  next_step_message: `让我们看看是否正确使用了你的签名和原像。`,
},
outro_one: {
  title: `结语`,
  nav_title: `章节完成`,
  heading: `干得漂亮！`,
  paragraph_one: `捐款已分发给你和 Lil Bits 基金会，许多观众感谢你揭露了 Vanderpoole 的行为。虽然比特币的去中心化特性使得接管网络困难，但这并不能阻止像他这样的人尝试。你终于松了一口气，尤其是在付出如此多努力之后。`,
},
resources: {
  opcodes_five: {
    arithmetic_heading: `算术操作码`,
    arithmetic_paragraph: `在比特币脚本中，算术操作就像数学运算一样，对输入进行计算。在实际比特币脚本中，输入仅限于有符号 32 位整数，但输出可能会溢出。`,
    spoiler: `在初始堆栈中放入两个整数，使它们的和为 3`,
  },
  opcodes_six: {
    cryptography_heading: `密码学操作码`,
    cryptography_paragraph: `这些操作码在日常交易中非常重要，因为它们确保输出只能通过该 UTXO 所有者的签名来花费。注意，比特币操作码没有正式分类，它们通常只是按十六进制代码排列。`,
    spoiler: `脚本会检查签名是否对应哈希后的公钥。先放签名，再放公钥`,
  },
  opcodes_eight: {
    multisig_heading: `多重签名操作码`,
    multisig_paragraph: `<span className="text-[#3DCFEF] rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_CHECKMULTISIG</span> 有一个显著的漏洞，需要堆栈顶部包含一个未使用的值，与实际多重签名无关。`,
    spoiler: `这是一个需要两个签名的多重签名脚本，堆栈中的第一个值是 CHECKMULTISIG 操作的占位符。`,
  },
  opcodes_nine: {
    timelock_heading: `时间锁操作码`,
    timelock_paragraph: `比特币脚本可以读取当前区块高度，从而允许基于未来区块锁定交易。实际 <span className="text-[#3DCFEF] rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_CHECKLOCKTIMEVERIFY</span> 的具体语义可以在`,
    timelock_link: `<Link target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki" className="underline">这里</Link> 找到。`,
    spoiler: `脚本会锁定支出直到特定区块高度，然后验证初始堆栈中的签名。`,
  },
  opcodes_ten: {
    conditionals_heading: `操作码逻辑`,
    conditionals_paragraph: `条件操作码允许一些基本的编程逻辑分支。虽然条件逻辑允许在比特币脚本中实现更广泛的可能性，但与传统编程语言相比仍然有限。`,
    spoiler: `初始堆栈中前两个值的和为 false，所以脚本会走 OP_ELSE 分支。`,
  },
  proposal_two: {
    making_script_heading: `编写脚本`,
    making_script_paragraph: `记住，脚本只有在堆栈上最终留下一个真值时才会被验证。一些版本允许任意真值，但我们的脚本编辑器只允许值等于 1 或 true。`,
    tip: `别忘了 <span className="text-[#3DCFEF] rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_CHECKMULTISIG</span> 的漏洞，需要在堆栈上放一个额外的未使用值！`,
    spoiler: `脚本提示：这个多重签名安排需要双方签名。脚本指定需要两个签名，并包含两个公钥。
堆栈提示：为了满足脚本，你需要提供两个签名。堆栈上的 0 是为了处理 CHECKMULTISIG 操作的特定行为。`,
  },
  proposal_three: {
    tip: `考虑将条件语句与时间锁结合起来，以将 Vanderpoole 的签名与你的签名分开。`,
    spoiler: `脚本提示：该脚本允许在两种条件下支出：区块高度 6930300 前或之后。区块前，Vanderpoole 可以支出；区块后，你可以支出。
堆栈提示：在指定区块前支出，Vanderpoole 使用他的签名。区块后，你使用你的签名，并需要提供一个 0，因为脚本已经通过了时间锁验证。`,
  },
  proposal_four: {
    tip: `原像将在未知时间后揭示，因此无需使用时间锁。`,
    spoiler: `脚本提示：该脚本允许在两种条件下支出：秘密揭示前或之后。揭示前，Vanderpoole 可以支出；揭示后，你们都可以支出。
堆栈提示：在秘密揭示前支出，Vanderpoole 使用他的签名。秘密揭示后，你使用你的签名、秘密的哈希，并提供一个 0，因为脚本已经通过了未揭示验证。`,
  },
},
},

chapter_ten: {
  title: `100亿连接`,
  paragraph_one: `电视演播室的播出灯熄灭了。舞台工作人员关闭了他们的 3D 摄像机，经过漫长而精彩的一天后离开。Mika 3000 在那里等你。`,
  intro_one: {
    title: `庆祝`,
    nav_title: `庆祝`,
    paragraph_one: `—MIKA 3000：“你成功了！你真的做到了！我们去喝点东西庆祝一下吧。”`,
    paragraph_two: `你们走到附近一家名为 Public Key Pub 的酒吧。酒保是个友好的家伙，名牌写着 Laszlo，他热情地欢迎你们。`,
    paragraph_three: `—MIKA 3000：“不知道为什么，但我真想来一个卡尔佐内。”`,
    paragraph_four: `—LASZLO：“我们没有卡尔佐内，但我祖传的披萨非常棒。有人甚至说值 10,000 个比特币。”`,
    paragraph_five: {
      a: `—MIKA 3000：“1 万比特币？等等……你叫 Laszlo 是因为你是`,
      b: `的后代吗？”`,
    },
    paragraph_six: `—LASZLO：“没错，就是我。”`,
    tooltip_one: {
      question: `Laszlo 和披萨日有什么意义？`,
      link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=What%2520is%2520the%2520significance%2520of%2520Laszlo%2520and%2520pizza%2520day%253F`,
      highlighted: `THE Laszlo`,
    },
  },
  intro_two: {
    title: `买饮料`,
    nav_title: `买饮料`,
    paragraph_one: `—MIKA 3000：“太棒了。只要不是 10,000 个比特币，我们就点一个披萨和几杯 Lightning Lemonade。可惜没有卡尔佐内。”`,
    paragraph_two: `Mika 3000 和 Laszlo 拿出他们的太阳能 ePhone Infinity，开始操作。`,
    paragraph_three: `—MIKA 3000：“哎呀，你刚才的小把戏搞得矿工费疯涨。比特币网络活动激增，交易费用高得离谱！我们得通过链下支付解决。”`,
  },
  intro_three: {
    title: `链下？`,
    nav_title: `链下？`,
    paragraph_one: `自从“Satoshi”联系你以来，你一直处理链上交易。这也是你领取挖矿奖励和向 Mika 3000 转账的方式。然而，链上交易不适合频繁使用，因为区块空间有限，矿工费可能波动。`,
    paragraph_two: `那么，人们如何每天可扩展地使用比特币呢？答案是链下支付，你可能每天都见过：出租车送完乘客快速离开，买晚餐的街头小贩，一个孩子提着全息热狗和牛奶走出商店。用例几乎无限。`,
    paragraph_three: `虽然比特币本身无法处理如此大量的活动，但通过链下支付，它可以做到。`,
    paragraph_four: `—你：“没问题，Mika 3000。我可以处理。我来用链下支付向 Laszlo 买一杯 Lightning Lemonade。”`,
  },
  opening_a_channel_one: {
    title: `初始资金`,
    nav_title: `初始资金`,
    heading_one: `初始资金`,
    paragraph_one: `你在区块链上有一个已确认的 UTXO，金额为 101,000 satoshi。制作链下支付看起来很简单，对吧？`,
  },
  opening_a_channel_two: {
    title: `链下交易`,
    nav_title: `链下交易`,
    heading_one: `链下交易`,
    paragraph_one: `创建一个有效的比特币交易，但不广播到网络，而是直接给 Laszlo。作为回报，他应该给你一杯 Lightning Lemonade，因为他可以随时广播交易。一旦确认并被打包进区块，资金归他所有。`,
    paragraph_two: `记住，现在是 2140 年！一杯 Lightning Lemonade 价格是 0.00001000 BTC。`,
    heading_two: `操作说明`,
    off_chain_list_one: `填写两个输出金额：第一个输出给 Laszlo 1000 satoshi，第二个输出作为找零给自己。`,
    off_chain_list_two: `为了获得资金，Laszlo 需要将交易广播到网络，这需要支付矿工费。我们预留 1000 sats 来支付费用。更新找零输出金额。`,
    off_chain_list_three: `编写两个输出脚本`,
    off_chain_list_four: `点击 <span className="rounded-sm px-1.5 py-1 h-[28px] bg-[#0000004D] m-0.5 text-base">Sign</span> 对输入签名`,
    // off_chain_list_four: `Send it to Laszlo by clicking "send to bob"`,
    heading_three: `提示`,
    hint_one: `Laszlo 使用 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> SIG(LASZLO)</span> 花费输出 0`,
    hint_two: `你使用 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> SIG(YOU)</span> 花费输出 1`,
    hint_three: `这些签名不属于输出脚本`,
  },
  opening_a_channel_three: {
    title: `链下支付信任问题`,
    nav_title: `链下支付信任问题`,
    paragraph_one: `—LASZLO：“等等，这不对——只要我不广播交易，你仍然可以花费那 101,000 sats。你可能喝了 Lightning Lemonade，然后把钱花在别处，而我什么都得不到！”`,
    paragraph_two: `“如果我们要进行链下交易，我需要保证你用来支付的钱不会在链上被你再次花费。”`,
  },
  opening_a_channel_four: {
    title: `多重签名`,
    nav_title: `多重签名`,
    heading_one: `多重签名`,
    paragraph_one: `在支付给 Laszlo 之前，先把资金放入一个 2-of-2 多重签名地址，并在区块链上确认。然后我们可以想办法让这个单一链上交易发挥更大作用——用更少的交易做更多的事。`,
    heading_two: `操作说明`,
    multisig_one: `填写输出金额和输出脚本`,
    multisig_two: `点击 <span className="rounded-sm px-1.5 py-1 h-[28px] bg-[#0000004D] m-0.5 text-base">Sign and Broadcast</span> 对输入签名`,
    heading_three: `提示`,
    hint_one_a: `你和 Laszlo 希望未来一起花费输出 0，用 <br/>`,
    hint_one_b: `<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> 0 SIG(LASZLO) SIG(YOU) </span>`,
    hint_two: `别忘了预留矿工费`,
  },
  opening_a_channel_five: {
    title: `多重签名退款保护`,
    nav_title: `多重签名退款保护`,
    paragraph_one: `—LASZLO：“好，谢谢。这是个好开始。但如果我离开，而你再也见不到我呢？我可能会广播这笔交易，你的 100,000 satoshi 就会被卡在 2-key 多重签名里，你永远无法取回。”`,
    paragraph_two: `为自己考虑，在签名前先创建一个退款交易，以确保你能取回资金。`,
  },
updating_the_state_one: {
  title: `退款`,
  nav_title: `退款`,
  heading_one: `退款`,
  paragraph_one: `你的 ePhone Infinity 上出现了一个新标签：<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">Refund</span>，它会在同一屏幕上启动另一个交易模板，并从 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">Multisig</span> 输出指向这个交易的输入。`,
  heading_two: `操作指南`,
  refund_list_one: `填写输出金额和输出脚本`,
  refund_list_two: `点击 <span className="rounded-sm px-1.5 py-1 h-[28px] bg-[#0000004D] m-0.5 text-base">Send to Laszlo</span> 发送给 Laszlo，然后他会告诉我们是否签署`,
  refund_list_three: `暂时不要自己签名！先看看 Laszlo 的意见`,
  heading_three: `提示`,
  hint_one: `输出 0 由你支出，使用 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">SIG(YOU)</span>`,
},
updating_the_state_two: {
  title: `确保支付安全`,
  nav_title: `确保支付安全`,
  paragraph_one: `—LASZLO：“好的，我会签署这个并发回给你，然后你就可以签署 2-of-2 多重签名的资金交易。”`,
  paragraph_two: `“等等，如果我签了，我们又回到了原点：你可以在给我一杯闪电柠檬饮后广播这个交易，而我却拿不到钱。”`,
  paragraph_three: `“在我签署之前，我需要保证这个退款交易可以被撤销。”`,
  paragraph_four: `“一旦你真的支付给我闪电柠檬饮，你就不应该能够广播这个退款交易。如果你在它被撤销后仍试图广播，我将获得 <span className="italic">全部</span> 100,000 satoshi！”`,
},
updating_the_state_three: {
  title: `撤销机制`,
  nav_title: `撤销机制`,
  heading_one: `撤销机制`,
  paragraph_one: `你可以通过为 100,000 satoshi 的输出增加额外条件，使 Laszlo 可以撤销。逻辑分支应允许 Laszlo 用他的私钥和你生成的新私钥来花费输出。撤销交易时，你将把新私钥交给 Laszlo。这种做法很不寻常，但它让 100,000 satoshi 处于风险状态，并允许 Laszlo 在你尝试广播交易时使用撤销密钥回收资金。`,
  paragraph_two: `你生成一对新密钥：一个私钥 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">REVOCATION_YOU_1</span> 和 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">PUBKEY(REVOCATION_YOU_1)</span>。每次你想更新支付通道状态时，都要生成这样一对新密钥。`,
  heading_two: `操作指南`,
  revocation_list_one: `在脚本中添加 IF 条件，使 Laszlo 仅在同时拥有撤销密钥时才能花费输出（你将继续保密该密钥，直到需要撤销时使用！）`,
  revocation_list_two: `点击 <span className="rounded-sm px-1.5 py-1 h-[28px] bg-[#0000004D] m-0.5 text-base">Send to Laszlo</span> 发送给 Laszlo，以便他签署`,
  revocation_list_three: `暂时不要自己签署！`,
  heading_three: `提示`,
  paragraph_three: `输出 0 可以由以下方式支出：`,
  hint_one: `如果你领取资金，初始堆栈：<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> SIG(YOU) 1 </span>`,
  hint_two: `如果 Laszlo 领取资金，初始堆栈：<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> 0 SIG(REVOCATION_YOU_1) SIG(LASZLO) 0 </span>`,
},
updating_the_state_four: {
  title: `撤销的竞赛`,
  nav_title: `撤销的竞赛`,
  paragraph_one: `—LASZLO：“这更好了，但我突然想到，即使我有撤销密钥，你和我之间仍然会有一场争夺输出的竞赛。”`,
  paragraph_two: `“我需要一定的领先时间，这样我才能及时发现你是否欺骗我，然后用撤销密钥回收比特币。”`,
},
updating_the_state_five: {
  title: `时间锁`,
  nav_title: `时间锁`,
  heading_one: `时间锁`,
  time_lock_list_one: `在你可以花费输出之前增加 700 个区块的延迟`,
  time_lock_list_two: `点击 <span className="rounded-sm px-1.5 py-1 h-[28px] bg-[#0000004D] m-0.5 text-base">Send to Laszlo</span> 发送给 Laszlo，以便他签署`,
  time_lock_list_three: `暂时不要自己签署！`,
  heading_two: `提示`,
  paragraph_one: `输出 0 可以由以下方式支出：`,
  hint_one: `如果你在 700 个区块后领取资金：<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">SIG(YOU) 1</span>`,
  hint_two: `如果 Laszlo 领取资金：<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">0 SIG(REVOCATION_YOU_1) SIG(LASZLO) 0 </span>`,
},
updating_the_state_six: {
  title: `与 Laszlo 打开通道`,
  nav_title: `与 Laszlo 打开通道`,
  paragraph_one: `这一次，当你把交易给 Laszlo 时，他微笑并鼓掌！他签署了退款（子）交易，现在你可以签署并广播父交易，将资金存入 2-of-2 多重签名。支付通道现在已经开启！`,
},
making_a_payment_one: {
  title: `进行支付`,
  nav_title: `进行支付`,
  heading_one: `进行支付`,
  paragraph_one: `我们来回顾一下：`,
  list_one: `你已将 100,000 satoshi 发送到你和 Laszlo 的 2-of-2 多重签名输出。`,
  list_two: `你手上离线有一笔退款交易，它花费了该输出。`,
  list_three: `退款交易指定了两种资金使用方式：`,
  list_three_sub_one: `你在 700 个区块后可收回全部 99,000 satoshi（扣除费用），或者`,
  list_three_sub_two: `如果 Laszlo 拥有你的私钥 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">REVOCATION_YOU_1</span>，他可拿走全部资金`,
  list_four: `Laszlo 已经签署了退款交易，你随时可以签署它。`,
  list_five: `一旦 Laszlo 签署了退款（子）交易，你就可以安全地签署并广播父交易，将资金发送到 2-of-2 多重签名。`,
  paragraph_two: `资助多重签名输出的交易称为 <span className="font-bold">资金交易</span>。在区块链上确认它会 <span className="font-bold">开启</span>支付通道。`,
  paragraph_three: `花费资金输出的离线退款交易称为 <span className="font-bold">承诺交易</span>。在区块链上确认它会 <span className="font-bold">关闭</span>通道。第一个承诺交易是你的全额退款，因为你还没有向 Laszlo 支付任何款项。`,
  paragraph_four: `通道开启后，你和 Laszlo 可以通过协商新的承诺交易并撤销旧的，实现离线支付。随着你购买更多饮品，你的“退款”金额会减少，而 Laszlo 在原始 100,000 satoshi 中的份额会上升。`,
},
making_a_payment_two: {
  title: `购买闪电柠檬饮！`,
  nav_title: `购买闪电柠檬饮！`,
  heading_one: `购买闪电柠檬饮！`,
  paragraph_one: `现在终于可以离线支付给 Laszlo 了。我们将“简单地”在更新的承诺交易中增加一个 1,000 satoshi 的输出给他。同时，我们需要承诺永远不广播旧的承诺交易，否则 Laszlo 将无法收到款项。这个保证通过将撤销密钥发送给 Laszlo 来实现。`,
  paragraph_two: `你为这一状态生成了另一个撤销密钥 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">REVOCATION_YOU_2</span>。如果你想重复此过程购买第二杯饮料，你需要撤销 <span className="font-bold">此</span>交易，并生成新的承诺交易，确保 Laszlo 收到第二杯闪电柠檬饮的付款。毕竟是派对！`,
  heading_two: `操作指南`,
  list_one: `从你的输出中扣除 1,000 satoshi`,
  list_two: `在第二个输出增加 1,000 satoshi 并填写 Laszlo 的脚本`,
  list_three: `点击“Send to Laszlo”发送给 Laszlo 以便他签署`,
  list_four: `暂时不要自己签署！`,
  heading_three: `提示`,
  paragraph_three: `输出 0 可以由以下方式支出：`,
  hint_one: `'Refund' 标签现在称为 'Initial Commitment'。你可以用它查看上一个状态的脚本。`,
  hint_two: `你在 700 个区块后：<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">SIG(YOU) 1 </span>`,
  hint_three: `Laszlo：<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> 0 SIG(REVOCATION_YOU_2) SIG(LASZLO) 0 </span>`,
  paragraph_four: `输出 1 由 Laszlo 支出：<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> SIG(LASZLO) </span>`,
},
making_a_payment_three: {
  title: `Laszlo 的区块链困境`,
  nav_title: `Laszlo 的区块链困境`,
  paragraph_one: `Laszlo 看了一眼这笔交易，拿起吧台后的杯子，却没有倒出闪电柠檬饮。`,
  paragraph_two: `—LASZLO：“等等，如果你不签署这个交易，我什么都拿不到。你可能带着闪电柠檬饮消失，而我无法在链上确认任何交易。也许你应该先签署，再发给我，这样我们都有一份副本？”`,
},
making_a_payment_four: {
  title: `Holocat 的无信任警告`,
  nav_title: `Holocat 的无信任警告`,
  paragraph_one: `这时，Holocat 出现在桌子上，站起后腿，前爪伸出，喵了一声。`,
  paragraph_two: `—HOLOCAT：“等等，你不能把这个交易的签名给 Laszlo！下次你支付时，要给他撤销密钥 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">REVOCATION_YOU_2</span>。这样他就可以偷走全部 100,000 satoshi！”`,
  paragraph_three: `事情有点复杂。在他给你闪电柠檬饮之前，Laszlo 需要一些保证，确保他会收到款项。但他不能拥有你的交易，否则就能访问你所有的资金。Laszlo 很靠谱，他的酒吧也是城里最棒的，但最好是我们不必完全信任他。`,
},
making_a_payment_five: {
  title: `不对称`,
  nav_title: `不对称`,
  heading_one: `不对称`,
  paragraph_one: `我们知道希望 Laszlo 签署第一笔交易，但又不希望他拥有我们的签名。我们需要构建第二笔交易，<span className="font-bold">包含</span>我们的签名，但不能让他不公平地支配所有资金。`,
  paragraph_two: `如果 Laszlo 有自己的承诺交易，那么这个交易也应该可以被撤销。是的！事实上，Laszlo 的承诺交易是你的镜像。可撤销时间锁脚本将使用 Laszlo 的第一个撤销密钥 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">PUBKEY(REVOCATION_LASZLO_1)</span>，大额退款输出直接给你，无需任何额外操作。`,
  heading_two: `操作指南`,
  list_one: `填写 Laszlo 承诺交易的金额和输出脚本`,
  list_two: `签署并发送给 Laszlo，然后他签署你的承诺交易并返还给你`,
  heading_three: `提示`,
  hint_one: `你可以切换到 'Commitment_you' 标签查看你的承诺交易脚本。`,
  paragraph_three: `输出 0 可以由以下方式支出：`,
  hint_two: `Laszlo，在 700 个区块后：<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">SIG(LASZLO) 1 </span>`,
  hint_three: `你：<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> 0 SIG(REVOCATION_LASZLO_1) SIG(YOU) 0 </span>`,
  paragraph_four: `输出 1 由你支出：<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> SIG(YOU) </span>`,
},
making_a_payment_six: {
  title: `完成支付`,
  nav_title: `完成支付`,
  heading_one: `完成支付`,
  paragraph_one: `再来回顾一下。`,
  list_one: `2-of-2 输出已在区块链上确认`,
  paragraph_two: `有几笔离线交易花费了锁定在 2-of-2 多重签名中的 100,000 satoshi：`,
  paragraph_three: `你将拥有以下交易：`,
  paragraph_four: `承诺交易 1（你）`,
  commitment_one_you: {
    list_one: `<span className="font-semibold">输入 0：</span> 由 Laszlo 签署`,
    list_two: `<span className="font-semibold">输出 0：</span> 700 个区块后 99,000 sats 给你，或 Laszlo 拥有 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">REVOCATION_YOU_1</span>`,
    list_three: `<span className="font-semibold">矿工费：</span> 1,000 sats`,
  },
  commitment_two_you: {
    list_one: `<span className="font-semibold">输入 0：</span> 由 Laszlo 签署`,
    list_two: `<span className="font-semibold">输出 0：</span> 700 个区块后 98,000 sats 给你，或 Laszlo 拥有 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">REVOCATION_YOU_2</span>`,
    list_three: `<span className="font-semibold">输出 1：</span> 1,000 sats 给 Laszlo`,
    list_four: `<span className="font-semibold">矿工费：</span> 1,000 sats`,
  },
  paragraph_five: `承诺交易 2（你）`,
  paragraph_six: `Laszlo 将拥有以下交易：`,
  paragraph_seven: `承诺交易 2（Laszlo）`,
  commitment_two_laszlo: {
    list_one: `<span className="font-semibold">输入 0：</span> 由你签署`,
    list_two: `<span className="font-semibold">输出 0：</span> 700 个区块后 1,000 sats 给 Laszlo，或你拥有 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">REVOCATION_LASZLO_1</span>`,
    list_three: `<span className="font-semibold">输出 1：</span> 98,000 sats 给你`,
    list_four: `<span className="font-semibold">矿工费：</span> 1,000 sats`,
  },
  paragraph_eight: `这三笔交易都已签署且有效，但 Laszlo 仍未给你闪电柠檬饮。为什么？只剩一件事：将你之前的撤销密钥 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">REVOCATION_YOU_1</span> 发送给 Laszlo！`,
  success_bar: `发送 REVOCATION_YOU_1 给 Laszlo`,
},
making_a_payment_eight: {
  title: `再支付一次`,
  nav_title: `再支付一次`,
  heading_one: `再支付一次`,
  paragraph_one: `夜还很年轻，你还没开 Budgetcopter 回家。要不要再来一杯闪电柠檬饮？现在你和 Laszlo 已经有了不对称交易和撤销密钥流程，让我们再次运行这个协议。`,
  paragraph_two: `代表当前状态的两笔承诺交易（你已经为闪电柠檬饮支付了 1,000 sats）显示在你的 ePhone Infinity 屏幕上。`,
  heading_two: `操作指南`,
  list_one: `更新 Laszlo 新承诺交易的金额和输出脚本`,
  list_two: `签署 Laszlo 的交易并发送给他`,
  list_three: `更新你的承诺交易：Laszlo 将通过发送给你 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">REVOCATION_LASZLO_1</span> 来撤销他的上一个状态。更新你的承诺交易中的金额和输出脚本。`,
  list_four: `将你的交易发送给 Laszlo 以便他签署`,
  list_five: `获得 Laszlo 的签名后，将你之前的撤销密钥 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">REVOCATION_YOU_2</span> 发送给他`,
  paragraph_three: `尽情享用 🍋🍹`,
  heading_three: `提示`,
  paragraph_four: `别忘了预留 1,000 sats 用作矿工费`,
  paragraph_five: `输出 0 可由以下方式支出：`,
  step_one: {
    hint_one: `Laszlo，700 个区块后：<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">SIG(LASZLO) 1</span>`,
    hint_two: `你：<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">0 SIG(REVOCATION_LASZLO_2) SIG(YOU) 0</span>`,
    hint_three: `输出 1 由你支出：<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">SIG(YOU)</span>`,
  },
  step_two: {
    hint_one: `你，700 个区块后：<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">SIG(YOU) 1</span>`,
    hint_two: `Laszlo：<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">0 SIG(REVOCATION_YOU_3) SIG(LASZLO) 0</span>`,
    hint_three: `输出 1 由 Laszlo 支出：<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">SIG(LASZLO)</span>`,
  },
},

outro_one: {
  title: `结尾`,
  nav_title: `整晚尽情嗨`,
  paragraph_one: `你可以整晚这么玩！嗯，直到你的 100,000 satoshi 全部发送给 Laszlo 为止`,
  paragraph_two: `别忘了喝点水！他们还有全息热狗和玉米片。`,
},

outro_two: {
  title: `结尾`,
  nav_title: `回家途中`,
  paragraph_one: `经过漫长而奇怪的一天，你付了饮料钱准备回家。但当你打开 3D 打印的小屋门时——糟了！又是 Vanderpoole！这到底是真的，还是你喝了太多 Mempool 玛格丽塔？尽管他的四周都有全息猫护卫，他并不想打架。`,
  paragraph_two: `—VANDERPOOLE：“我们其实不太认识，尽管正如我曾祖父所说，陌生人的命运常常交织。我需要你听我说。所有 Satoshi Nakamoto 的事情，是我在尝试拯救家族生意。你无法想象矿业对我们意味着什么。我想我当时还没准备好改变，只想保持现状。”`,
},

outro_three: {
  title: `结尾`,
  nav_title: `比特币社区`,
  paragraph_one: `你问他为什么 Satoshi Nakamoto 这个名字对他如此重要。`,
  paragraph_two: `—VANDERPOOLE：“这是比特币中唯一比 Bitrey 和 Vanderpoole 更响亮的名字。有人使用 Satoshi Nakamoto 告诉我，比特币早在一个世纪前就已经超出其创造者的控制。这就是为什么，为了挽救 Vanderpoole 的名声，我试图占据更显著的名字。你无法理解创造新币的兴奋感。那时对我来说是魔法，现在仍是魔法。”`,
  paragraph_three: `—VANDERPOOLE：“我现在明白，即便我是 Satoshi 的曾孙，比特币也不是由领袖定义的，而是由社区定义的。即便是 Satoshi 也无法改变比特币已成的样子。这一直是比特币伟大的原因，也是为什么其他无数模仿比特币的币从未长久。”`,
},

outro_four: {
  title: `结尾`,
  nav_title: `Vanderpoole 的恶行`,
  paragraph_one: `Vanderpoole 拿起你的全息猫，它开始咕噜。人类很复杂，而猫比任何人都更清楚这一点，无论是全息猫还是现实猫。`,
  paragraph_two: `—HOLOCAT：“你不是恶棍，Vanderpoole 先生。但也许，你也许，可能太在意了。”`,
  paragraph_three: `—VANDERPOOLE：说的没错。`,
},

outro_five: {
  title: `结尾`,
  nav_title: `你成功了！！！`,
  heading_one: `你成功了！！！`,
  paragraph_one: `就像 Satoshi 一样，你曾是无名之辈，但你的想法有价值，所以人们追随你。Satoshi 已经离开，但他的精神与思想依然存在。凭借你新掌握的比特币开发技能、适度的谦逊和坚持不懈，你可以在这个优雅的系统中留下持久印记，它已经让世界在无许可、抗审查的货币下团结了百年。新的冒险在代码和思想的开放市场中等待你。比特币能够存续，正因为有人像你一样贡献力量。这就是为什么我们都是 Satoshi。`,
},

outro_six: {
  title: `超越拯救 Satoshi`,
  nav_title: `走向超越拯救 Satoshi`,
  heading: `比特币仍需要你的帮助…`,
  paragraph_one: `尽管 2139 年似乎遥远，但比特币的使命永恒不变：创造公平、开放、诚实的货币。然而，要实现这一愿景，需要每个人的努力——包括你。`,
  paragraph_two: `你已经展示了你对比特币的理解。现在正是将知识转化为行动、为这项重要技术贡献力量的最佳时机。`,
  paragraph_three: `<Link className="underline" href="https://bitcoindevs.xyz/">比特币开发者项目</Link> 将引导未来一代开源贡献者。今天成为比特币英雄，仅需轻点鼠标。`,
  paragraph_four: `我们都是 Satoshi。`,
},
tab_data: {
  signed: `已签署`,
  pending: `待处理`,
  deposit: `这是你钱包中的 101,000 sats 输出，你将用于与 Laszlo 的链下支付。`,
  payment: `这是你向 Laszlo 的链下支付。`,
  multisig: `这笔交易将为你和 Laszlo 创建一个多重签名输出。`,
  refund_0: `这笔交易确保如果 Laszlo 消失，资金不会丢失。`,
  refund_1: `这笔交易确保如果 Laszlo 消失，资金不会丢失。同时保证你支付闪电柠檬饮后不会广播交易。`,
  refund_2: `这笔交易确保如果 Laszlo 消失，资金不会丢失。同时防止你在支付闪电柠檬饮后立即领取资金。如果你尝试全额退款，包括支付 1,000 sats 的闪电柠檬饮，700 个区块的延迟给了 Laszlo 足够时间发现。`,
  commitment_you: `这是本支付通道的第二笔承诺交易，支付给 Laszlo 1,000 sats`,
  commitment_laszlo: `这是 Laszlo 的承诺交易版本。`,
},

resources: {
  output_zero_sig: `输出 0 签名`,
  output_one_sig: `输出 1 签名`,
  sats_distribution: `Laszlo 应收到足够的 sats 用于闪电柠檬饮，1,000 sats 矿工费由你的找零支付。`,
  output_script: `输出锁定脚本不应包含任何签名（即 <span className="rounded-sm px-1.5 py-1 font-mono bg-[#0000004D] m-1 text-base whitespace-nowrap">OP_PUSH SIG()</span>）。如果脚本中有，直接移除即可。`,
  miner_fees_basic: `别忘了预留 1,000 sats 作为矿工费。`,
  miner_fees: `别忘了从找零中预留 1,000 sats 用作矿工费。`,
},
},
///CHALLENGE PAGE
challenge_list: {
  coming_soon: `敬请期待，稍安勿躁。`,
},

chapter: {
  chapter_locked_one: `完成第`,
  chapter_locked_two: `章以解锁。`,
  coming_soon: `敬请期待，稍安勿躁。`,
  description: `探索 Satoshi 的奥秘，同时学习比特币的知识。`,
},

hero: {
  title: `拯救 Satoshi`,
  description: `通过编码揭开比特币的神秘面纱。`,
  start_journey: `开始`,
  tell_more: `告诉我更多`,
},

footer: {
  paragraph_one: `这是比特币社区的开源作品。`,
  link: `查看源码`,
},

navbar: {
  intro: `简介`,
  outro: `结尾`,
  chapter: `章节`,
  chapter_complete: `章节完成`,
  challenge: `挑战`,
  help_tooltip: `需要帮助？`,
  your_language: `你的语言`,
},

modal_signin: {
  heading: `登录`,
  pre_signin_paragraph_one: `在下面输入你的私钥以恢复账户和进度。`,
  post_signin_paragraph_one: `很高兴你回来拯救 Satoshi！你可以直接从上次课程开始。`,
  prompt: `输入你的私钥`,
  confirm: `登录`,
  create_account: `还没有账户？`,
  login: `登录`,
  welcome_back: `欢迎回来！`,
  progress_redirect: `带我去上次的进度`,
},

modal_logout: {
  heading: `你已登录`,
  paragraph_one: `你的会话将保持活跃，直到你使用下面按钮登出。`,
  private_key: `你的私钥`,
  signout: `登出`,
},

modal_signup: {
  heading: `保存你的进度`,
  paragraph_one: `复制并保存一段简单代码，以便在此浏览器中保存和加载你的进度。如果你已有代码，可在此加载进度。`,
  subheading_one: `选择头像`,
  subheading_two: `备份你的私钥`,
  generate: `准备好了吗？代码已复制并备份了吗？请务必保存，因为丢失后无法恢复。`,
  confirm: `完成`,
  acknowledged: `我确认已保存此私钥，并知道未来完成挑战时将需要它。`,
},

difficulty_selection: {
  NORMAL: `启用困难模式以增加挑战难度。`,
  HARD: `禁用困难模式以降低挑战难度。`,
},

social: {
  twitter_share: `通过 X 分享`,
  nostr_share: `通过 nostr 分享`,
  sharing: `分享中...`,
  shared: `已分享！`,
  share_error: `分享失败`,
},

disclaimer: {
  description: `我们很高兴你来探索。请注意，有些挑战需要基本的编程经验（提供提示）。试试看并分享你的 <Link href="https://docs.google.com/forms/d/e/1FAIpQLSf1xpNqUYJyvYL5IZDnxy78273pkqzfYW2Hf91H4Do4KHgy9g/viewform?usp=sf_link" className="underline">反馈</Link>` ,
},

opcode: {
  run: `运行脚本`,
  reset: `重置`,
},

status_bar: {
  begin_message: `完成上方挑战以继续...`,
  error_message: `嗯……还不太对……`,
  in_progress_message: `目前看起来不错...`,
  success_message: `做得好！`,
  next_step_message: `现在一切正常，让我们进入下一步。`,
  im_stuck: `我卡住了`,
  try_again: `再试一次`,
  next: `下一步`,
  skip_challenge_first: `让我们开始第一个挑战！`,
  skip_challenge_last: `让我们开始最后一个挑战！`,
},

hasher: {
  placeholder: `在这里输入...`,
  return_hash: `下面将显示你的输入转换为哈希`,
},

hashrate: {
  start: `开始`,
  running: `运行中`,
  blocks_found: `发现区块`,
  hashrate: `算力`,
  partial_solutions: `部分解`,
},

runner: {
  run: `运行脚本`,
  running: `运行中`,
  pause: `暂停`,
  result: `结果`,
  computing: `计算中...`,
  evaluation: `评估`,
  script_output: `脚本输出`,
  waiting: `等待你在上方输入...`,
  poor: `这是有效代码，但不是我们期望的结果。请再试一次。`,
  good: `做得不错，虽然不是完美，但仍被认为正确。可继续尝试或前进，你选择。`,
  success: `干得漂亮！你的代码很棒！`,
  language_tabs: {
    locked: `语言被禁用，因为你已在此章节开始使用`,
    reset: `重置终端`,
  },
},

notfound: {
  first: `嗯……我们在哪里？`,
  second: `不太清楚这里是何处或是什么地方。`,
  third: `我们可能迷失在空间（或时间）中。`,
  back_safety: `返回安全区域`,
},

error: {
  first: `出现问题！`,
  second: `全息猫可能又咬断了一些电缆。坏猫！`,
  reload: `重试`,
},

help_page: {
  main_heading: `学习资源`,
  main_subheading: `我们能提供哪些有用信息和资源以帮助进一步学习？`,
  tips_heading: `小技巧`,
  tips_subheading: `如果学习者卡住了，我们想提供哪些具体提示？`,
  spoilers_heading: `提示答案`,
  spoilers_confirm: `是的，我想看答案`,
  pseudo_confirm: `是的，我想看伪代码`,
  solution: `本挑战的解决方案`,
  pseudo_solution: `本挑战的伪代码解决方案`,
  solution_one: `本挑战第一部分的解决方案`,
  feedback: `你的反馈非常有价值，可帮助我们改进工作，请通过 <a href="https://docs.google.com/forms/d/e/1FAIpQLSf1xpNqUYJyvYL5IZDnxy78273pkqzfYW2Hf91H4Do4KHgy9g/viewform" target="_blank" rel="noreferrer">此链接</a> 提交反馈。`,
  help_suggestion: `如果你卡住了，请按右上角的 "?" 按钮。它提供有用的资源和提示。`,
},
}

export default translations
