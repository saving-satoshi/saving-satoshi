const translations = {
  shared: {
    next: `계속`,
    start: `시작`,
    copy: `복사`,
    info: `정보`,
    copy_acknowledged: `복사되었습니다!`,
    about: `자세히`,
    chapter: `챕터`,
    chapters: `챕터`,
    challenge: `도전과제`,
    challenges: `도전과제들`,
    coming_soon: `곧 공개됩니다`,
    start_chapter: `챕터 시작하기`,
    back: `뒤로가기`,
    end: `끝내기`,
    close: `닫기`,
    poweroff: `챕터 선택으로 돌아가기`,
    loading: `로딩중`,
    bitcoin_dev_project: `비트코인 개발 프로젝트`,
  },
  ///ABOUT PAGE
  about: {
    title: `자세히`,
    mobile_title: `Saving Satoshi의 모든 것`,
    subtitle: `현재는 2139년. 마지막 비트코인이 단 2주 뒤 채굴될 예정이다. 사토시 광장에서는 카운트다운을 알리는 시계가 몇달째 째깍째깍 돌아가고 있다.`,
    intro: `이 역사적인 순간을 앞두고, 비트코인 네트워크가 갑자기 멈춰버린다.<br><br> 당신의 Everything Watch에는 사토시 나카모토라는 이름을 사용하는 누군가가 보낸 WhiskerWare 브랜드의 홀로켓이 도착한다. (*홀로캣: 고양이 형상의 전자 홀로그램.) 당신은 고양이 코를 눌러 홀로캣을 연다.`,

    project: {
      title: `비트코인은 어렵지만, 배우는 방법이 어려울 필요는 없다.`,
      paragraph_one: `Saving Satoshi는 직접 체험하며 배우는, 부담 없는 비트코인 게임입니다. 이 재밌는 게임은 혁신적인 도전과제와 스토리 텔링을 통해 비트코인 개발 입문을 도와줍니다.`,
      paragraph_two: `이 콘텐츠는 코딩을 즐기는 사람들, 기술자들, 그리고 비트코인이 <span className="italic">실제로</span> 어떻게 작동하는지 알고싶은 호기심 많은 이들을 위해 흥미롭게 구성되었습니다. 특히 비트코인 오픈 소스 소프트웨어(₿OSS)가 선사하는  놀라움을 직접 체험하고 함께 만들어가고 싶은 사람들을 위한 게임입니다.`,
      paragraph_three: `각 챕터마다 코드 기반 학습 콘텐츠, 시뮬레이션, 퍼즐로 가득합니다. 비트코인의 어려운 개념들도 즐겁게 배울 수 있을 겁니다.`,
      paragraph_four: `간단하고 직관적인 예시를 통해 플레이어는 중요한 개념들을 자연스럽게 익히게 됩니다. 또한 몰입감 있는 경험들과 풍부한 시각적 요소와 매끄러운 상호작용을 통해, 당신은 다음과 같은 주제를 배우게 될것입니다:`,
      chapter_topics: {
        list_one: `제네시스 블록에 숨겨진 비밀 메시지를 찾아내고 해독하는 법`,
        list_two: `해시 함수와 작업 증명(Proof-of-Work)`,
        list_three: `채굴 풀의 작동 원리`,
        list_four: `타원 곡선 암호학(Elliptic Curve Cryptography, ECC)의 기초와 공개-개인키에서 주소를 알아내는 법`,
        list_five: `ECDSA 메시지 서명과 검증법`,
        list_six: `비트코인 트랜잭션 해보기`,
        list_seven: `트랜잭션을 조합해 블록 템플릿을 만드는 방법`,
        list_eight: `비트코인 코어 RPC API를 사용하여 블록과 트랜잭션을 살펴보는 방법`,
        list_nine: `비트코인 스크립트`,
        list_ten: `라이트닝 네트워크의 작동 원리`,
      },
      paragraph_five: `이 게임은 단순한 교육을 넘어, 비트코인 네트워크의 지속 가능성과도 관련된 중요한 이야기를 다룹니다. 이 게임은 비트코인의 문화, 역사, 디자인 등 다양한 요소들을 다룰 것입니다.`,
      paragraph_six: `우리에게 비트코인은 모두가 이익을 얻을 수 있는 긍정적인 기술입니다. 이 프로젝트는 비트코인을 알리고자 모인 열정적인 사람들이 만들어낸 최고 수준의 결과물이자, 100% 무료 오픈 소스(FOSS)입니다. Saving Satoshi가 어떻게 만들어졌는지 궁금하다면, Bitcoin Design Guide의 <Link href="https://bitcoin.design/guide/case-studies/saving-satoshi" className="underline" target="_blank">사례연구</Link>를 참고하면 됩니다.`,
      paragraph_seven: `게임을 즐기고, 워크숍을 열거나 코드·콘텐츠 제작에 기여하는 등 Saving Satoshi 커뮤니티에 참여할 수 있는 다양한 방법이 있습니다. 여러분의 참여는 언제나 환영입니다. 참여하려면 <Link href="https://github.com/saving-satoshi/saving-satoshi" className="underline" target="_blank">Github</Link>에서 Saving Satoshi를 팔로우하고 <Link href="https://discord.gg/eBGRaCSjg5" className="underline" target="_blank">#saving-satoshi 채널</Link>에 참가하시면 됩니다.`,
      paragraph_eight: `또한 <Link href="https://x.com/savingsatoshi" className="underline" target="_blank">X</Link>, <Link href="https://njump.me/npub1vy6wcgw6jhhtcmpawvlnsfx7g8qt8r40z7qlks9zwa4ed57vm5eqx527hr" className="underline" target="_blank">nostr</Link>, and <Link href="https://bsky.app/profile/bitcoindevs.bsky.social" className="underline" target="_blank">Bluesky</Link>에서 저희와 연결되어 대화에 참여하실 수 있습니다. 여러분의 따뜻한 응원과 활발한 참여를 기다리겠습니다!`,
    },

    contributing: {
      title: `기여방법`,
      paragraph_one: `Saving Satoshi는 누구나 함께할 수 있는 오픈 소스 프로젝트입니다.`,

      feedback: {
        title: `피드백`,
        paragraph_one: `우리는 여러분의 의견에 귀를 기울이고 있습니다! 여러분의 생각과 아이디어는 매우 소중합니다. 잘한 점, 아쉬웠던 점, 개선할 부분을 언제든 알려주세요. <a href="https://docs.google.com/forms/d/e/1FAIpQLSf1xpNqUYJyvYL5IZDnxy78273pkqzfYW2Hf91H4Do4KHgy9g/viewform" target="_blank" rel="noreferrer">피드백</a>에서 작성할 수 있습니다.`,
      },

      contribute: {
        title: `건의하기`,
        paragraph_one: `모든 의견과 건의를 환영합니다. 코드 변경 검토와 품질 관리를 도와주실 분을 찾고 있습니다. 코드 개선 아이디어가 있다면 <a href="https://github.com/saving-satoshi/saving-satoshi" target="_blank" rel="noreferrer">GitHub</a>에서 pull request를 보내거나 issue에 자유롭게 남겨주세요.`,
        paragraph_two: `디자인, 스토리 등 어떤 분야든 참여하고 싶다면 <a href="https://discord.gg/B9WURkwF" target="_blank" rel="noreferrer">Bitcoin Design Discord</a>의 #saving-satoshi 채널에 글을 남겨주세요. 어떤 방식으로 참여하고 싶은지 알려주시면, 함께할 수 있도록 도와드릴게요.`,
      },
    },

    privacy: {
      title: `개인정보에 대한 약속`,
      paragraph_one: `Saving Satoshi는 사용자 프라이버시와 보안을 최우선으로 생각합니다. 저희는 앱 사용 추적의 목적과 방식을 투명하게 공유하고자 합니다. 투명성을 유지하면서도 앱추적을 위해 <Link href="https://umami.is/" className="underline" target="_blank">Umami</Link>라는 강력한 툴을 사용하고 있습니다.`,
      sub_heading_one: `Umami란?`,
      paragraph_two: `Umami는 개인정보를 침해하지 않으면서 유용한 데이터를 제공하는 오픈 소스 분석 플랫폼입니다. 이 데이터를 바탕으로 더 나은 제품을 만들고, 사용자 경험을 향상시킬 수 있습니다. Umami 대시보드는 <Link className="underline" href="https://visits.bitcoindevs.xyz/share/zFmD5WIus09mDxEf/Saving%20Satoshi" target="_blank">여기</Link>에서 확인할 수 있습니다.`,
      sub_heading_two: `어떤 데이터를 수집하나요?`,
      paragraph_three: `여러분의 개인정보는 언제나 저희의 최우선 고려사항입니다. 예를 들어:`,
      list_item_one_title: `제품 개선:`,
      list_item_one_text: `사용자들의 앱 사용 패턴과 불편한 점을 파악해 개선에 활용합니다.`,
      list_item_two_title: `호환성:`,
      list_item_two_text: `여러분이 주로 사용하는 기기와 플랫폼을 파악해 다양한 환경에서도 문제없이 작동하게 만듭니다.`,
      sub_heading_three: `여러분의 개인정보는 소중합니다.`,
      paragraph_four: `우리는 개인정보 보호를 최우선으로 생각합니다. 우리는 개인 식별 정보를 수집하지 않으며, 수집된 데이터들은 오직 앱개선을 위해서만 사용됩니다. 수집된 데이터는 제 3자에게 공유하거나 판매되지 않습니다.`,
      paragraph_five: `개인정보 보호 관련 문의가 있다면 언제든 연락주세요. 앱 사용 중에도 투명성을 지키고, 여러분의 안전을 책임지는 것이 저희의 사명입니다.`,
    },

    contributors: {
      title: `즐기세요!`,
      paragraph_one: `Saving Satoshi는 많은 분들의 도움이 없었다면 불가능했을 겁니다.`,
      paragraph_two: `이 프로젝트의 핵심 팀 멤버는 다음과 같습니다: <Link href="https://adamjonas.com/" className="underline" target="_blank">Adam Jonas</Link>, <Link href="https://www.germanysbestkeptsecret.com/" className="underline" target="_blank">Christoph Ono</Link> (design lead), <Link href="https://satsie.dev/" className="underline" target="_blank">Satsie</Link>, <Link href="https://github.com/benalleng" className="underline" target="_blank">BenAllenG</Link> (engineering lead), <Link href="https://github.com/pinheadmz" className="underline" target="_blank">Matthew Zipkin</Link> (lesson content lead), <Link href="https://x.com/TuedonTuoyo" className="underline" target="_blank">Tuedon Tuoyo</Link>, <Link href="https://www.artassoiants.com/" className="underline" target="_blank">Art Assoiants</Link> (product manager) 그리고 이 모든 걸 함께한 4마리의 신비로운 고양이들, <Link href="https://spiral.xyz/" className="underline" target="_blank">Spiral</Link>의 친구들이 있습니다.`,
      paragraph_three: `이 프로젝트에 함께해 주신 소중한 기여자들: <Link href="https://x.com/ecurrencyhodler" className="underline" target="_blank">ecurrencyhodler</Link>, <Link href="https://www.jtwoodhouse.com/" className="underline" target="_blank">JT Woodhouse</Link>, <Link href="https://x.com/_Jsms_" className="underline" target="_blank">JSMS</Link>, <Link href="https://github.com/afterburn" className="underline" target="_blank">Kevin Karsopawiro</Link>, <Link href="https://github.com/daviroo" className="underline" target="_blank">daviroo</Link>, <Link href="https://github.com/nully0x" className="underline" target="_blank">nully0x</Link>, <Link href="https://github.com/vinayaksh42" className="underline" target="_blank">Vinayak Sharma</Link>, <Link href="https://github.com/shaavan" className="underline" target="_blank">Shashwat Vangani</Link>, <Link href="https://github.com/aureleoules" className="underline" target="_blank">Aurèle Oulès</Link>, <Link href="https://github.com/sabakhilji" className="underline" target="_blank">sabakhilji</Link>. 그리고 한국어 번역은 <Link href="https://x.com/peachbtc?s=21" className="underline" target="_blank">피치⚡</Link> (<Link href="http://bsl.pub" className="underline" target="_blank">Bitcoin Social Layer</Link>)가 했습니다.`,
      paragraph_four: `더 많은 기여자 목록은 <Link href="https://github.com/saving-satoshi/saving-satoshi/graphs/contributors" className="underline" target="_blank">GitHub</Link>에서 확인하실 수 있어요.`,
    },

    satoshi_needs_you: `서두르세요! 사토시가 당신을 기다리고 있습니다.`,
  },

  ///CHAPTERS TITLE PAGE
  chapter_one: {
    title: `눈앞에 숨겨진 비밀`,
    paragraph_one: `2139년. 마지막 비트코인이 채굴되기까지 단 2주 남았습니다. 사토시 광장에선 카운트다운 시계가 수개월째 돌아가고 있습니다. 지금까지 모든 블록에는 비트코인 보상이 있었지만, 곧 그 보상도 끝나갑니다. 100년 넘게 이어져 온 채굴 끝에, 마침내 마지막 비트코인 채굴이 눈앞에 다가왔습니다. 전 세계가 마지막 블록이 채굴되는 역사적인 사건이자, 한 시대가 끝나는 순간을 지켜보고 있습니다.`,
    paragraph_two: `그 순간, 네트워크가 멈춥니다.`,

    ///CHAPTER 1
    intro_one: {
      title: `도입부`,
      nav_title: `채굴자 시위`,
      paragraph_one: `잠시 후, 호버 스크린이 깜빡이며 켜집니다.`,
      paragraph_two: `—데보라 청크: “토마스 반더풀 씨. BitRey의 CEO로서 전 세계 최대 비트코인 채굴풀을 운영하고, 채굴기까지 직접 개발하셨죠. 지금 무슨 일이 벌어지고 있나요? 비트코인이 정말 죽어가고 있나요?”`,
      paragraph_three: `—반더풀: "네, 데보라. 처음부터 설명할게요. 우리 반더풀 집안, 아버지와 할아버지 때부터 블록 21,000부터 채굴을 해왔죠. 그래서 단언할 수 있어요. 지금 네트워크가 멈춘 이유는 전 세계 채굴자들이 의도적으로 채굴기를 껐기 때문입니다. 이건 시위입니다. 아무도 비트코인 발행이 2,100만 개에서 멈추는 걸 원치 않아요. 채굴자들은 수수료만으론 살 수 없거든요.”`,
      start: `계속하기`,
    },

    intro_two: {
      title: `제네시스`,
      nav_title: `사토시의 홀로캣`,
      paragraph_one: `에브리띵 시계에 '사토시 나카모토'라는 이름을 쓰는 사람에게서 WhiskerWare 브랜드 홀로캣이 도착합니다. (*홀로캣: 고양이 형상의 홀로그램) 코를 눌러 메시지를 엽니다.`,
      paragraph_two: `—“비트코인은 죽지 않았어. 하지만 지금 네 도움이 필요해. 고양이를 잊지마." - 사토시 나카모토`,
      paragraph_three: `—사토시? 그 사토시? 비트코인 백서를 쓴 바로 그 사람? 말도 안 돼... 100년 전에 이미 사망했다고 알려졌잖아.`,
      paragraph_four: `정말일까?`,
      paragraph_five: `홀로캣: "얼른 시작해야 해. 내가 도와줄 수는 있지만 서둘러야 해. 야옹~”`,
    },

    genesis_one: {
      title: `제네시스`,
      nav_title: `제네시스의 비밀`,
      heading: `당신의 첫 도전과제`,
      paragraph_one: `비트코인은 검열에 강한 화폐입니다. 누구나 네트워크를 통해 거래를 하여 돈을 보낼 수 있습니다. 거래를 진행하면 채굴자들이 거래를 블록으로 묶어 저장합니다. 채굴자들은 블록체인에 새 블록을 추가할 기회를 두고 경쟁합니다. 이런 구조 덕분에 비트코인은 탈중앙화를 유지할 수 있습니다.`,
      paragraph_two: `비트코인을 만든 익명의 사토시 나카모토는 비트코인의 첫 번째 블록, 제네시스 블록을 직접 채굴했습니다. 그는 첫 비트코인 거래에 비밀 메시지도 남겼습니다. 이제, 그 메시지를 찾고 해독하는 것이 바로 당신의 첫 임무입니다.`,
    },

    genesis_two: {
      title: `제네시스`,
      nav_title: `메시지 찾기`,
      heading: `숨겨진 메시지를 찾아라`,
      paragraph_one: `비트코인 블록체인의 첫 번째 블록, 제네시스 블록을 찾아봅시다. 아래 버튼을 누르면 <Tooltip id="genesis_two_paragraph_one" content="chapter_one.genesis_two.tooltip_block_explorer" theme="bg-[#30435b]">Block Explorers</Tooltip>가 열리고, 0번 블록(제네시스 블록)이 바로 보입니다.`,
      paragraph_two: `아래로 스크롤해서 이 블록에 저장된 거래내역을 펼쳐보세요. “Coinbase” 입력항목을 찾고, “SCRIPTSIG (<Tooltip id="genesis_two_paragraph_two" content="chapter_one.genesis_two.tooltip_hex" theme="bg-[#30435b]">HEX</Tooltip>)”라벨 옆에 있는 값이 바로 인코딩된 메시지입니다.`,
      paragraph_three: `그 값을 복사해서 코드 블록에 붙여넣으세요.`,
      tooltip_block_explorer: `<a  href="https://bitcoinops.org/en/topics/block-explorers/" target="_blank" rel="noreferrer">Block Explorers</a>는 비트코인 거래 정보를 빠르게 조회할 수 있는 도구입니다.`,
      tooltip_hex: `16진수를 뜻하며, 숫자를 16진법으로 표현하는 방식입니다.`,
      view_block_0: `0번 블록보기`,
      placeholder: `찾은 값을 여기에 붙여넣으세요`,
    },

    genesis_three: {
      title: `제네시스`,
      nav_title: `메시지 디코딩`,
      heading: `메시지를 해독해봅시다`,
      paragraph_one: `찾은 메시지는 HEX라는 형식으로 인코딩되어 있습니다. 이제 읽을 수 있도록 ASCII로 변환하는 명령어를 실행해봅시다.`,
      paragraph_two: `아래 명령어를 코드 블록에 있는 터미널에 복사해서 붙여넣고 Enter키를 눌러보세요.`,
      terminal_challenge_lines: `여기에 명령어를 입력하고 Enter키를 누르세요...\n $scriptSigHex 변수는 이미 정의되어 있습니다. \n\n var $scriptSigHex = '04fff...e6b73'`,
      waiting_for_input: `스크립트를 작성과 실행을 기다리고 있습니다...`,
      success: `잘하셨습니다! 해독한 메시지는 2009년 1월 3일, 사토시가 제네시스 블록을 채굴한 날 <Link href="https://en.bitcoin.it/wiki/Genesis_block" target="_blank" className="underline">The Times</Link> 1면을 참조합니다. 놀랍지 않나요? 이 메시지 덕분에 사토시가 비트코인을 만든 동기를 조금 엿볼 수 있습니다. \n\n 계속 해볼까요?`,
    },

    genesis_four: {
      title: `제네시스`,
      nav_title: `첫 성공`,
      subtitle: `축하드립니다! 첫 번째 도전과제를 멋지게 완수했습니다!`,
      paragraph_one: `사토시 나카모토가 제네시스 블록에 숨겨둔 비밀메시지를 성공적으로 찾아냈습니다. 이제 방금 배운 걸 바탕으로 한 걸음 더 나아가봅시다. 다음 도전에서는 이야기의 중요한 단서를 해독해볼겁니다.`,
    },

    transacting_one: {
      title: `트랜잭션`,
      nav_title: `트랜잭션 안에는 무엇이 있을까?`,
      heading: `트랜잭션은 무엇으로 구성될까?`,
      paragraph_one: `트랜잭션에서 가장 중요한 요소는 '입력'과 '출력'입니다. 이전 과제에서는 입력에 숨겨진 비밀 메시지를 해독했죠. 이번에는 출력에 담긴 메시지를 해독해볼겁니다.`,
      paragraph_two: `이제 OP_RETURN 타입 출력을 직접 확인해봅시다.`,
    },

    transacting_two: {
      title: `트랜잭션`,
      nav_title: `OP_RETURN을 찾아라`,
      heading: `OP_RETURN`,
      paragraph_one: `트랜잭션에 비밀 메시지를 숨길 수 있는 또 다른 방법이 있습니다. 비트코인에는 OP_RETURN 이라는 특별한 코드가 있습니다. 이를 이용해 사용자들은 트랜잭션 출력에 메시지를 담을 수 있게 해줍니다. 직접 찾아보도록 합시다.`,
      paragraph_two: `1. <Link href="https://blockstream.info/tx/ff9148605a772a51cba39004df5fb042d40515967a3e38ff5294cfd017c452a9" target="_blank" className="underline">여기</Link>를 클릭해서 특정 트랜잭션을 확인하세요.`,
      paragraph_three: `2. '자세히'를 클릭해 OP_RETURN 부분을 찾아보세요.`,
      paragraph_four: `3. 이제 SCRIPTPUBKEY(ASM) 항목을 찾으세요. OP_RETURN OP_PUSHBYTES_33 부분이 보일 거예요. 이것들은 연산 코드(opcode)라고 부르며, 우리가 주목할 부분은 그 이후에 나오는 데이터입니다.`,
      paragraph_five: `4. OP_RETURN OP_PUSHBYTES_33 뒤에 나오는 긴 문자열을 복사해서 코드블록에 붙여넣어보세요.`,
      input_challenge_label: `OP_RETURN 유형을 입력하세요.`,
    },

    transacting_three: {
      title: `트랜잭션`,
      nav_title: `OP_RETURN 해독하기`,
      heading: `또 다른 비밀 메시지`,
      paragraph_one: `트랜잭션 출력 부분에 담긴 메시지를 찾아냈습니다.`,
      paragraph_two: `이전 과제에서처럼, 이번에도 그 메시지를 해독해볼 차례예요. 트랜잭션을 다시 확인하고 싶다면 <Link href="https://blockstream.info/tx/ff9148605a772a51cba39004df5fb042d40515967a3e38ff5294cfd017c452a9?expand" className="underline">여기</Link>를 클릭하세요.`,
      terminal_challenge_success: `정답이에요! 잘하셨습니다. \n\n 그 주소가 다음 장소로 이어지는 열쇠예요. 지금 바로 확인해보세요. \n\n 다음 과제가 당신을 기다리고 있습니다.`,
      terminal_challenge_lines: `여기에 명령어를 입력하고 Enter 키를 누르세요...\n\n 명령어: \n echo $scriptPubKeyBytes | xxd -r -p \n\n 이번에는 $scriptPubKeyBytes 변수가 미리 정의되어 있지 않습니다. 이전 과제에서 찾았던 값으로 $scriptPubKeyBytes를 대체해야 합니다.`,
      terminal_challenge_error: `거의 다 됐습니다! 다만, 이번엔 $scriptPubKeyBytes 변수가 자동으로 설정되어 있지 않다는 점을 잊지 마세요.`,
    },

    outro_one: {
      title: `마무리`,
      nav_title: `모험이 당신을 기다립니다`,
      paragraph_one: `당신은 차고로 달려가 아버지의 낡은 버짓콥터(*저가형 헬리콥터)을 타고 좌표를 입력한 뒤 21구역으로 향합니다.`,
      paragraph_two: `당신은 심한 고양이 알레르기가 있어서 홀로그램 고양이 조차 버거울 지경이지만, 홀로캣은 따라옵니다. 따라오지 말라고 해도요… 고양이는 원래 말을 안 듣잖아요?`,
      button_text: `챕터1 완료`,
    },

    outro_two: {
      title: `해내셨군요!`,
      nav_title: `챕터 완료`,
      description: `여기까지 오다니 멋져요! 첫 번째 챕터를 완료하면서 해시와 트랜잭션에 대해 정말 많은 걸 배우셨을 거예요. 기분이 어때요?`,
    },

    end: {
      save: `진행상황 저장`,
      next: `저장하지 않고 계속하기`,
      feedback: `피드백 공유하기`,
    },
    resources: {
      genesis_two: {
        scriptsig_heading: `스크립트 시그(ScriptSig)`,
        scriptsig_paragraph: `'스크립트 시그는 트랜잭션의 입력 부분에 포함되는 스크립트로, 해당 비트코인을 사용할 수 있는 권한이 자신에게 있음을 증명하는 역할을 해요. 일종의 잠금 해제 키처럼 작동하며, 참조된 UTXO를 사용할 수 있다는 증거를 보여줍니다.`,
        block_explorer_heading: `블록 탐색기(Block Explorer)`,
        block_explorer_paragraph: `블록 탐색기(block explorer)는 블록체인 네트워크를 탐색하고 이해하는데 중요한 도구입니다. 블록체인 데이터를 쉽게 확인하고 분석할 수 있도록 도와주는 도구입니다. 블록 탐색기를 사용하면 거래 내역을 탐색하고, 계좌 잔액을 확인하고, 개별 블록과 거래 진행상황을 추적할 수 있습니다.`,
        tip: `블록 내 트랜잭션에 자세히 버튼을 누른 뒤, 코인베이스 입력 안에서 scriptSig(Hex) 항목을 찾아보세요.`,
      },
      genesis_three: {
        bash_heading: `Bash 명령어(Bash Commands)`,
        bash_paragraph: `우리는 사토시가 제네시스 블록에 압축하여 숨겨진 비밀 메시지를 원래 상태로 되돌리기 위해 간단한 bash 명령어와 옵션을 사용하고 있습니다.`,
        tip: `xxd’ 명령어는 파일을 16진수(hex)로 변환하며, '-r' 옵션은 이를 다시 텍스트로 되돌릴 수 있게 해줘요. '-p' 옵션은 변환된 내용을 콘솔에 깔끔하게 출력해줍니다.`,
      },
      transacting_two: {
        transactions_heading: `트랜잭션`,
        transactions_paragraph: `암호화폐 세계에서 트랜잭션은 하나의 독립적인 결제 단위입니다. 이는 기존에 가진 코인을 사용해 새로운 수신자에게 전송하는 과정을 말합니다. 예를 들어 누군가 암호화폐 트랜잭션을 시작하면 특정 수량의 코인을 다른 지갑에 전송하도록 블록체인에 지시하는 것과 같게 됩니다. 트랜잭션은 보내는 사람이 갖고 있던 코인을 사용하여 수신자에게 새로운 코인을 생성하게 하고, 그리고 이 모든 과정은 블록체인 거래장부에 기록됩니다.`,
        bitcoin_script_heading: `비트코인 스크립트(Bitcoin Script)`,
        bitcoin_script_paragraph: `비트코인 스크립트(Bitcoin Script)는 비트코인 거래에서 사용되는 간단한 스택 기반 프로그래밍 언어입니다. 다양한 연산 코드(opcode)를 통해 스크립트 내부 데이터에 어떤 연산을 수행할지 정의합니다.`,
        tip: `Op_Code가 OP_Pushbytes_33일 경우, 트랜잭션의 OP_RETURN에 이어 나오는 33바이트(총 66자)의 문자열을 찾아보세요.`,
      },
      transacting_three: {
        secrets_heading: `비트코인의 비밀들`,
        secrets_paragraph: `이전 도전과제에서 우리가 살펴본 것처럼, 비트코인 스크립트 안에 비밀 메시지를 숨기는 것은 제네시스 블록 때부터 이어져왔습니다. 비트코인 블록체인 안에 단순히 정보를 저장하는 것부터, 비트코인 외부로 어떤 가치를 전달하기 위해서든, 메시지를 전하기 위해서든, 사람들은 초기부터 단순한 입력과 출력 외에도 다양한 정보들을 블록체인에 기록해왔습니다.`,
        tip: `'xxd' 명령어로 문자열을 해독할 때는 변수를 사용하지 않습니다. 전체 문자열을 직접 입력해야 해요.`,
      },
    },
  },

  chapter_two: {
    title: `해시 계획 수립`,
    paragraph_one: `사토시가 알려준 좌표에 도착했어요. 예상대로, 그곳은 낡고 으스스한 창고였죠.`,
    paragraph_two: ` 당신은 아버지의 낡은 버짓콥터를 타고 그 창고 주위를 세바퀴나 돌며 고민합니다. 당신은 깊게 한숨을 쉬고, 결국 안으로 들어가기로 결심합니다. 버짓콥터의 열 감지기로 확인해봐도, 어둠 외에는 아무것도 감지되지 않습니다. 이 장소는 오랫동안 아무도 찾아오지 않은걸로 보입니다.`,

    intro_one: {
      title: `들어가며`,
      nav_title: `창고`,
      paragraph_one: `—홀로캣: “여기 완전 쓰레기장이잖아. 멸치라도 있었으면 좋겠는데. 사이버키블(*홀로캣이 먹는 사이버 간식)이면 더 좋고."`,
      paragraph_two: `당신은 착륙 후 몸을 가다듬고 안에 들어갈 방법을 찾아봅니다. 그러던 중 깨진 창문을 발견합니다. 남아 있는 유리 조각을 조심스레 치우고, 창문을 통해 안으로 넘어갑니다. 건물 안엔 먼지투성이지만, 잘 정돈된 비트코인 채굴기 수천 대가 가득 차 있습니다.`,
      paragraph_three: {
        a: `—홀로캣: “이건 창고가 아니라 완전 박물관 같은데? 이건 아마 반더풀 가문이 사용했던 옛날 채굴기들 같아. 비트코인이 처음 나왔을 때는 일반 컴퓨터로 채굴 했거든. 하지만 시간이 흐르자, 채굴자들은 특별한 칩을 사용한 기계가 더 효율적이라는 걸 깨달았어. 그 칩이 바로 주문형 반도체인 ASIC 이야.`,
        b: ` 그 칩이 하는일은 비트코인 채굴 하나 뿐이야. 오직 한 가지 일만 하다 보니, 효율도 높고 에너지도 적게 들지. 덕분에 채굴 경쟁력도 생겼고. 믿기진 않겠지만 예전엔 노트북으로도 채굴을 했었으니까."`,
      },
      paragraph_four: `이제 반더풀 가문이 남긴 이 오래된 채굴기들의 정체가 확실해졌습니다.`,
      tooltip_one: {
        question: `ASIC 채굴기란?`,
        link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=What%2520is%2520an%2520ASIC%2520miner%253F`,
        highlighted: `ASIC`,
      },
    },

    intro_two: {
      title: `계획을 세우다`,
      nav_title: `컴퓨터 켜기`,
      paragraph_one: `구석에는 희미하게 깜빡이는 컴퓨터 모니터가 하나 놓여있습니다. 모니터에는 '전원부터 켜, 멍청아'라는 메모가 붙어 있습니다.`,
      paragraph_two: `—홀로캣: “멍청이라니 무례하긴. 와 이거 기계식 키보드잖아. 들어만 봤지 보는 건 처음이야. 소음이 심해서 청력 보호법 때문에 금지됐다던데?”`,
      paragraph_three: `홀로캣은 키보드를 톡톡 걸으며, 눌러야 할 키를 가리킵니다.`,
    },

    hashing_one: {
      title: `수많은 0들`,
      nav_title: `컴퓨터가 윙 소리를 내며 켜진다`,
      paragraph_one: `우연인지 아니면 홀로캣이 진짜 뭔가 알고 있는건지, 홀로캣이 건드린 이상한 글자들이, 다른 난해한 문자열로 바뀝니다.`,
      list_one: `> QX23Y6VGECTUKSNIEUTUB[P[pihof`,
      list_two: `> 1c31d1d9fb848a505fc0cdbea848ff1bdd46a9ed4d639d413d3a93035194eedf`,
      paragraph_two: `모니터에는 '잘못된 해시입니다. 다시 시도하세요.'라는 문구가 표시됩니다.`,
      paragraph_three: `당연히 홀로캣이 입력한 엉터리 암호가 맞을리 없습니다. 그녀는 그냥 건방진 홀로그램 고양이일 뿐이니까요.`,
      paragraph_four: `다르게 입력한다면 무슨 일이 일어날까요?`,
    },

    hashing_two: {
      title: `수많은 0들`,
      nav_title: `직접 해시해보기`,
      heading: `아무거나 입력하세요`,
      return_hash: `아래에는 입력한 내용이 아래에 해시 값으로 변환되어 표시됩니다.`,
      progress_message: `계속 진행하세요...`,
      success_message: `잘했어요. 그럼 다음으로 넘어가볼게요.`,
    },

    hashing_three: {
      title: `수많은 0들`,
      nav_title: `SHA256의 위력`,
      heading: `해시에서 뭔가 특별한 걸 발견하셨나요?`,
      list_one: `해시는 사람의 지문처럼 고유해요. 아주 드물게 예외가 있을 수 있지만, 일반적으로 서로 다른 데이터는 절대 같은 해시 값을 가질 수 없어요.`,
      list_two: `해시 함수는 단방향입니다. 한 번 해시된 값은 거꾸로 계산해서 원래 데이터를 알아낼 수 없어요.`,
      list_three: `해시는 같은 입력값이면 어떤 상황에서도 항상 같은 결과를 만들어내요. 그래서 신뢰할 수 있죠. 즉, 같은 데이터를 반복해서 해싱해도 항상 동일한 결과가 나옵니다.`,
      paragraph_one: {
        a: `여기서 사용된 해시 함수는 바로 `,
        b: `이에요. 보안성과 효율성 덕분에 전 세계적으로 널리 쓰이고 있죠.`,
      },
      paragraph_two: `이제 특정 해시를 찾아봅시다`,
      paragraph_three: `0으로 시작하는 해시 값을 찾아보세요. 원하는 결과가 나올 때까지 계속 시도해보면 돼요!`,
      tooltip_one: {
        question: `SHA-256는 비트코인에서 어떻게 쓰일까? `,
        link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=how%2520is%2520SHA-256%2520used%2520in%2520bitcoin%253F`,
        highlighted: `SHA-256`,
      },
    },

    hashing_four: {
      title: `수많은 0들`,
      nav_title: `0으로 시작하는 해시 찾기`,
      heading: `0으로 시작하는 해시가 나올 때까지 계속 입력해보세요`,
      hint_prompt: `<Tooltip id="hint_prompt" position="bottom" theme="bg-[#5e212a]" offset="-1" content="chapter_two.hashing_four.hint_tooltip">힌트</Tooltip>가 필요한가요?`,
      hint_tooltip: `<span className="text-m whitespace-nowrap leading-none text-white/50">다음과 같이 적어보세요:</span> <span className="whitespace-nowrap text-white">popcorn</span>`,
    },

    hashing_five: {
      title: `수많은 0들`,
      nav_title: `강도 높이기`,
      heading: `그렇게 어렵진 않았죠?`,
      paragraph_one: `이번에는 난이도를 조금 높여볼게요. 두 개의 0으로 시작하는 해시를 찾아보세요.`,
    },

    hashing_six: {
      title: `수많은 0들`,
      nav_title: `두 개의 0으로 시작하는 해시 찾기`,
      heading: `0이 두 개로 시작하는 해시가 나올 때까지 계속 입력해보세요.`,
      hint_prompt: `<Tooltip id="hint_prompt" position="bottom" theme="bg-[#5e212a]" offset="-1" content="chapter_two.hashing_six.hint_tooltip">힌트</Tooltip>가 필요한가요?`,
      hint_tooltip: `<span className="text-m whitespace-nowrap leading-none text-white/50">다음과 같이 적어보세요:</span> <span className="whitespace-nowrap text-white">trigonometry</span>`,
    },

    scripting_one: {
      title: `자동화`,
      nav_title: `논스(Nonce) 해싱하기`,
      heading: `컴퓨터가 대신 하도록 해봅시다.`,
      paragraph_one: `직접 해보니 시간이 꽤 걸렸죠? 그런데 앞에 5개, 심지어 10개의 0으로 시작하는 해시를 찾아야 한다면 어떨까요? 이게 바로 채굴자들이 새로운 블록을 제출하려 할때마다 비트코인 네트워크가 채굴자들에게 주는 과제입니다.`,
      paragraph_two: `채굴자들은 블록에 넣고 싶은 모든 정보를 모읍니다. 예를 들어 이전 블록 헤더 해시, 블록에 포함할 거래들의 해시(코인베이스 거래 포함), 시간 정보 등을 모아 무작위 숫자인 논스(Nonce: number used once)와 결합합니다. 논스는 말 그대로 한 번만 사용하는 숫자예요. 이 모든 정보를 해시 함수에 넣어서 "블록 해시"를 생성합니다.`,
      paragraph_three: `비트코인이 처음 나왔을 때 채굴자들은 블록 헤더에 있는 논스 값을 1씩 증가하면서 될 때까지 계속 시도했습니다. 하지만 채굴장비가 점점 발전하면서 채굴 난이도도 함께 올라갔습니다. 나중에는 난이도가 너무 높아져서 아예 32비트 범위 안에선 답을 못 찾는 경우도 생기기 시작했어요.`,
      paragraph_four: `그래서 채굴자들은 블록 안에 들어갈 거래 정보나 시간 값을 바꾸면서, 블록 헤더의 다른 부분들을 수정하기 시작했어요.`,
      paragraph_five: `비트코인 네트워크는 난이도 설정(difficulty setting)이 있으며 특정 개수의 0으로 시작하는 블록해시만을 인정합니다. 이 조건을 '난이도(difficulty)'라고 부르며, 비트코인 네트워크는 매 2016개 블록마다 이 난이도를 자동으로 조정해요.`,
      paragraph_six: `이번엔 00000(0 다섯 개)으로 시작하는 해시를 찾는 스크립트를 직접 작성해볼 거예요.`,
      tooltip_one: {
        question: `목표 난이도(target difficulty)는 무엇인가요?`,
        link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=what%2520is%2520target%2520difficulty%253F`,
        highlighted: `목표 난이도 (target difficulty)`,
      },
    },

    scripting_two: {
      title: `자동화`,
      nav_title: `해시함수 만들기`,
      paragraph_one: `자 이제 직접 코드를 작성하고 실행해봅시다. 앞에 0이 다섯 개로 시작하는 SHA-256 해시를 생성하는 스크립트를 작성해보세요. sha256 함수를 반복해서 호출하고 입력값을 바꿔가며 원하는 해시를 찾아보세요. 반복문에서 숫자를 하나씩 늘려가며 입력값을 바꿔보세요. 이런 숫자를 암호학에선 '논스(Nonce)'라고 부르며, 한 번만 사용하는 특별한 값이에요.`,
      python: {
        paragraph_two: `해시가 0이 다섯 개로 시작하는 논스를 찾으면 그 논스를 함수에서 반환하세요. 이 함수를 만들기 위해 파이썬의 hashlib 라이브러리의 도움을 받을거에요. 다음 자료들도 함수 작성에 도움이 될겁니다:`,
        list_one: `<Link href="https://docs.python.org/3/library/hashlib.html" target="_blank" className="underline">hashlib documentation</Link>`,
        list_two: `<Link href="https://datagy.io/python-sha256/" target="_blank" className="underline">Tutorial python function</Link>`,
      },
      javascript: {
        paragraph_two: `0이 다섯 개로 시작하는 해시를 찾으면, 해당 논스를 함수에서 반환하세요. 이 함수를 만들기 위해 자바스크립트의 crypto 라이브러리의 도움을 받을거예요. 다음 자료들도 함수 작성에 도움이 될 거예요:`,
        list_one: `<Link href="https://www.geeksforgeeks.org/node-js-crypto-createhash-method/" target="_blank" className="underline">crypto documentation</Link>`,
        list_two: `<Link href="https://www.educative.io/answers/what-is-node-cryptocreatehashalgorithm-options" target="_blank" className="underline">Tutorial JavaScript function</Link>`,
      },
    },

    mining_one: {
      title: `채굴 속으로`,
      nav_title: `블록 채굴하기`,
      heading_one: `이제 직접 채굴을 해볼 차례예요!`,
      heading_two: `지금 채굴 중이에요.`,
      heading_three: `정말 잘했어요!`,
      heading_four: `100번째 블록까지 가봅시다.`,
      heading_five: `정말 잘해냈어요!`,
      paragraph_one: `현재 비트코인 네트워크는 앞에 0이 10개 붙은 해시를 가진 블록만 인정해주고 있습니다. 한번 찾아봅시다!`,
      paragraph_two: `이번 시뮬레이션에서는 한 블록마다 3,500개의 트랜잭션이 포함되고 0.061 BTC 보상과 함께 수수료가 주어진다고 가정할게요.`,
      paragraph_two_one: `채굴기를 한번 켜보세요.`,
      paragraph_three: `코드가 반복적으로 해시를 계산하고 있어요.`,
      paragraph_four: `앞에 0이 10개로 시작하는 해시가 나오면, 코드가 자동으로 멈춰요.`,
      paragraph_five: `해시를 계산할 때마다 숫자가 하나씩 올라가는 게 보이나요? 논스 필드는 지금까지 몇 번이나 시도했는지를 보여주는 숫자예요.`,
      paragraph_six: `다음과 같은 논스를 사용해봅시다:`,
      paragraph_seven: `결과 해시값은:`,
      paragraph_eight: `이 해시는 새 블록이 요구하는 0이 열 개로 시작해요. 이제 블록을 몇 개 더 채굴해보겠습니다.`,
      paragraph_eight_one: `채굴기를 다시 켜봅시다.`,
      paragraph_nine: `시간이 좀 걸릴 수 있지만, 블록을 채굴하고 거래를 확인하는 게 얼마나 어려운 일인지 체감할 수 있어요.`,
      paragraph_ten: `저 해시를 계산하는데 정말 많은 컴퓨터 연산 처리 능력이 필요했어요. 논스를 얼마나 많이 시도했는지 한번 보세요. 해시 파워를 키운 게 도움이 됐습니다. ‘해시파워’는 초당 얼마나 많은 해시를 계산할 수 있는지를 의미해요.`,
      paragraph_eleven: `각 블록에 3,500개 트랜잭션이 들어있으니 채굴된 100개 블록에는 35만 건의 트랜잭션이 확인됐다고 볼 수 있습니다.`,
      paragraph_twelve: `채굴한 덕분에 비트코인 보상을 받았어요. 비트코인 네트워크가 각 블록마다 지급하는 비트코인 블록 보상과 거래 수수료를 함께 받았어요.`,
      paragraph_thirteen: `시뮬레이션에서는 금방 끝났지만, 실제로는 한 블록을 채굴하는 데 평균 10분이 걸려요.`,
      paragraph_fourteen: `실제 메인넷에서는 이 블록을 채굴하려면 훨씬 더 강력한 연산 능력이 필요해요.`,
      progress_bar_title: `찾은 블록수`,
      progress_bar_one: `논스(Nonce)`,
      progress_bar_two: `초당 해시 수`,
      progress_bar_three: `확인된 트랜잭션 수`,
      progress_bar_four: `획득한 비트코인`,
      button_hash: `해시파워 10배 증가시키기`,
      ten_x_hint: `해시 속도를 높이려면 100x 버튼을 눌러보세요!`,
    },
    outro_one: {
      title: `마무리`,
      nav_title: `챕터 완료`,
      heading: `잘하셨습니다!`,
      paragraph_one: `기계들이 윙윙 소리를 내며 작동합니다. 이제 모든 게 제대로 돌아가는 것 같아요. 낡은 모니터에 지도가 하나 나타나고, 다른 창고들의 위치가 표시됩니다. 그 창고들에는 반더풀 가문이 사용해왔던 오래된 채굴 장비들이 가득 차 있고, 방금 막 전원이 켜진 듯 보입니다. 당신이 방금 채굴 도전과제를 완료하면서 활성화된 듯하네요.`,
      paragraph_two: `—홀로캣: “저기봐! 메시지가 있어.”`,
      paragraph_three: `“잘했어. 덕분에 비트코인이 다시 10분마다 한 블록씩 채굴 될거야.” – 사토시 나카모토`,
      paragraph_four: `또 그 사람인가?`,
    },
    resources: {
      hashing_two: {
        hash_functions_heading: `해시 함수`,
        hash_functions_paragraph: `해시 함수는 다양한 길이의 데이터를 일정한 길이의 값으로 변환하는 함수예요. 같은 입력에는 항상 동일한 해시 값이 나오지만, 입력이 조금만 달라져도 완전히 다른 해시가 생성됩니다. 이 특성 덕에 데이터의 무결성을 확인하거나 비트코인 채굴과정에 사용됩니다.`,
        tip: `계속 입력해보세요. SHA-256 알고리즘 덕에 입력값이 비슷하더라도 새로운 입력값을 넣으면 완전히 다른 무작위 해시로 변환됩니다.`,
        spoiler: `8글자를 입력해보세요`,
      },
      hashing_four: {
        power_of_random_heading: `무작위의 힘(The Power of Random)`,
        power_of_random_paragraph: `SHA-256 해시 함수는 새로운 데이터가 추가될 때마다 완전히 다른 무작위 해시를 생성합니다. 예를 들어 소설 "War and Peace"를 해시한 다음, 원본 텍스트에 단 한 글자만 추가해도 완전히 다른 해시 값이 나옵니다. 16진수 체계에서는 총 16개의 문자(0-9와 a-f)가 있습니다. 그렇다면 0으로 시작하는 해시를 찾을 확률은 얼마나 될까요?`,
        tip: `계산 한번 해봅시다. 각 자리마다 16개의 가능한 문자가 있다고 할 때 '00'으로 시작하는 해시를 찾을 확률은 얼마나 될까요? 그렇다면 '000'으로 시작하는 해시를 찾을 확률은요?`,
        spoiler: `s로 시작하는 단어를 한번 시도해봅시다.`,
      },
      hashing_six: {
        collision_resistance_heading: `SHA256과 충돌 저항성`,
        collision_resistance_paragraph: `SHA-256은 256비트(64자)의 해시 값을 생성하며, 이는 입력 데이터를 고유하게 표현한 값입니다. 이 해시 함수는 '머클-댐가드 구조(Merkle–Damgård construction)'를 기반으로 한 계열에 속합니다. 머클-댐가드 구조는 간단한 압축 함수를 사용해 해시 함수를 만드는 방법입니다. 이 구조에서는 입력 메시지를 고정 크기의 블록으로 나눈 다음 각 블록의 출력을 이전 블록의 결과와 결합하여 순차적으로 처리합니다. 이 과정을 전체 메시지가 처리될 때까지 반복하여 최종 해시값을 만들어냅니다. SHA-256의 강력한 보안성과 충돌 저항성은 현대 암호학에서 데이터 무결성과 인증의 핵심 요소로 작용합니다.`,
        tip: `이번 과제에서는 별 다른 힌트가 주어지지 않습니다. Saving Satoshi를 진행하는 동안 점점 더 스스로 문제를 해결해보세요!`,
        spoiler: `새 문자를 하나만 추가해도 완전히 다른 해시가 나온다는 걸 기억하세요. '00'으로 시작하는 해시를 찾을 때까지 계속 문자를 추가해보세요. 아니면 'trigonometry'라는 단어를 시도해보세요.`,
      },
      scripting_one: {
        hash_libraries_heading: `해시 함수`,
        hash_libraries_paragraph: `Node.js의 crypto와 파이썬의 hashlib은 우리가 사용할 알고리즘을 쉽게 다룰 수 있게 해주는 라이브러리입니다. 이 라이브러리들은 많은 사람들이 중요한 시스템을 안전하게 보호하기 위해 사용하는 만큼 정확성과 보안을 보장하도록 철저히 검증되었습니다.`,
        nonce_heading: `논스`,
        nonce_paragraph: `논스는 한 번만 사용하는 숫자(Number Used Once)의 줄임말입니다. 주로 암호화나 컴퓨터 연산에서 사용되는 무작위 또는 반무작위(semi-random) 숫자입니다. 논스는 특정 연산을 반복하거나 결과를 예측하기 어렵게 만듭니다. 비트코인 채굴에서도 중요한 보안 요소입니다. 이 부분은 나중에 더 자세히 알아보겠습니다.`,
        tip_one: `입력 값을 제대로 디코딩(decoding)하고 있는지 확인하세요. 해시 알고리즘은 해시 값을 바이트(Byte) 형태로 디코딩하여 출력합니다. 하지만 우리가 해석할 수 있는 16진수(HEX) 형식이 필요합니다.`,
        tip_two: `어떤 값을 구하려고 할 때, 값이 나올 때까지 반복 실행되는 함수를 만든다고 생각해보세요.`,
        tip_three: `정답을 출력할 때는 <span className="p-1 font-mono bg-[#0000004D] m-1">console.log()</span>나 <span className="p-1 font-mono bg-[#0000004D] m-1">print()</span>를 써야 합니다. 그래야 IDE가 답을 확인할 수 있습니다.`,
      },
      mining_one: {
        mining_heading: `채굴`,
        mining_paragraph: `채굴은 지금까지 배운 개념들이 모두 합쳐져 이루어지는 과정입니다. 비트코인 채굴은 새로운 비트코인을 만들고 거래를 블록체인에 추가하는 과정입니다. 채굴자들은 각 블록의 거래 안에서 고유하고 유효한 논스를 찾아 복잡한 수학 퍼즐을 해결하기 위해 경쟁합니다. 이 작업 증명(Proof-of-Work) 과정은 상당한 연산 능력과 에너지가 필요하기 때문에 안전하면서 탈중앙화된 방식으로 거래를 검증할 수 있습니다. 채굴에 성공한 사람은 새로 발행된 비트코인과 거래 수수료를 보상으로 받을 수 있습니다. 또한 비트코인 네트워크의 무결성을 유지하는 중요한 역할을 수행합니다.`,
        difficulty_heading: `난이도`,
        difficulty_paragraph: `채굴 난이도는 블록이 평균 10분 간격으로 생성되도록 조절돼요.`,
        spoiler: `힌트는 없습니다! 이번 수업을 쭉 복습해보세요. 앞으로 채굴 지식을 뽐낼 기회가 더 많이 생길 거예요.`,
      },
    },
  },
  chapter_three: {
    title: `51% 공격`,
    paragraph_one: `Block explorer에 주소를 입력해보니, 블록이 다시 10분 간격으로 정상 채굴되고 있는 게 보입니다. 홀로캣은 시끄러운 ASIC 기계들 사이에서도 곤히 잠을 자고 있습니다.`,
    paragraph_two: `역시 고양이는 고양이일 뿐이죠.`,
    paragraph_three: `그런데 뭔가 이상합니다. 블록들은 비어있고 거래는 처리되지 않고 있습니다. 당신은 "내가 실수한 걸까? 아니면 그냥 우연일까?" 의문을 갖습니다. 그때 컴퓨터 화면에 또 다른 메시지가 나타나고 그 소리에 홀로캣이 잠에서 깹니다.`,
    paragraph_four: `"이건 우연이 아니야."`,

    intro_one: {
      title: `들어가며`,
      nav_title: `계획 세우기`,
      paragraph_one: `—사토시 나카모토: “야! 맞아, 너 말이야! 지금 비트코인이 51% 공격을 당하고 있어. 너가 채굴장비를 켜고난 뒤 반더풀이 다시 BitRey의 ASIC을 켜서 빈 블록을 채굴하고 있어. 그 장비만 문제가 아니야. 반더풀은 표준 ASIC 펌웨어에 숨겨진 백도어를 이용해서 기존 채굴기에 바이러스를 심었어. 이 바이러스 때문에 채굴기에 빈블록만 채굴되고 있어. 반더풀이 비트코인 생태계를 인질로 삼아서 비트코인 발행량을 늘리자고 협박하는 중이야. 뭐라도 빨리해봐, 멍청아!”`,
      paragraph_two: `낡은 컴퓨터가 먼지를 내뿜더니 스프레드시트라는 자료 파일을 출력합니다. 이 스프레드시트에는 비트코인 채굴자들의 연락처와 바이러스 패치 파일이 들어있습니다. 패치를 빠르게 전달할수록, 더 많은 채굴자들이 BitRey에 맞서 싸우는 데 빨리 참여할 수 있어요.`,
      paragraph_three: `—홀로캣: “우리 아직 할 일이 더 남았어! 아, 우리가 아니라 '너'가 할 일이지만. 나는 벽이나 뚫고 들어가서 쥐나 놀래켜야겠다~”`,
    },

    solo_one: {
      title: `당신 vs BitRey`,
      nav_title: `혼자 채굴하기`,
      step_zero_heading: `당신 혼자 한번 해봅시다`,
      step_zero_paragraph_one: `다른 채굴자들에게 연락한 후, 기다리는 동안 당신은 혼자서 BitRey를 물리칠 수 있을지 시도해보기로 합니다. 다른사람 도움 없이도 혼자 빈블록 문제를 해결할 수 있을지도 모르죠. 여기 당신의 해시 속도(해시레이트)가 나와 있어요. 이 정도면 가능할 것 같나요?`,
      step_one_heading: `이제 경주 시작입니다`,
      step_one_paragraph_one: `지금부터 100개의 블록을 채굴해서 BitRey에 맞서 얼마나 버틸 수 있는지 확인해봅시다.`,
      step_two_heading: `잘 안됐네요!`,
      step_two_paragraph_one: `아쉽네요... BitRey와 감염된 채굴 장비들과 경쟁하기엔 우리 해시 파워가 너무 부족했어요. 다른 채굴자들과 힘을 합쳐 다음 100개의 블록에서 BitRey를 물리칠 수 있을지 한번 시도해봅시다. 비트코인은 한 세기가 넘도록 운영되어 왔습니다. 이렇게 쉽게 무너지지 않을겁니다!`,
    },

    pool_one: {
      title: `풀(Pool) vs BitRey`,
      nav_title: `친구 찾기`,
      waiting_screen_heading: `우리는 도움이 필요합니다!`,
      waiting_screen_paragraph_one: `창고에 있는 당신의 채굴기만으로는 이기기 어려워요. 다른 채굴자들과 힘을 합쳐 해시파워를 높인다면 BitRey의 공격에 맞서 싸울 수 있을지도 모릅니다.`,
      waiting_screen_paragraph_two: `다른 채굴자들이 합류할 때까지 기다려봐요. 함께 힘을 모아야 해요.`,
      waiting_button: `기다리는 중...`,
      continue_button: `출발합시다`,
    },

    pool_two: {
      title: `채굴 풀 vs. BitRey`,
      nav_title: `함께 채굴하기`,
      step_zero_heading: `함께 시작해봅시다!`,
      step_zero_paragraph_one: `다른 채굴자들과 해시 파워를 합치면 BitRey에 맞설 수 있을까요?`,
      step_two_heading: `또 졌습니다!`,
      step_two_paragraph_one: `뭔가 이상합니다. Hashrate Hoppers만 블록을 채굴했어요. 왜 이런 일이 생긴걸까요?`,
    },

    coop_one: {
      title: `협동팀 vs. BitRey`,
      nav_title: `무언가 잘못되었다.`,
      heading: `무언가 아직도 이상합니다.`,
      paragraph_one: `가장 강한 해시파워를 가진 Hashrate Hoppers만 블록을 발견하고 있고 다른 채굴자들은 아무런 성과도 내지 못하고 있어요.`,
      paragraph_two: `모든 채굴자들이 같은 논스를 사용하고 있는 게 문제예요. 어떻게 해야 좀 더 효율적일까요?`,
      paragraph_three: `같은 작업을 반복하지 않도록, 블록 데이터마다 'extraNonce'에 고유한 식별 값을 넣기로 했어요.`,
    },

    coop_two: {
      title: `협동팀 vs. BitRey`,
      nav_title: `extraNonce`,
      heading: `extraNonce란 무엇인가?`,
      paragraph_one: `Stratum 채굴 풀 프로토콜(비트코인 자체 프로토콜 외 프로토콜)에서는 코인베이스 트랜잭션에도 'extraNonce'라는 값이 포함됩니다. 채굴 풀은 채굴자들에게 블록 데이터를 제공할 때 extra Nonce를 "extranonce1", "extranonce2" 처럼 두 부분으로 나눠 전달합니다.`,
      paragraph_two: `extraNonce를 두 부분으로 나누면 여러 가지 장점이 있습니다:`,
      list_one: `채굴풀에 참여한 사람들이 서로 똑같은 작업을 반복하지 않게 막아줍니다.`,
      list_two: `채굴 풀은 모든 채굴자에게 동일한 거래 목록을 보낼 수 있습니다. 그렇게 하면 채굴자들은 블록에 포함된 거래들을 건드릴 필요 없이 'extranonce2' 값만 바꾸면 됩니다.`,
      list_three: `'extranonce1'은 각 채굴자에게 각자만의 값으로 할당되기 때문에 누가 얼마나 기여했는지를 확인할 수 있습니다.`,
      paragraph_three: `채굴자들은 'extranonce2' 값을 바꾸고, 블록 헤더 안의 논스를 반복해서 변경하며 해시값을 찾기 위해 계속 계산합니다. 답을 못 찾으면 'extranonce2' 값을 다시 바꿔가며 해시값을 찾으려 시도합니다.`,
      paragraph_four: `이 방법으로 작업을 나눠서 다시 시도해봅시다.`,
    },

    coop_three: {
      title: `협동팀 vs. BitRey`,
      nav_title: `팀원들과 함께 채굴하기`,
      step_zero_heading: `한번만 더...`,
      step_zero_paragraph_one: `논스 영역을 나눠서 작업하면 BitRey를 이길 수 있을지 한번 봅시다.`,
      step_two_heading: `해내셨습니다!`,
      step_two_paragraph_one: `당신과 다른 채굴자들이 힘을 합쳐 BitRey가 네트워크를 장악하려는 걸 막아냈습니다!`,
    },

    split_one: {
      title: `보상 나누기`,
      nav_title: `채굴 보상을 공평하게 나누기`,
      heading: `수고 많으셨습니다.`,
      paragraph_one: `당신은 BitRey의 공격도 막아내고 보상으로 비트코인도 받았습니다!`,
      paragraph_two: `블록 하나가 채굴될 때마다, 채굴자는 비트코인을 보상으로 받습니다. 하지만 여러 사람이 함께 채굴했다면 채굴풀이 그 보상을 나눠 갖습니다.`,
      paragraph_three: `이 보상은 두 가지로 구성됩니다:`,
      list_one: `블록 안에 포함된 모든 거래에서 발생한 수수료`,
      list_two: `블록 보조금(새로 생성된 비트코인)`,
      paragraph_four: `다른 채굴자들과 함께 총 7.41 BTC를 받았어요. 이제 이걸 어떻게 나눌지 고민 중이에요. 각자의 기여도에 따라 공정하게 분배하는 게 좋겠죠.`,
      paragraph_five: `채굴풀은 각 채굴자가 찾아낸 '셰어 제출 결과(Partial Solution)'의 수를 바탕으로 보상을 나눠요. 풀은 해시파워에 따라 각 채굴자에게 블록 난이도보다 낮은 최소 난이도를 부여합니다. 채굴자는 몇 초마다 이 낮은 난이도의 해시를 찾아내고 풀에 보고하고, 풀은 제출된 모든 쉐어를 기준으로 보상을 나눠줍니다.`,
      paragraph_six: `직접 작동 과정을 살펴봅시다.`,
    },

    split_two: {
      title: `보상 나누기`,
      nav_title: `보상 계산하기`,
      step_zero_heading: `모두 얼마나 노력했는지 확인해봅시다.`,
      step_zero_paragraph: `다시 시뮬레이션을 시행해봅시다. 채굴풀 안에서 각 채굴자가 찾은 셰어 제출 결과의 개수에만 집중해보세요.`,
      step_two_heading: `계산해봅시다.`,
      step_two_paragraph: `위에 나온 숫자들을 보고 보상을 공정하게 나눌 방법을 생각해봅시다. 생각나셨나요? 그럼 이제 함께 차근차근 계산해볼까요?`,
      step_three_heading: `해시레이트(Hash rate) 비율`,
      step_three_paragraph: `이 수치는 각 채굴자가 블록을 찾기 위해 얼마나 노력했는지 보여줍니다. 하지만 채굴풀은 채굴자가 "성공한 결과"만 보기 때문에 정확한 작업량을 확인하거나 측정할 수 없습니다.`,
      step_four_heading: `발견된 블록(Blocks found) 비율`,
      step_four_paragraph: `블록을 발견할 확률은 매우 낮고, 어느 정도 운이 따라줘야 합니다. 특히 해시파워가 아주 강력한 채굴자들이 있다면 해시파워가 작은 채굴자들이 열심히 해도 블록을 하나도 못 찾을 수 있습니다.`,
      step_five_heading: `셰어 제출 결과(Partial solution) 비율`,
      step_five_paragraph: `이 수치는 실제로 공정한 분배에 큰 도움이 됩니다. 채굴자들은 난이도가 낮은 문제의 정답을 꾸준히 채굴풀에 보고하기 때문입니다. 덕분에 채굴 풀은 각 채굴자가 얼마나 일했는지 정확히 측정할 수 있습니다.`,
      step_six_heading: `보상 나누기`,
      step_six_paragraph: `이제 7.41개의 비트코인 보상을 각 채굴자가 제출한 셰어 제출 결과의 제출 비율에 따라 공평하게 나눌 수 있어요. 축하합니다!`,
    },

    outro_one: {
      title: `마무리`,
      nav_title: `챕터 완료`,
      heading: `이걸로 끝장이다, 반더풀!`,
      paragraph_one: `대단해요! 당신과 채굴자들이 힘을 모아 반더풀의 51% 공격을 막아냈습니다. 이제 빈 블록도 더 이상 생기지 않고, 반더풀도 물러난 것 같네요.`,
      paragraph_two: `이제 보상을 챙길 시간입니다. 다음 챕터로 넘어가서 비트코인을 인출해봅시다!`,
    },
    resources: {
      solo: {
        hashrate_heading: `채굴 해시레이트`,
        hashrate_paragraph: `채굴자의 해시레이트는 그 사람이 비트코인 네트워크에 제공하는 컴퓨터 연산 능력을 뜻합니다. 이 연산 능력은 블록을 채굴하기 위해 필요한 수학 계산을 얼마나 빠르게 수행하는지 보여줍니다. 보통 해시레이트는 초당 몇 번의 계산을 할 수 있는지 나타냅니다. 규모가 크면 테라해시(TH/s), 즉 1초에 1조 번의 계산으로 표현되기도 합니다.`,
      },
      pool: {
        pool_heading: `채굴 풀`,
        pool_paragraph: `채굴풀은 개인 채굴자들에게 다양한 혜택을 제공하며 암호화폐 채굴에서 중요한 역할을 합니다. 여러 채굴자들이 연산능력을 모아 함께 채굴할 수 있도록 도와주는 시스템입니다. 많은 사람들이 힘을 합치면 블록을 성공적으로 채굴할 확률이 높아지며 보상도 더 예측 가능해지고 안정적으로 받을 수 있게 됩니다. 또한 몇몇 채굴풀은 전문 장비나 기술을 제공해 누구나 쉽게 참여할 수 있도록 설계되어 있습니다. 기여한 만큼 보상을 공정하게 나눠주기 때문에 채굴풀은 더 많은 사람에게 안정적이며 가치있는 기회를 제공해줍니다.`,
      },
      coop: {
        distribution_heading: `작업 분배`,
        distribution_paragraph: `채굴풀은 같은 블록 참가자들이 동일한 논스를 채굴하지 않도록 유의해서 작업을 나눠줍니다. 채굴에서는 누구보다 먼저 유효한 논스를 찾는 것이 가장 중요하기 때문입니다. 같은 풀에 있는 두 채굴자가 동시에 같은 논스를 계산하면 효율이 떨어지고 한명 밖에 보상을 받지 못합니다. 이런 비효율성을 막기 위해 채굴풀은 '작업 할당' 또는 '작업 분배'를 합니다. 채굴풀은 각 채굴자에게 고유한 작업을 만들어 보내줍니다. 이 작업에는 블록을 채굴하는 데 필요한 정보들이 들어 있습니다. 예를 들어 미확인 거래 목록, 이전 블록의 헤더, 그리고 목표 난이도 등이 있습니다.`,
        shares_heading: `쉐어(Shares) 제출`,
        shares_paragraph: `채굴자들은 할당된 작업을 진행하며 계속 유효한 논스를 찾으려 시도합니다. 어떤 해답이 유효하다고 판단되면 '쉐어(share)'라는 결과를 풀 서버에 제출합니다. 쉐어는 채굴자가 문제를 열심히 풀고 있다는 증거가 됩니다. 쉐어는 실제 블록을 완전히 채굴하는 것보다 훨씬 쉽게 찾을 수 있지만, 노력의 증거로 인정받을 수 있습니다.`,
      },
      split: {
        payout_heading: `보상 분배 방식`,
        payout_subheading: `채굴 풀은 블록 보상 방법을 여러 방식으로 나눌 수 있습니다. 방식마다 비슷해보이지만 차이가 있습니다:`,
        pps_heading: `PPS 방식 (Pay-Per-Share)`,
        pps_paragraph: `PPS는 쉐어당 지급 방식입니다. PPS 방식은 채굴자가 유효한 쉐어(share)를 제출할 때마다 실제로 블록을 채굴했는지와 상관없이 고정된 보상을 받습니다. 이 방식은 수입이 꾸준하고 예측 가능해서 안정적인 수익을 원하는 채굴자들에게 인기가 많습니다. 하지만 만약 풀이 일정 시간동안 블록을 찾지 못한다면 운영 비용과 위험 부담을 줄이기 위해 일부 수수료가 차감될 수도 있습니다. 전통적인 PPS에서는 풀 상황이 어려워질 경우 보상이 줄어들기도 합니다.`,
        pplns_heading: `PPLNS 방식 (Pay-Per-Last-N-Shares)`,
        pplns_paragraph: `PPLNS는 마지막 N개의 쉐어를 기준으로 채굴자의 기여도를 계산해 보상을 지급하는 방식입니다. 이 방식은 꾸준히 활동한 채굴자에게 더 유리하고, 풀을 자주 옮기는 전략(pool-hopping)을 방지하는 데 도움이 됩니다. 보상은 풀에서 블록을 성공적으로 채굴했을 때에만 지급되며, 최근 기여도에 따라 공정하게 나뉩니다.`,
        pps_plus_heading: `PPS+ 방식 (Pay Per Share +)`,
        pps_plus_paragraph: `PPS+는 PPS처럼 유효한 쉐어마다 고정 보상을 지급하며, 추가 인센티브도 포함된 방식입니다. 풀의 안정성에 기여한 채굴자에게는 보너스가 주어져, 꾸준히 참여하는 채굴자에게 더 유리합니다. 안정성과 보상을 함께 원하는 채굴자에게 적합한 방식입니다.`,
        fpps_heading: `FPPS 방식 (Full Pay Per Share)`,
        fpps_paragraph: `FPPS는 유효한 쉐어 1개당 고정된 보상을 지급하는 방식입니다. 풀에서 블록을 실제로 채굴했는지에 상관없이 보상이 지급되며, 채굴자는 언제나 자신이 기여한 만큼의 보상을 받습니다. 안정성과 예측 가능성이 높아 꾸준한 수익을 원하는 채굴자에게 적합한 방식입니다.`,
      },
    },
  },

  chapter_four: {
    title: `1.61 비트코인 받기`,
    paragraph_one: `휴! 아슬아슬했네요. BitRey와의 치열한 싸움에 아직도 손이 떨리지만, 결국 이겼다는 안도감이 밀려옵니다.`,
    paragraph_two: `당신은 책상에 앉아 심호흡을 하며 하루 동안 있었던 일들을 천천히 떠올립니다.`,

    intro_one: {
      title: `들어가며`,
      nav_title: `비트코인 챙기기`,
      paragraph_one: `—홀로캣: "우리 중 한 명은 좀 자야겠어. 너는 다른 채굴자들에게 연락해서 이 사실을 알려. 세상 사람들보다, 그 사람들이 가장 먼저 이 사실을 알고 싶어할걸?”`,
      paragraph_two: `당신은 ButtLift Hover 책상에 앉아 오늘 있었던 일들을 머릿속으로 뒤집어 봅니다. 반더풀, BitRey, 채굴자들의 항의로 비트코인 채굴 종료에 동의한 적 없다는 사실을 떠올립니다. 이게 정말 다 사실일지, 누군가 다 계획한 연극은 아니었을지 혼자 생각합니다. 그리고 이 고양이는 언제까지 돌봐야 하는 건지 고민합니다. (멀리서 야옹 소리가 들립니다.)`,
      paragraph_three: `앞으로 무슨일이 발생하든 돈이 필요할 겁니다. 당신은 BitRey와의 대결에서 얻은 채굴 보상을 아직 수령하지 않았습니다. 당신은 그것부터 먼저 인출하기로 결심합니다.`,
    },

    public_key_one: {
      title: `공개키(Public key)`,
      nav_title: `키 조합(Key pairs)`,
      heading: `키 조합 자세히 알아보기`,
      paragraph_one: `채굴 풀에 따르면, 당신은 이전 작업 덕분에 1.61 BTC를 받을 수 있다고 해요.`,
      list_one: `개인키(Private key)`,
      list_two: `공개키(Public key)`,
      paragraph_two: `잠깐! 당신은 아직 지갑이 없습니다. "지갑은 어디서 사야하지?"라고 생각할 수 있습니다. 일부 종류의 지갑은 별도의 하드웨어를 구입해야할 수도 있지만, 컴퓨터나 핸드폰으로도 지갑을 만들 수 있습니다. 지금 바로 함께 만들어 보겠습니다.`,
      paragraph_three: `가입할 때 '개인 코드'를 받았던 걸 기억하시나요? 이건 암호학에서 '개인키'라고 불리며 보통 한 쌍으로 이루어져 있습니다:`,
      paragraph_four: `지갑을 만들고 자금을 관리하려면, 하나의 키 조합(key pairs)만 있으면 돼요. 비트코인을 보낼 때는 '개인키'를 사용하고, 받을 때는 '공개키'를 사용합니다.`,
    },

    public_key_two: {
      title: `공개키(Public key)`,
      nav_title: `타원 곡선 암호학(Elliptic curve cryptography)`,
      paragraph_one: `우리는 가입할 때 받은 '나만의 비밀 코드'인 개인키를 이미 가지고 있습니다. 그렇다면 이 개인키로 어떻게 공개키를 만들어낼지 알아봅시다.`,
      paragraph_two: `먼저, 조금 낯설 수 있는 수학 개념인 '타원 곡선'을 살펴볼게요. 이 방식을 '타원 곡선 암호학', 줄여서 ECC(Elliptic Curve Cryptography)라고 합니다.`,
      paragraph_three: `ECC는 타원 곡선 위의 특정 점들을 대상으로 연산하는 방식입니다.`,
      paragraph_four: `비트코인은 secp256k1이라는 특정한 타원 곡선을 사용합니다. 이미지에 나오는 곡선은 실제보다 단순화된 버전이지만 수학적 원리는 동일합니다.`,
      paragraph_five: `먼저 '기준점(generator point)'이라고 불리는 곡선 위의 특정 점에서 시작해볼게요.`,
      tooltip_one: {
        highlighted: `기준점`,
        question: `기준점이란?`,
        link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=What%2520is%2520the%2520Generator%2520point%253F`,
      },
    },

    public_key_three: {
      title: `공개키(Public key)`,
      nav_title: `공개키 계산하기`,
      paragraph_one: `개인키에서 공개키를 만들기 위해, 기준점을 이용해 타원 곡선 연산을 반복합니다. 이 기준점은 secp256k1 표준에 정의된 곡선 위의 특정 점이며, 항상 동일한 값을 사용합니다.`,
      paragraph_two: `타원 곡선 연산은 덧셈과 비슷하며, 이를 반복하는 것은 곱셈과 유사합니다. 그래서 알고리즘에서는 * 기호를 사용해 나타냅니다. 여기서 'k'는 개인키, 'P'는 해당 공개키를 의미합니다:`,
      python: {
        paragraph_three: `<span className="text-green">privatekey_to_publickey()</span> 함수를 완성해보세요. 이 함수는 16진수 문자열로 인코딩된 개인키를 받아서 해당 공개키를 GE(Group Element) 객체로 반환합니다.`,
      },
      javascript: {
        paragraph_three: `<span className="text-green">privateKeyToPublicKey()</span> 함수를 완성하세요. 이 함수는 16진수 문자열로 인코딩된 개인키를 받아 해당 공개키를 GE 객체로 반환합니다.`,
      },
      paragraph_four: `타입 변환에 도움이 될 힌트를 몇 가지 알려드릴게요:`,
      success: `잘하셨습니다! 공개키가 제법 기네요. 이제 이걸 압축하는 법을 배워봅시다.`,
    },

    public_key_four: {
      title: `공개키(Public key)`,
      nav_title: `공개키 압축하기`,
      paragraph_one: `공개키는 x좌표와 y좌표로 구성되어 총 64바이트를 차지합니다. 하지만 y좌표를 제거하고 메타데이터 1바이트만 앞에 붙이면 33바이트로 압축할 수 있습니다. 이 메타데이터는 y좌표가 짝수인지 홀수인지 나타냅니다. 타원 곡선은 수학적으로 x와 y의 관계가 정해져 있기 때문에 검증자는 나중에 x값과 메타데이터만으로 전체 공개키를 다시 계산할 수 있습니다:`,
      paragraph_two_javascript: `메타데이터 바이트는 y가 짝수일 때 '2', 홀수일 때는 '3'이어야 합니다. <span className="text-green">compressPublicKey()</span> 함수를 완성하여 공개키를 입력받고, 압축된 33바이트짜리 16진수 문자열로 반환해봅시다.`,
      paragraph_two_python: `메타데이터 바이트는 y가 짝수일 때 '2', 홀수일 때는 '3'이어야 합니다. <span className="text-green">compress_publickey()</span> 함수를 완성하여 공개키를 입력받고, 압축된 33바이트짜리 16진수 문자열로 반환해봅시다.`,
      success: `훌륭합니다. 이제 압축된 공개키가 만들어졌습니다. 다음에는 이 키를 해시하고 사람이 읽기 쉬운 형식으로 인코딩해보겠습니다.`,
    },

    address_one: {
      title: `주소`,
      nav_title: `일방통행`,
      heading: `잘하셨습니다!`,
      paragraph_one: `압축된 공개키가 생겼으니, 이제 지갑 주소를 만들거나 다른 다양한 작업을 할 수 있어요. 다음 도전과제에서 한번 배워보겠습니다.`,
      paragraph_two: `공개키를 만드는 건 '단방향'입니다. 공개키를 안다고 해서 개인키를 거꾸로 알아낼 수는 없기 때문이에요. 그걸 하려면 '이산 로그 문제(discrete log problem)'라는 아주 어려운 수학문제를 풀어야 하거든요.`,
      tooltip_one: {
        question: `이산 로그 문제가 비트코인과 어떤 관련이 있을까?`,
        link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=how%2520is%2520the%2520discrete%2520log%2520problem%2520relevant%2520to%2520bitcoin%253F`,
        highlighted: `이산 로그 문제`,
      },
    },

    address_two: {
      title: `주소`,
      nav_title: `압축된 공개키 해시하기`,
      paragraph_one: `이전의 해시과제에서 배운 방식으로 비트코인 주소를 만들어 보겠습니다. 가장 기본적인 비트코인 주소는 '압축된 공개키'를 해시해서 만들 수 있습니다. 이때 SHA-256과 RIPEMD-160이라는 두 가지 해시 알고리즘을 차례대로 사용할 거예요.`,
      paragraph_two: `만드는 순서:`,
      paragraph_three: `<span className="indent-48">1. 압축된 공개키에 SHA-256 해시를 적용해줍니다.</span>`,
      paragraph_four: `<span className="indent-48">2. SHA-256 결과값에 다시 RIPEMD-160 해시를 적용합니다. 이렇게 두번 해싱하면 최종적으로 20바이트짜리 16진수 문자열이 나옵니다.</span>`,
      paragraph_five: `33바이트 압축 공개키(hex 문자열)를 입력받아, 20바이트짜리 공개키 해시(hex 문자열)로 반환하는 함수를 만들어봅시다.`,
      paragraph_six:
        `해시함수를 쓸 수 있는 문서 링크를 준비했습니다. 참고하세요:\n` +
        '<Link href="https://nodejs.org/api/crypto.html#class-hash" target="_blank" className="underline">JavaScript: crypto</Link>\n' +
        '<Link href="https://docs.python.org/3/library/hashlib.html#usage" target="_blank" className="underline">Python: hashlib</Link>',
      success: `거의 다 됐습니다. 이제 한 단계만 더 거치면 비트코인 지갑 주소가 완성됩니다.`,
    },

    address_three: {
      title: `주소`,
      nav_title: `P2WPKH 주소 만들기`,
      paragraph_one: `비트코인 주소에는 여러가지 종류가 있어요. 이전 단계에서는 20바이트짜리 압축된 공개키 해시를 만들었습니다. 이번에는 그 해시를 Pay-to-Witness-Public-Key-Hash(P2WPKH) 형식으로 바꿔서 테스트넷(Testnet) 주소를 생성해보겠습니다.`,
      paragraph_two: `제일 먼저, 아까 만든 해시 앞에 버전 번호 '0'을 붙여줍니다. 이렇게 만들어진 21바이트 데이터를 <span className="font-bold">witness program</span> 이라고 합니다.`,
      paragraph_three: `이제 witness program을 사람이 읽기 쉬운 형태인 <Link href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#user-content-Specification" target="_blank" className="underline">bech32</Link> 형식으로 인코딩 해줍니다. bech32는 읽기 쉬운 접두어(prefix)와 오류검출용 체크섬(checksum)까지 자동으로 붙여주기에 주소를 안전하게 만들 수 있습니다.`,
      paragraph_four: `bech32 주소의 접두어(prefix)는 네트워크 종류에 따라 달라집니다:`,
      table_heading: {
        item_one: `네트워크(Network)`,
        item_two: `사람이 읽을 수 있는 접두어(Human-Readable Prefix)`,
      },
      table_rows: {
        key_one: `Mainnet`,
        value_one: `bc`,
        key_two: `Testnet`,
        value_two: `tb`,
        key_three: `Regtest`,
        value_three: `bcrt`,
      },
      paragraph_five: `우리는 테스트넷(Testnet) 주소를 만드는 중이니 접두어 'tb'를 사용할 거예요.`,
      paragraph_six: `witness program을 bech32 형식으로 인코딩하면 비트코인 주소가 완성됩니다.`,
      paragraph_seven: `압축된 공개키 해시를 bech32 주소로 바꾸는 함수를 만들어 봅시다. 먼저 witness program을 만들고 미리 임포트된 bech32 라이브러리를 이용해서 주소를 변환하면 됩니다.`,
      paragraph_eight: `어떤 함수를 써야할지 모르겠다면 bech32 라이브러리 코드에서 직접 찾아보면 돼요: \n`,
      paragraph_eight_javascript: `<Link href="https://github.com/saving-satoshi/bech32js/blob/main/bech32.js" target="_blank" className="underline">JavaScript: @savingsatoshi/bech32js</Link>\n`,
      paragraph_eight_python: `<Link href="https://github.com/saving-satoshi/bech32py/blob/main/bech32py/bech32.py" target="_blank" className="underline">Python: savingsatoshi_bech32py</Link>`,
      success: `이제 당신이 만든 주소로 비트코인을 받을 수 있게 됐습니다!`,
    },

    outro_one: {
      title: `마무리`,
      nav_title: `챕터 완료`,
      heading: `성공하셨습니다!`,
      paragraph_one: `직접 만든 비트코인 지갑이 생겼습니다!`,
      paragraph_two: `방금 만든 지갑으로 채굴풀에 쌓아둔 비트코인을 꺼내서 옮겼습니다. 이제 모든 준비는 끝났어요. 반더풀 가문이든 BitRey든, 뭐든 맞설 수 있을 거예요!`,
    },
    resources: {
      public_key_three: {
        generator_point_heading: `기준점(Generator point)`,
        generator_point_paragraph: `secp256k1 곡선 위에 있는 특정한 하나의 점입니다. 이 값은 secp256k1 표준에 포함된 공식적인 값이며 모든 사람이 계산의 출발점으로 사용하기로 약속한 값입니다. 곡선 위의 다른 점들과 특별히 다를 건 없지만, 모두가 기준으로 삼자고 정한 값입니다. 왜 이 점이 기준점으로 선택됐는지는 아무도 몰라요.`,
        elliptic_curve_operations_heading: `타원 곡선 연산(Elliptic curve operations)`,
        elliptic_curve_operations_paragraph: `타원 곡선에는 고유한 수학 규칙이 있어서, 덧셈이나 곱셈 같은 연산이 우리가 아는 방식과는 많이 다릅니다. 간단히 설명하자면, 기존의 기호들-예를 들어 곱셈기호 *-를 비슷한 의미로 재사용하긴 하지만, 실제로는 완전히 다른 연산입니다.`,
        discrete_log_heading: `이산로그(Discrete logarithm)`,
        discrete_log_paragraph: `이산 로그는 곱셈은 가능하지만, 나눗셈이 불가능한 수학 시스템입니다. 시계로 예를 들어 보겠습니다. 11시에 3시간을 더하면 2시가 됩니다. 그러면 11 + 3 = 2 라고 표현할 수 있습니다. 하지만 반대로 2 - x = 11 을 푼다고 하면 답은 무한이 많아집니다: 3, 15, 27, 39, ... 으로 말이죠. 자세히 알고 싶다면 <Link href="https://en.wikipedia.org/wiki/Discrete_logarithm" className="underline">wikipedia</Link> 링크를 참고하시면 됩니다.`,
        tip_one: `타원 곡선 위에서의 곱셈은 우리가 평소에 하는 숫자 곱셈과 완전히 다릅니다. 기준점(generator point)는 실제로 <span className="p-1 font-mono bg-[#0000004D] m-1">G</span> 타입입니다. 이 틀(class) 안에서 어떤 기능(methods)이 있는지 한번 살펴보면 어떻게 곱셈을 할 수 있는지 감이 잡힐겁니다.`,
        tip_two: `개인키는 보통 16진수(hex) 형태로 입력해도 되지만, 기준점과 곱하려면 먼저 숫자(BigInt)으로 바꿔줘야 합니다. JS에서는 BigInt()를 써서 변환할 수 있습니다.`,
      },
      public_key_four: {
        y_coordinate_compression_heading: `공개키 압축`,
        y_coordinate_compression_paragraph: `타원 곡선에서 두 점을 더하면, 그 두 점을 기준으로 곡선 위의 세 번째 점을 구할 수 있습니다. 흥미로운 사실은 대부분 x좌표에는 y좌표가 두 개씩 존재한다는 것입니다. (특별한 예외 상황 제외) 그래서 공개키를 압축할 때는 y값 중 하나만 골라 x좌표와 함께 메타데이터만 붙이는 방식으로 줄입니다. (*메타데이터: 어떤 y값을 골랐는지 알려주는 표시)`,
        tip: `이 과제는 생각보다 간단합니다. 우리는 y좌표가 짝수인지 홀수인지 확인한 뒤, 그 정보를 x좌표 앞에 덧붙이면 됩니다.`,
      },
      address_two: {
        hash_algo_heading: `SHA-256과 RIPEMD-160 해시 알고리즘`,
        hash_algo_paragraph: `해시 함수는 데이터 크기와 상관없이 항상 같은 크기의 출력을 만들어냅니다. SHA256은 32바이트, RIPEMD-160은 20바이트를 출력하죠. 같은 입력에는 항상 같은 결과가 나오지만, 그 외에는 무작위처럼 보입니다. 해시 함수는 데이터를 작고 일정한 ‘지문(fingerprint)’으로 변환해줍니다.`,
        tip_one: `SHA-256 해시를 계산할 때에는 압축된 공개키를 hex 문자열 그대로 쓰지 말고, 바이트(byte) 형태로 변환한 다음 해시해야 합니다. Javascript에서는 hex 문자열을 Buffer로 변환해야 합니다.`,
        tip_two: `해시 알고리즘을 올바른 순서로 적용하고 있는지 확인하세요! SHA-256을 먼저 적용하고, 그 결과에 RIPEMD-160을 이어서 적용해야 정확한 결과가 나와요.`,
      },
      address_three: {
        wpkh_heading: `WPKH(Witness Public Key Hash) 주소`,
        wpkh_paragraph: `비트코인 주소는 사용자들이 쉽게 다룰 수 있게 만들어진 문자열입니다. 복사, 붙여넣기 쉬우면서도 짧습니다. 또한 잘못 입력해도 오류를 잡아주는 체크섬(checksum) 기능도 내장돼 있습니다. 이 문자열은 수신자가 사용할 수 있는 비트코인 스크립트 정보를 안전하게 담고 있어요. 스크립트와 인코딩 방식은 여러가지가 있지만, 이번 과제에서는 압축된 공개키를 bech32 방식으로 인코딩하여 WPKH 주소를 만들어 보겠습니다.`,
        network_heading: `메인넷(Mainnet), 테스트넷(Testnet), 시그넷(Signet), 레그테스트(Regtest)`,
        network_paragraph: `비트코인 소프트웨어를 만들 때는, 돈을 맡기기 전에 반드시 먼저 테스트를 해야 합니다. 가장 간단한 방법은 완전히 별개의 블록체인에서 테스트를 돌리는 것입니다. 이 테스트 체인은: 새로운 제네시스 블록으로 시작하고, 거기있는 코인들은 아무 가치도 없고, 채굴은 공짜이면서 쉽고, 언제든지 초기화할 수 있습니다. 이런 체인들은 메인넷에 영향을 주지 않는 자체적인 노드 네트워크에서 운영됩니다. 대표적으로는 테스트넷(Testnet)과 시그넷(Signet)이 있습니다. 이 둘은 메인넷과 병렬로 전 세계에서 유지되고 있습니다. 또 하나는 레그테스트(Regtest)로, 개발자 혼자서 로컬에서 테스트할 수 있는 모드입니다. 인터넷 연결도 필요없이 내 컴퓨터 하나로만 실행 가능하므로 개발할 때 매우 유용합니다.`,
        tip: `bech32 라이브러리 안에 어떤 함수들을 쓸 수 있는지 잘 확인해보세요. 이 과제에서는 직접 함수 이름들을 하나씩 살펴보는게 매우 중요합니다.`,
      },
    },
  },

  chapter_five: {
    title: `진짜 사토시는 일어나 주세요`,
    paragraph_one: `밤이 늦었습니다. 피곤에 지쳐 눈을 감으려는 찰나, 나쁜 소식이 두 개가 한꺼번에 날아듭니다.`,
    paragraph_two: `1) 반더풀이 다시 TV에 나왔습니다.`,
    paragraph_three: `2) 그가 자신이 사토시 나카모토의 증손자라고 주장하고 있습니다.`,
    paragraph_four: `그의 얼굴은 마치 며칠을 못 잔 듯 초췌해 보입니다.`,
    intro_one: {
      title: `들어가며`,
      nav_title: `믿지 말고, 검증하라`,
      paragraph_one: `—데보라 청크: "반더풀 씨, 얼마 전에 안티소셜미디어에 엄청난 발언을 하셨죠. 자신이 사토시 나카모토의 증손자라고 하셨는데 정말입니까?”`,
      paragraph_two: `—반더풀: "그렇습니다. 정말 오랫동안 가슴 속에 품어온 비밀을 풀게됐네요. 우리 집안은 대대로 허름한 CD-ROM 하나를 몰래 전해 내려왔습니다. 누군가 훔쳐갈 일 없도록 일부러 허름하게 CD에 <span className="italic">Creed – My Own Prison</span>(*20세기 명반 이름) 이라는 가짜 제목까지 붙였죠. 그 CD 안에는 제 증조할아버지 사토시 나카모토의 비트코인 개인키가 들어가있습니다. 이걸로 어마어마한 비트코인을 움직일 수 있죠. 그러니까 제 목소리는 곧, 사토시 나카모토의 목소리인 겁니다. 저는 현재 채굴자들의 의견을 지지합니다.”`,
      paragraph_three: `—데보라 청크: “그렇다면 사토시 나카모토의 개인키를 소유하고 계신다는 걸 증명할 수 있나요?”`,
      paragraph_four: `—반더풀: "물론이죠. 공개키 암호방식으로 아주 간단히 증명할 수 있습니다.”`,
      paragraph_five: `—데보라 청크: "그런데 이렇게 세상을 뒤흔들 폭로를 왜 지금까지 숨기고 계셨던 거죠?"`,
    },
    intro_two: {
      nav_title: `반더풀의 황당한 주장`,
      paragraph_one: `—반더풀: "용기가 없었습니다. 우리 집안 내력애 대해선 늘 말이 많았으니까요. 제가 나서기만 했어도 쉽게 밝혀질 이야기였지만... 저는 사람들의 큰 관심이 부담스러웠습니다. 그저 소박하고 운둔하는 삶을 살고 싶었거든요. 제 개인 전용섬 중에서도 가장 마음에 드는 섬에 있는 14세기에 지어진 성에서, 카우보이 농장과 자쿠지를 오가며 매주 이런 인터뷰를 다섯 여섯 개쯤 조용히 소화하는 정도로요.”`,
      paragraph_two: `—반더풀: "하지만 비트코인의 미래가 위태로운 상황 속에서 여러분들께 진실을 알려야겠다고 다짐했습니다. 좀 더 정확히 말하자면... Creed의 데뷔 앨범인 My Own Prison의 음악과 함께요." - 반더풀이 유명한 20세기 앨범 타이틀곡 멜로디를 조용히 흥얼거린다.`,
      paragraph_three: `—반더풀: "진작 나서지 못했던 점은 유감입니다. 왜냐하면 그 CD 안에는 사토시 나카모토의 비트코인 수정 계획서도 함께 들어있기 때문이죠. 사실 저희 증조할아버지께서는 비트코인 공급량을 2,100만 개로 제한한 걸 평생 후회했습니다. 그래서 전 그의 뜻에 따라, 비트코인을 영구발행 구조로 하드포크하려는 계획을 세우고 있습니다."`,
    },
    intro_three: {
      nav_title: `사토시에게서 온 메세지`,
      paragraph_one: `당신의 TXM4H-A Hover 스크린이 삐빅- 소리를 내며 켜진다. 새로운 메시지가 도착한 모양이다.`,
      paragraph_two: `—홀로캣: "내 코를 눌러봐"`,
      paragraph_three: `당신은 그녀의 코를 살짝 누른다.`,
      paragraph_four: `—사토시 나카모토: "반더풀이 사토시 나카모토 증손자라고? 절대 아니야. 너가 진실을 밝혀야 돼. 사토시 지갑의 개인키로 메시지에 서명해서 본인이 소유자임을 증명하라고 해봐.”`,
    },
    derive_message_one: {
      title: `메시지의 진위를 밝히다`,
      nav_title: `문제가 된 메시지`,
      heading: `반더풀은 이 메시지가 사토시 개인키로 서명된 진짜 메시지라고 주장합니다:`,
      code_one: `-----비트코인 서명된 메시지 시작----- \n \n I am Vanderpoole and I have control of the private key Satoshi used to sign the first-ever bitcoin transaction confirmed in block #170. This message is signed with the same private key. \n \n(한국어: 나는 반더풀이고, 사토시가 블록 #170에서 처음 서명한 비트코인 거래에 사용한 개인키를 갖고 있다. 이 메시지는 그 개인키로 서명했다.) \n \n -----비트코인 서명 시작----- \n \n`,
      code_two: `<span className="break-all"> H4vQbVD0pLK7pkzPto8BHourzsBrHMB3Qf5oYVmr741pPwdU2m6FaZZmxh4ScHxFoDelFC9qG0PnAUl5qMFth8k= </span>`,
      code_three: `\n \n-----비트코인 서명 종료-----`,
      paragraph_two: `이게 무슨 의미일까요?`,
    },
    derive_message_two: {
      nav_title: `공개키를 찾아라`,
      paragraph_one: `챕터 4에서 배웠듯이 개인키는 엄청나게 긴 무작위 숫자이며, 만든 사람만 알고 비밀로 보관해야 합니다. 우리는 타원 곡선 수학을 이용해 이 개인키로 공개키를 계산할 수 있어요.`,
      paragraph_two: `공개키는 공유 가능한 유일한 식별자입니다. 그리고 개인키는 그 공개키에 대한 소유권을 증명할 수 있습니다. 이 증명 방식이 바로 '서명(Signature)'입니다. 서명을 만드려면 필요한 건 메시지와 개인키, 이 두가지 입니다. 그렇게 만들어진 서명은 누구든지 메시지와 공개키만 있으면 진짜인지 아닌지 직접 확인할 수 있습니다.`,
      paragraph_three: `반더풀은 메시지와 서명은 제출했습니다. 하지만 공개키는 어디있는 걸까요?`,
    },
    derive_message_three: {
      nav_title: `사토시의 서명을 찾아라`,
      heading: `먼저 사토시의 서명부터 찾아봅시다.`,
      paragraph_one: `블록 #170에는 사토시가 할 피니(Hal Finney)에게 보낸 <link href="https://bitcointalk.org/index.php?topic=155054.0" target="_blank" className="underline">첫 비트코인 트랜잭션</link>이 담겨있습니다. 그 거래에는 딱 하나의 <Link href="https://blockstream.info/tx/f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16?expand" target="_blank" className="underline">입력(input)</Link>이 있습니다. 이 입력에서 scriptSig를 찾아봅시다. 거기서 사토시의 실제 서명이 담겨 있을 거예요.`,
      placeholder: `데이터를 여기에 붙여넣으세요.`,
      success: `잘하셨습니다! 이건 진짜 사토시의 서명입니다. 그가 할 피니에게 비트코인을 보내며 전송을 승인한 증거가 됩니다.`,
    },
    derive_message_four: {
      nav_title: `사토시의 공개키를 찾아라`,
      heading: `사토시의 공개키는 어디에 있는걸까?`,
      paragraph_one: `사토시가 블록 #9를 채굴하면서 받은 보상 비트코인에는 공개키가 포함됩니다.`,
      paragraph_two: `<Link href="https://blockstream.info/tx/0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9?output:0&expand" target="_blank" className="underline">이 링크</Link>를 따라가면 입력 #0의 가장 위에 있는 원본 트랜잭션을 볼 수 있습니다. 이건 바로 사토시가 블록 #9을 채굴하면서 직접 시행한 트랜잭션입니다. 이 트랜잭션은 50 BTC를 만들어내고 그 코인을 공개키로 잠가두었습니다. 이 공개키는 scriptPubKey 안에서 '0411...'로 시작하는 데이터를 찾아보면 됩니다.`,
      paragraph_three: `이 공개키는 scriptPubKey 안에서 OP_PUSHBYTES와 OP_CHECKSIG 사이에 있습니다. 찾아서 아래에 붙여넣어주세요:`,
      placeholder: `데이터를 여기에 붙여넣으세요.`,
      success: `잘하셨습니다!`,
    },
    derive_message_five: {
      nav_title: `이제 서명을 검증해봅시다.`,
      paragraph_one: `사토시는 블록 #9을 채굴하며 50 BTC를 보상으로 받았습니다. 그 코인을 할 피니에게 보내는 거래가 블록 #170에 담겨 있었죠. 그 거래에서 사토시는 10 BTC는 할 피니의 공개키로 보내고, 40 BTC는 거스름돈으로 자신에게 되돌려 보냈습니다. 이 트랜잭션을 승인하기 위해 사용된 게 바로 사토시의 개인키로 생성된 디지털 서명입니다.`,
      paragraph_two: `다음으로는 서명이 진짜인지 검증하는 방법을 배우겠습니다. 하지만... 그 전에, 사토시가 할 피니에게 비트코인을 보내기 위해 서명한 "그 메시지"는 대체 뭐였을까요?`,
    },
    derive_message_six: {
      nav_title: `서명에 사용된 메시지 추출하기`,
      heading: `트랜잭션에서 서명용 메시지 추출하기`,
      paragraph_one: `block explorer에서 확인할 수 있듯, 비트코인 트랜잭션은 여러 요소로 구성되어 있어요. 어떤 건 작은 숫자고, 어떤 건 큰 데이터 블록이에요. 비트코인 프로토콜은 이 트랜잭션들을 바탕으로 서명 가능한 메시지를 만드는 구체적인 알고리즘을 갖고 있습니다. 그 메시지가 개인키로 서명되는 대상이 됩니다.`,
      paragraph_two: `우리는 <Link href="https://en.bitcoin.it/wiki/OP_CHECKSIG" target="_blank" className="underline">이 링크</Link>에 정리된 과정을 요약해서 따라가볼 거예요. 운 좋게도 그 문서에 <Link href="https://en.bitcoin.it/wiki/OP_CHECKSIG#Code_samples_and_raw_dumps" target="_blank" className="underline">블록 #170의 트랜잭션 예제</Link>가 그대로 사용되어 있습니다.`,
      paragraph_three: `트랜잭션 전체를 구성하는 원시 바이트(hex 형식의 데이터)가 필요해요. <Link href="https://blockstream.info/api/tx/f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16/hex" target="_blank" className="underline">Our block explorer</Link>를 사용하여 hex API의 endpoint를 열고, 그 안에 있는 데이터를 전체 복사해서 아래에 붙여넣어 주세요.`,
      input_challenge_label: `트랜잭션 전체 데이터를 여기에 붙여 넣으세요.`,
      success_message_line_one: `트랜잭션을 구성요소를 항목별로 나눠 표시해두었습니다:`,
      success_message_line_two: `버전:`,
      success_message_line_three: `입력(input)의 개수:`,
      success_message_line_four: `입력 #0이 참조한 거래의 해시:`,
      success_message_line_five: `입력 #0이 사용한 UTXO의 인덱스 번호:`,
      success_message_line_six: `입력 #0의 사용을 승인하는 scriptSig:`,
      success_message_line_seven: `입력 #0의 시퀀스 넘버:`,
      success_message_line_eight: `출력(output) 개수:`,
      success_message_line_nine: `출력 #0의 값 (10 BTC 또는 1,000,000,000 satoshis):`,
      success_message_line_ten: `출력 #0의 scriptPubKey (할 피니의 공개키 + OP_CHECKSIG):`,
      success_message_line_eleven: `출력 #1의 값 (40 BTC 또는 4,000,000,000 satoshis):`,
      success_message_line_twelve: `출력 #1 scriptPubKey (사토시가 되돌려받은 잔액을 자신의 공개키로 잠금 처리):`,
      success_message_line_thirteen: `락타임(locktime: 거래가 유효해지는 시간):`,
    },
    derive_message_seven: {
      nav_title: `서명할 메시지 만들기`,
      paragraph_one: `서명 안에 그 서명 자체를 포함할 수는 없습니다. 따라서 메시지를 만들 때는 scriptSig를 제거해야 합니다. 비트코인 프로토콜에서는 scriptSig 대신, 우리가 사용하려는 트랜잭션 출력의 scriptPubKey를 넣습니다.`,
      paragraph_two: `우리는 이전 단계에서 이미 scriptPubKey를 찾아뒀습니다. 그 값을 첫 번째 빈칸에 붙여 넣어봅시다.`,
      paragraph_three: {
        a: `서명 메시지를 완성하려면 마지막으로 하나가 더 필요합니다. 바로`,
        b: `입니다. 이건 다음 챕터에서 더 자세히 다룰 예정입니다. 지금은 간단히 메시지 끝에 <span className="font-bold">01000000</span> 값을 추가해주면 됩니다.`,
      },
      tooltip_one: {
        question: `sighash flags는 무엇인가요?`,
        link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=what%2520are%2520sighash%2520flags%253F`,
        highlighted: `sighash type flag`,
      },
      success: `좋습니다! 서명할 메시지를 완성했습니다.`,
    },
    verify_signature_one: {
      title: `서명 검증하기`,
      nav_title: `서명 검증하기`,
      heading: `드디어 서명할 메시지를 손에 넣었습니다!`,
      paragraph_one: `이제 우리는 사토시가 자신의 개인키로 직접 만든 서명, 그리고 그의 공개키까지 다 갖고 있습니다. 이 서명이 실제 사토시의 서명인지 확인하는 방법을 배워봅시다. 그리고 나서 반더풀이 제출한 서명도 진짜인지 확인해보는 겁니다.`,
    },
    verify_signature_two: {
      title: `서명 검증하기`,
      nav_title: `메시지 해싱하기`,
      heading: `트랜잭션 데이터를 해싱해서 요약하기`,
      paragraph_one: `직렬화된 트랜잭션 데이터는 너무 길어서 ECDSA(타원 곡선 서명 알고리즘)로 직접 서명하거나 검증하기 어렵습니다.`,
      paragraph_two: `그럼 이렇게 긴 데이터를 어떻게 하면 짧고 간단한 형태로 만들 수 있을까요? 맞습니다. 바로 해싱(hash)입니다.`,
      paragraph_three: {
        a: `비트코인 프로토콜에서는 트랜잭션 데이터를 서명 가능한 메시지로 압축하기 위해`,
        b: ` 를 사용합니다.`,
      },
      paragraph_four: `32바이트짜리 해시 값을 만들고 나면, 이를 하나의 정수(integer)로 변환합니다. 무려 32바이트짜리 정수이므로 어마어마하게 큰 숫자입니다.`,
      tooltip_one: {
        question: `왜 비트코인에서는 대부분의 데이터를 두 번 해시(double hash) 할까요?`,
        link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=Why%2520does%2520everything%2520in%2520bitcoin%2520use%2520double%2520hash%2520%28HASH256%29%253F`,
        highlighted: `double SHA256 digest`,
      },
      success: `잘하셨습니다!`,
    },
    verify_signature_three: {
      nav_title: `서명 디코딩하기`,
      heading: `서명 내용 해석하기`,
      label_one: `R 값 붙여넣기`,
      label_two: `S 값 붙여넣기`,
      paragraph_one: `사토시의 서명은 DER이라는 형식으로 인코딩되어 있습니다. DER은 ASN.1이라는 데이터 표현 규칙의 하위 형식입니다.`,
      paragraph_two: `우리가 추출해야 할 값은 32바이트 길이의 숫자 두 개입니다. 하나는 R, 다른 하나는 S라고 부릅니다. 이 값들은 DER 구조 안에서 각각 "0220"이라는 바이트로 시작합니다. DER 형식 전체를 복잡하게 분석할 필요는 없습니다. 그냥 0220으로 시작하는 부분을 찾아서 R 값과 S 값만 따로 복사해서 붙여넣으면 됩니다.`,
      paragraph_three: `# 아래는 할피니에게 보낸 트랜잭션(블록 #170)에서 scriptSig에 들어있던 사토시의 서명 값입니다.`,
    },
    verify_signature_four: {
      nav_title: `공개키 디코딩하기`,
      heading: `공개키 디코딩하기`,
      label_one: `x 좌표 붙여넣기`,
      label_two: `y 좌표 붙여넣기`,
      paragraph_one: `챕터 4에서 배웠듯이, 공개키는 실제로 ECDSA 타원곡선 위에 있는 하나의 점입니다. 그래서 항상 x좌표와 y좌표 두 값을 가지고 있습니다. 공개키의 첫 바이트가 04로 시작되면, 그건 압축되지 않은 형식(uncompressed) 입니다. (챕터 4에서 배운 02, 03은 압축된 형태였습니다.) 이 04는 떼어내고, 나머지 64바이트 데이터를 32바이트씩 나누면 앞의 32 바이트는 x좌표, 뒤의 32바이트는 y좌표가 됩니다. 이제 그 두 값을 복사해서 붙여넣으면 됩니다.`,
      paragraph_two: `아래는 블록#9의 코인베이스 트랜잭션에서 추출한 사토시의 공개키입니다. (output의 scriptPubKey에 담겨 있습니다.)`,
    },
    verify_signature_five: {
      title: `서명 검증하기`,
      nav_title: `서명 테스트하기`,
      heading: `서명을 검증해봅시다!`,
      success: `해냈습니다. 사토시의 서명이 진짜임을 성공적으로 검증했습니다!`,
      paragraph_one: `이제 ECDSA를 계산할 준비가 됐습니다.`,
      paragraph_two: `ECDSA 서명 검증 알고리즘의 원리는 <Link className="underline" href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#Signature_verification_algorithm" target="_blank">위키백과</Link>와 <Link className="underline" href="https://www.secg.org/sec1-v2.pdf#page=52" target="_blank">공식 문서</Link>에 잘 정리돼 있습니다.`,
      paragraph_three: `우리는 이미 사토시의 공개키 x, y 좌표로부터 타원곡선 위 점(Group Element) 객체를 생성해뒀습니다. 이제 당신은 ECDSA 서명 검증 함수 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">verify()</span>를 완성하면 됩니다. 모든게 올바르면 True를 반환할겁니다.`,
      paragraph_four: `사토시의 서명은 2010년부터 지금까지 모든 비트코인 풀 노드가 검증해온 진짜입니다. 그러니 만약 당신의 코드가 True를 반환하지 않는다면 어딘가 실수가 있는 거예요 다시 점검해봅시다!`,
      python: {
        paragraph_five_part_one: `힌트: 파이썬의 <span className="text-green">pow()</span> 함수는`,
        paragraph_five_part_two: `음수 지수나 모듈로(modulus) 값을 인자로 받을 수 있습니다. 자세한 내용은 <Link className="underline" href="https://docs.python.org/3/library/functions.html#pow" target="_blank">공식 문서</Link>를 참고해보세요.`,
      },
      javascript: {
        paragraph_five_part_one: `우리는 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">invert()</span>라는 보조 함수(helper function)를 미리 준비해놨습니다.`,
        paragraph_five_part_two: `이 함수는 자바스크립트에는 기본적으로 없는 모듈로 역수 계산(modular inverse)을 대신해줄 겁니다.`,
      },
    },
    validate_signature_one: {
      title: `서명 유효성 검증하기`,
      nav_title: `검증할 메시지 준비하기`,
      heading: `반더풀이 서명한 메시지를 검증할 수 있도록 준비해봅시다`,
      paragraph_one: `반더풀은 본인의 주장을 뒷받침하기 위해 <Link href="https://github.com/bitcoin/bips/blob/master/bip-0137.mediawiki" target="_blank" className="underline">비트코인 메시지 서명 프로토콜</Link>을 사용했습니다. 계산 방식은 우리가 지금까지 배운 것과 같지만 메시지를 준비하는 과정이 조금 다릅니다.`,
      paragraph_two: `먼저, 반더풀의 메시지를 특정 템플릿 형식에 따라 바이트(byte) 배열로 인코딩해야 합니다.`,
      paragraph_three: {
        pre_link: `그 다음엔 그 데이터를`,
        highlighted: `SHA-256으로 두 번 해싱(double hash)`,
        question: `비트코인에서는 왜 항상 두 번 해시(double hash)를 할까요?`,
        post_link: `한 후, 그 결과를 정수(integer)로 변환해야 해요. 함수 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">encode_message()</span>를 완성해보세요. 최종적으로는 32바이트짜리 16진수(hex) 값을 반환해야 합니다.`,
      },
      success: `잘하셨습니다!`,
    },
    validate_signature_two: {
      nav_title: `서명 데이터 준비하기`,
      heading: `반더풀의 서명을 검증할 수 있도록 준비해봅시다`,
      paragraph_one: `반더풀이 사용한 비트코인 메시지 서명 프로토콜에서는 서명을 base64 형식으로 인코딩하도록 되어 있습니다. 우리는 이 base64 문자열을 총 65바이트 길이의 바이트 시퀀스로 디코딩해야 합니다. 맨 앞의 1바이트 메타데이터는 제외한 후, 그 다음 남은 64바이트 데이터는 32바이트짜리 r값과 s값으로 구성됩니다. (6단계에서 봤던 바로 그 r, s값 입니다!)`,
      javascript: {
        paragraph_two: {
          post_link: `함수 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">decode_sig()</span>를 완성해보세요.`,
          return: `이 함수는 [r, s] 값을 BigInts 형식의 배열로 반환해야 합니다.`,
        },
      },
      python: {
        paragraph_two: {
          post_link: `함수 <span className=" text-green">decode_sig()</span>을 완성하세요.`,
          return: `이 함수는 (r, s) 값을 담은 튜플(tuple)을 반환해야 합니다.`,
        },
      },
      success: `훌륭합니다!`,
    },
    validate_signature_three: {
      title: `서명이 진짜인지 검증하기`,
      nav_title: `반더풀이 거짓말 한 건지 확인해봅시다`,
      heading: `그래서 반더풀은 정말 거짓말쟁이일까요?`,
      paragraph_one: `이제 프로그램에 필요한 요소들을 모두 모아, 반더풀의 서명이 사토시 공개키에 연결된 개인키로부터 나온 것인지 검증해봅시다. 주어진 코드를 참고하여 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm"> verify()</span> 함수를 실행하는 데 필요한 값을 채워주세요.`,
      paragraph_two: `이제 프로그램을 실행해 반더풀이 거짓말을 한 건지 밝혀봅시다. 두근두근... 결과를 확인해볼까요?`,
      success: `결과가 나왔습니다. 검증이 실패했어요. 즉, 이 메시지는 사토시의 공개키로 서명된 것이 아닙니다.`,
    },
    validate_signature_four: {
      title: `서명 검증하기`,
      nav_title: `진짜 공개키 찾기`,
      heading: `반더풀은 대체 어떻게 그 서명을 만들었을까?`,
      paragraph_one: `홀로캣이 툭 끼어들며 말합니다. "BitRey 내부의 누군가가 반더풀이 자주 사용하는 공개키 목록을 우리에게 몰래 넘겨줬어. 어쩌면 그 중 하나로 메시지를 서명했을지도 몰라."`,
      paragraph_two: `반더풀이 실제로 사용한 공개키를 알아내기 위해, 이 키들 중 하나를 입력해 검증을 시도해봅시다.`,
      paragraph_three: `이 키들 중 하나로 반더풀의 메시지와 서명을 검증할 수 있을까요?`,
      success: `이 서명은 반더풀의 공개키에서 유효합니다. 즉, 이건 사토시가 아닙니다! 이제 진실이 밝혀졌습니다.`,
    },
    outro_one: {
      title: `마무리`,
      nav_title: `챕터 완료`,
      heading: `반더풀이 거짓말을 했습니다!`,
      paragraph_one: `이번 챕터를 통해 비트코인의 가장 중요한 교훈을 배웠습니다. 바로 "믿지 말고, 검증하라." <br><br>당신의 손으로 직접 검증한 덕분에, 반더풀이 사토시의 키를 사용하지 않았다는 사실이 밝혀졌습니다. 그 순간, 그의 가족 이야기와 명성, 그리고 BitRey의 신뢰도까지 모두 흔들리게 되었죠.`,
    },
    resources: {
      derive_message_three: {
        op_pushdata_heading: `OP_PUSHDATA`,
        op_pushdata_paragraph_one: `비트코인 스크립트에서 OP_PUSHDATA는 임의의 데이터를 블록체인에 삽입할 수 있도록 해주는 중요한 명령어입니다. 사실, 이는 다양한 크기의 데이터를 포함할 수 있게 해주는 일련의 명령어 범주입니다. 이 덕분에 비트코인 스크립트는 더 유연해져, 스마트 계약이나 사용자 맞춤 트랜잭션을 구현할 수 있게 됩니다. 이번 경우에는 71바이트짜리 데이터를 스택에 넣어야 합니다. 이걸 16진수(hex)로 어떻게 표현할지 한번 생각해봅시다. 추가적인 OP_CODES 설명은 <Link href="https://en.bitcoin.it/wiki/Script#Constants" target="_blank" className="underline">여기</Link>에서 볼 수 있어요.`,
      },
      derive_message_four: {
        op_checksig_heading: `OP_CHECKSIG`,
        op_checksig_paragraph_one: `OP_CHECKSIG는 비트코인 스크립트에서 핵심적인 명령어로, 대부분의 스크립트에 포함되어 있습니다. 이는 주어진 공개키가 서명한 트랜잭션이 유효한지를 확인하는 데 사용됩니다. 대부분의 비트코인 스크립트에 이 명령어가 포함되어 있는데, 서명을 통해 비트코인을 쓸 수 있는 자격이 있는지 검증해줍니다. 더 많은 OP_CODE 설명은 <Link href="https://en.bitcoin.it/wiki/Script#Constants" target="_blank" className="underline">여기</Link>에서 확인 가능합니다.`,
      },
      derive_message_six: {
        transaction_parts_heading: `트랜잭션 구성 항목`,
        transaction_parts_one: `버전(Version): 이 값은 트랜잭션이 어떤 형식으로 구성되어 있는지를 나타냅니다.`,
        transaction_parts_two: `입력 개수(Number of inputs): 트랜잭션에 포함된 입력의 수를 의미합니다.`,
        transaction_parts_three: `입력 #0 TXID(Input #0 TXID): 입력 #0이 참조하고 있는 이전 트랜잭션의 해시값(TXID)입니다.`,
        transaction_parts_four: `입력 #0 인덱스(Input #0 index): 위에 트랜잭션에서 어떤 출력(output)을 사용하는지를 나타내는 인덱스입니다.`,
        transaction_parts_five: `스크립트시그(Scriptsig): 선택한 출력을 사용할 수 있다는 증거를 담고 있는 데이터입니다. 일반적으로 서명 등이 포함됩니다.`,
        transaction_parts_six: `입력 #0 시퀀스 번호(Input #0 sequence): 특정 조건이나 시간이 충족되어야만 이 입력을 사용하도록 제한할 때 사용하는 값입니다.`,
        transaction_parts_seven: `출력 개수(Number of outputs): 이 트랜잭션이 생성하는 출력(output)의 수를 나타냅니다.`,
        transaction_parts_eight: `출력 #0 금액(Output #0 value): 출력 #0 금액: 첫 번째 출력이 보내는 금액입니다. 리틀 엔디언 방식의 정수로 표현됩니다. (*리틀 엔디언: 가장 작은 바이트가 앞에 오는 방식)`,
        transaction_parts_nine: `출력 #0 스크립트퍼브키(Output #0 scriptPubKey): 출력 #0 스크립트퍼브키: 해당 금액을 사용하기 위해 충족해야 하는 조건들을 정의한 스크립트입니다. 일반적으로 공개키와 여러 연산 코드(opcode)로 구성됩니다.`,
        transaction_parts_ten: `출력 #1 금액(Output #1 value): 두 번째 출력에서 보내는 금액입니다. 마찬가지로 리틀 엔디언 형식의 정수로 표시됩니다.`,
        transaction_parts_eleven: `출력 #1 스크립트퍼브키(Output #1 scriptPubKey): 두 번째 출력 금액을 사용하기 위해 충족해야 할 조건들을 정의합니다. 보통 공개키와 다양한 연산 코드로 구성됩니다.`,
        transaction_parts_twelve: `락타임(Locktime): 이 트랜잭션이 유효해지는 최소 블록 높이를 나타냅니다. 지정된 블록이 생성되기 전까지는 처리되지 않습니다.`,
      },
      derive_message_seven: {
        sighash_type_flag_heading: `SigHash 타입 플래그`,
        sighash_type_flag_paragraph_one: `SigHash 플래그는 비트코인에서 서명이 작동하는 방식을 정의하는 역할을 합니다. 쉽게 말하자면 서명이 트랜잭션의 어느 부분에 "책임을 지는지"를 정하는 겁니다. 이 플래그는 각 서명 뒤에 1바이트로 덧붙여지며, 같은 트랜잭션 안에서도 입력(input)마다 서로 다른 값으로 설정될 수 있습니다. SigHash 플래그의 종류에 따라 서명이 적용되는 범위(전체, 일부, 특정 출력 등)가 달라집니다. 자세한 내용은 <Link href="https://river.com/learn/terms/s/sighash-flag" target="_blank" className="underline">여기</Link>를 확인하세요.`,
      },
      verify_signature_two: {
        tip_one: `JavaScript 힌트: 16진수 문자열을 바이트 버퍼로 변환하려면 이렇게 쓰면 됩니다: <span className="p-1 font-mono bg-[#0000004D] m-1">Buffer.from(someString, 'hex');</span>`,
        signature_verification_heading: `서명 검증`,
        signature_verification_paragraph_one: `서명 검증은 수학적인 알고리즘입니다. 한 사람이 개인키를 알고 있다는 걸 증명하기 위해서는 그 사람만 만들 수 있는 데이터(서명)을 제출해야 합니다. 검증 과정에서는 서명, 공개키, 그리고 메시지 세 가지를 비교합니다. 알고리즘 결과가 TRUE라면 그 서명은 진짜이고, 해당 개인키를 실제로 알고 있는 사람이 만들었다는 뜻입니다.`,
      },
      verify_signature_three: {
        signature_encoding_heading: `서명 인코딩 방식`,
        signature_encoding_paragraph_one: `비트코인에서는 ECDSA 서명을 저장할 때 DER(Distinguished Encoding Rules) 형식을 사용합니다. ECDSA 서명은 개인키와 서명할 메시지를 해시한 값으로 생성됩니다. 이 서명은 두 개의 32바이트 숫자, 즉 r값과 s값으로 구성됩니다. 더 자세한 구성요소는 <Link href="https://technicaldifficulties.io/2020/07/22/bip-66-unpacking-der-signatures/" target="_blank" className="underline">여기</Link>에서 확인할 수 있습니다.`,
      },
      verify_signature_four: {
        eliptic_curve_heading: `타원 곡선 디지털 서명 알고리즘 (ECDSA, Elliptic Curve Digital Signature Algorithm)`,
        eliptic_curve_paragraph_one: `ECDSA는 비트코인이 사용하는 암호학 알고리즘으로, 비트코인을 소유한 사람만 해당 자금을 사용할 수 있도록 보장해줍니다. 공개키는 개인키를 타원 곡선 연산을 통해 만들어줍니다. 그 과정은 컴퓨터로 쉽게 계산할 수 있지만, 공개키만으로는 개인키를 역산하는 것이 사실상 불가능합니다. 이처럼 단방향 구조는 비트코인 보안의 핵심 원리 중 하나입니다.`,
        public_private_key_heading: `공개키와 개인키`,
        public_private_key_paragraph_one: `비트코인에서는 공개키와 개인키 한 쌍을 사용해서 거래의 보안을 유지합니다. 개인키는 비밀로 유지되며, 거래에 서명하고 소유권을 증명하는데 사용됩니다. 공개키는 개인키에서 만들어지며, 다른 사람과 공유해도 안전합니다. 이 공개키로 서명이 유효한지 확인할 수 있지만, 개인키는 알 수 없습니다.`,
      },
      verify_signature_five: {
        finite_field_arithmetic_heading: `유한체 산술(Finite Field Arithmetic)`,
        finite_field_arithmetic_paragraph_one: `ECDSA에서 사용되는 유한체 산술은 고정된 범위 내의 숫자를 다루는 연산입니다. 덧셈, 뺄셈, 곱셈, 모듈로 역수 구하기 같은 연산이 정해진 수의 범위(=유한체) 내에서만 이루어집니다. 이런 연산은 비트코인의 타원 곡선 암호학 계산에 꼭 필요한 핵심 개념입니다.`,
        ge_and_fe_heading: `그룹요소(Group Elements, GE)와 필드요소(Field Elements, FE)`,
        ge_and_fe_paragraph_one: `타원 곡선 암호학에서 그룹요소(GE)는 보통 타원곡선 위의 점을 의미합니다. 이번 과제에서 그룹요소는 x,y좌표가 있는 점을 가리킵니다. 반면 필드요소(FE)는 유한체의 원소를 뜻하는데, 이는 해당 수학적 범위 내에서 정해진 규칙대로 연산하기 위해 사용됩니다.`,
        modular_inverse_heading: `모듈로 역수(Modular Inverse)`,
        modular_inverse_paragraph_one: `숫자 a에 대한 모듈로 역수는 (a * b) % m = 1이 되는 숫자 b를 뜻합니다. 이 계산은 ECDSA 서명 검증 과정에서 매우 중요합니다. 검증 과정에서 u1과 u2 값을 구할 때 반드시 필요한 연산입니다.`,
      },
      validate_signature_one: {
        message_verification_heading: `메시지 검증의 중요성`,
        message_verification_paragraph_one: `메시지 검증은 비트코인 생태계에서의 메시지 보안을 강화합니다. 이는 메시지의 진위성과 무결성을 확인할 수 있게 해주며, 개인 간 거래나 스마트 계약처럼 신뢰가 중요한 상황에서 특히 유용합니다. 또한, 메시지 검증은 신원 확인이나 특정 비트코인 주소의 소유 증명같은 다양한 응용의 기반이 됩니다. 이런 암호학적으로 보증된 덕분에 비트코인의 탈중앙적이고 신뢰 없는 시스템이 더욱 강해집니다.`,
      },
      validate_signature_two: {
        base64_encoding_heading: `Base64 인코딩`,
        base64_encoding_paragraph_one: `Base64는 데이터를 바이트로 변환하거나, 바이트에서 텍스트로 변환할 수 있도록 해주는 기본 인코딩 방식입니다. 이 인코딩 방식은 URL 경로나 쿼리 파라미터와의 충돌을 피하도록 설계되었습니다. Base58과 달리 Base64는 0(숫자), O(대문자 O), I(대문자 아이), l(소문자 엘) 같은 헷갈릴 수 있는 문자도 포함하고 있습니다. 사용자가 메시지를 복사하거나 말로 전달할 때 혼동을 줄 수 있는 문자가 포함되어 있다는 단점이 있습니다.`,
      },
      validate_signature_three: {
        signing_and_ownership_heading: `메시지 서명과 소유권`,
        signing_and_ownership_paragraph_one: `비트코인은 가명성(pseudo-anonymity)에 기반하기 때문에, 우리가 확실하게 증명할 수 있는 건 제한적입니다. 예를 들어, 키의 소유자는 메시지 서명을 거부하거나, 일부러 잘못된 키로 서명할 수도 있습니다. 그래서 우리가 유일하게 증명할 수 있는 것은, 유효하지 않은 서명을 만든 키는 유효한 서명을 생성할 수 있는 진짜 키가 아니라는 점입니다.`,
      },
      validate_signature_four: {
        one_for_one_heading: `1:1 대응원칙`,
        one_for_one_paragraph_one: `ECDSA의 신뢰성과 보안을 보장하기 위해, 개인 키로 생성된 서명은 반드시 그에 대응하는 공개 키로만 검증될 수 있습니다. 만약 다른 개인 키들로 같은 공개 키나 서명을 만들 수 있다면, 이 알고리즘의 보안은 무너져버립니다. 따라서, 이 메시지를 유효하게 서명한 공개키는 해당 비트코인의 소유자임을 나타냅니다.`,
      },
    },
  },

  chapter_six: {
    title: `열쇠를 쥔 자`,
    paragraph_one: `아아악! 당신 때문에 사기를 들킨 반더풀이 당신에게 복수하려고 눈이 돌아갔습니다. 하지만 진실이 드러났음에도 불구하고, 여전히 많은 사람들이 반더풀이 스스로 만들어낸 가짜 신화(자신과 가족, 그리고 조상에 대한 이야기)에 매달리고 있습니다. 세상이 불안하고 무서운 시기일수록, 사람들은 영웅을 갈망하거든요. 그리고 안타깝게도, 많은 사람들에게는 그게 바로 반더풀입니다. 반더풀이 그들이 가진 유일한 희망인 셈입니다.`,
    intro_one: {
      title: `들어가며`,
      nav_title: `그 사람은 정말 사토시였을까?`,
      paragraph_one: `—사토시 나카모토: ”잘했어. 이제 세상은 직접 두 눈으로 반더풀이 사기꾼이라는 걸 보게 될 거야. 아직 믿지 않는 사람들이 있어도, 우리가 할 일을 끝내기 전에는 결국 알게 될 거야.”`,
      paragraph_two: `당신은 잠시 멈춰 서서 지금까지의 모든 메시지가 '사토시 나카모토'라는 서명으로 끝났다는 걸 떠올립니다. 그저 비트코인의 철학을 따르는 누군가가 사용하는 가명일 거라고만 생각합니다. "설마 진짜 사토시일 리는 없어"하면서요. 하지만... 결국 당신은 직접 물어봐야겠다고 마음 먹습니다.`,
      paragraph_three: `—”이런 질문이 좀 바보 같을 수도 있지만... 당신, 혹시 진짜 사토시인가요?”`,
    },
    intro_two: {
      title: `들어가며`,
      nav_title: `미카 3000에게 돈을 보내다`,
      paragraph_one: `—홀로캣: “요즘 너 바보같은 말만 골라서 하더라?”`,
      paragraph_two: `—사토시 나카모토: “비트코인은 이미 오래전에 창조자의 손을 떠났어. 반더풀이든 나든, 혹은 그 후손이든 누가 진짜 사토시인지는 더 이상 중요하지 않아. 비트코인은 공동체에 의해 정의되는 것이고, 그 누구도, 심지어 사토시조차도 그걸 마음대로 할 수 없어. 그걸 증명하는 게 진짜 싸움이야. 실은 말이지, 네 그 괴짜 프리랜서 기자 친구한테 연락 좀 해달라고 부탁했어. 괜찮지?”`,
      paragraph_three: `—뭐라고요?`,
      paragraph_four: `—딩! (알람 소리)`,
      paragraph_five: `—홀로캣: "내 코 누르는거 잊지마~"`,
      paragraph_six: `—미카 3000: “넌 배짱 하나는 정말 대단해. 하지만 배짱만으론 부족해. 네가 밝혀낸 건 시작에 불과하거든. 이 이야기엔 더 많은 게 숨겨져 있어, 그리고 그 '더 많은 것'이 뭔지 알아내려면 반더풀의 개인 섬에 직접 가봐야 해. 그런데 비용이 엄청 들 거야. 예전에 우리가 같이 만들었던 멀티시그 지갑 기억나? 거기서 돈 좀 꺼내려면 네 도움이 필요해. 아직 내 키 중 하나 갖고 있지?”`,
    },
    in_out_one: {
      title: `입출금의 흐름`,
      nav_title: `아직 쓰이지 않은 UTXO`,
      paragraph_one: `미카 3000은 반더풀의 개인 섬으로 떠나기 위한 장비를 사기 위해 1 BTC가 필요합니다. 당신은 챕터 3에서 채굴로 얻은 보상 중 1 BTC를 그녀에게 보내기로 합니다. 그 보상은 챕터 4에서 만든 주소로 채굴풀을 통해 입금되어 있습니다.`,
      paragraph_two: `당신은 비트코인 풀 노드를 열고, 당신의 돈이 블록체인 상에서 어디에 있는지 확인하는 명령어를 실행합니다.`,
      paragraph_three: `이건 아직 쓰이지 않은 거래 출력, 즉 UTXO 입니다. 챕터  4에서 만든 압축 공개키 해시랑 주소가 보일 거예요. 금액은 1.61 BTC 입니다.`,
    },
    in_out_two: {
      title: `입출금의 흐름`,
      nav_title: `수신 주소`,
      paragraph_one: `미카 3000이 당신의 1 BTC 기여금을 보낼 주소를 알려줍니다:`,
      paragraph_two: `그런데 그 주소는 당신의 주소보다 훨씬 길어 보입니다. 왜 그런걸까요?`,
      paragraph_three: `이제 1.61 BTC 중 1 BTC를 이 주소로 보내는 트랜잭션을 만들고 서명해야 해요. 챕터 5에서 사토시의 트랜잭션 구조를 살펴봤지만, 당신의 트랜잭션은 조금 다를 겁니다. 요즘은 더 새로운 방식으로 트랜잭션을 만듭니다. Segregated Witness(세그윗)라는 프로토콜을 사용해 봅시다. 이 방식은 트랜잭션 버전을 2로 설정합니다.`,
    },
    in_out_three: {
      title: `입출금의 흐름`,
      nav_title: `트랜잭션 절차`,
      paragraph_one: `Segregated Witness(세그윗) 트랜잭션은 이전의 레거시 트랜잭션과 거의 같은 방식으로 작동합니다. 여기엔 버전(version), 락타임(locktime) 같은 전역 값들이 있고, 사용할 입력(UTXO) 배열과 생성할 출력(새로운 UTXO) 배열도 포함됩니다. 또한 각 입력마다 하나씩 증인(witness) 배열이 있습니다. 세그윗 트랜잭션은 레거시 트랜잭션과 거의 동일하게 작동하지만, scriptSig 대신 각 입력에 대응하는 witness 배열에 서명과 스크립트를 포함합니다.`,
      paragraph_two: `메시지 직렬화 방식에 대한 자세한 내용은 <Link href="https://en.bitcoin.it/wiki/Protocol_documentation#tx" target="_blank" className="underline">여기</Link>와 <Link href="https://github.com/bitcoinbook/bitcoinbook/blob/6d1c26e1640ae32b28389d5ae4caf1214c2be7db/ch06_transactions.adoc" target="_black" className="underline" >여기</Link>에서 확인할 수 있습니다.`,
    },
    in_out_four: {
      normal: {
        title: `입출금의 흐름`,
        nav_title: `Input 클래스 살펴보기`,
        heading: `Input 클래스 구현 살펴보기`,
        paragraph_one: `여기에는 <span className="font-bold">Input</span> 클래스와 <span className="font-bold">Outpoint</span> 클래스라는 두 개의 클래스 코드가 있습니다. (*주의: Outpoint(출력지점)는 Output(출력)과 다릅니다.)`,
        paragraph_two: `Input 객체는 사용되지 않은 트랜잭션 출력(UTXO)에서 생성됩니다. 만약 특정 출력 정보를 <span className="text-green p-1 font-mono bg-[#00000033] m-1 text-base">from_output()</span> 메서드에 전달하면, Input 클래스의 인스턴스가 생성됩니다.`,
        paragraph_three: `처음 두 개의 인자는 다음과 같습니다:`,
        paragraph_four: `1. <span className="font-bold">txid: </span>해당 출력을 생성한 트랜잭션의 고유 ID`,
        paragraph_five: `2. <span className="font-bold">vout: </span>트랜잭션 내 출력 목록 중에서 이 출력의 인덱스 번호`,
        paragraph_six: `이 두 가지 정보(txid와 vout)가 합쳐져서 <span className="font-bold">Outpoint</span>를 구성합니다. 이전 단계에서 <span className="text-green p-1 font-mono bg-[#00000033] m-1 text-base">listunspent</span> 명령어로 얻은 값을 여기 전달하게 될 겁니다.`,
        paragraph_seven: `다음 두 인자는 사용할 출력 금액(사토시 단위)과 scriptcode예요. scriptcode는 나중에 쓰이므로 지금은 빈 바이트 배열로 채워둡니다.`,
        paragraph_eight: {
          a: `비트코인의 해시는`,
          b: {
            text: ` 역순으로 표현됩니다.`,
            question: `왜 비트코인에서는 해시를 역순으로 뒤집을까?`,
            href: `https://chat.bitcoinsearch.xyz/?author=holocat&question=why%2520are%2520hashes%2520reversed%2520in%2520bitcoin`,
          },
          c: ` 다만, 사용자에게 보여주거나 입력할 때만 그래요. 해시가 16진수(hex)로 입력되면, 원시 바이트로 저장하거나 전송하기 전에 바이트 순서를 뒤집어야 합니다.`,
        },
        paragraph_nine: `이 개념은 <span className="text-green p-1 font-mono bg-[#00000033] m-1 text-base">from_output()</span> 메서드 안에서도 볼 수 있습니다. txid를 처리할 때 해시순서를 뒤집는 방식이 그 예입니다.`,
        paragraph_ten: `명세에 따라 바이트 배열을 반환하는 <span className="text-green p-1 font-mono bg-[#00000033] m-1 text-base">serialize()</span> 이 메서드는 네트워크 상에서 트랜잭션이 전송되거나 블록에 저장될 때 사용됩니다:`,
        heading_three: `Outpoint`,
        table_one: {
          heading: {
            one: `Description(설명)`,
            two: `Name(이름)`,
            three: `Type(타입)`,
            four: `Size(크기)`,
          },
          row_one: {
            column: {
              one: `Hash of transaction being spent from`,
              two: `txid`,
              three: `bytes`,
              four: `32`,
            },
          },
          row_two: {
            column: {
              one: `Position of output being spent in the transaction's output array`,
              two: `index`,
              three: `int`,
              four: `4`,
            },
          },
        },
        heading_four: `Input`,
        table_two: {
          row_one: {
            column: {
              one: `txid and output index being spent from`,
              two: `outpoint`,
              three: `bytes`,
              four: `36`,
            },
          },
          row_two: {
            column: {
              one: `ScriptSig 길이 (세그윗에서는 항상 0)`,
              two: `length`,
              three: `int`,
              four: `1`,
            },
          },
          row_three: {
            column: {
              one: `Always empty for Segregated Witness`,
              two: `script`,
              three: `bytes`,
              four: `0`,
            },
          },
          row_four: {
            column: {
              one: `Default value is 0xffffffff but can be used for relative timelocks`,
              two: `sequence`,
              three: `int`,
              four: `4`,
            },
          },
        },
        paragraph_eleven: {
          a: `참고: 비트코인에서는 정수가 리틀 엔디안(little-endian) 형식으로 직렬화돼요.`,
          b: {
            text: `little-endian`,
            question: `엔디안(endianness)이란 무엇인가요?`,
            href: `https://chat.bitcoinsearch.xyz/?author=holocat&question=What%2520is%2520endianness%253F`,
          },
        },
        success: `Input 클래스 구현이 완벽해요. 정말 잘했어요!`,
      },
      hard: {
        title: `입출금의 흐름`,
        nav_title: `Input 클래스 만들기`,
        heading: `Input 클래스 구현 마무리하기`,
        paragraph_one: `다음 메서드를 포함해야 합니다:`,
        paragraph_two: `처음 두 인자는 거래 ID(txid)와 그 거래에서 선택한 출력의 인덱스 번호예요.`,
        paragraph_three: `우리는 위에서 listunspent 명령어로 얻은 txid와 vout 값을 나중에 입력할 겁니다. 비트코인 해시는 리틀 엔디안 형식이라서, txid 문자열의 바이트 순서를 거꾸로 바꿔야 해요.`,
        paragraph_four: `다음 두 인자는 우리가 사용하려는 출력의 값(사토시 단위)과 ‘스크립트코드(scriptcode)’라는 것입니다. 지금은 이 값들을 Input 클래스 안에 저장해두기만 하면 돼요. 실제로 사용하는 건 6단계에서예요.`,
        paragraph_five: `트랜잭션을 직렬화하려면 명세에 맞게 바이트 배열을 반환하는 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">serialize()</span> 메서드를 만들어야 해요:`,
        heading_two: `Outpoint`,
        table_one: {
          heading: {
            one: `Description(설명)`,
            two: `Name(이름)`,
            three: `Type(타입)`,
            four: `Size(크기)`,
          },
          row_one: {
            column: {
              one: `Hash of transaction being spent from`,
              two: `txid`,
              three: `bytes`,
              four: `32`,
            },
          },
          row_two: {
            column: {
              one: `Position of output being spent in the transaction's output array`,
              two: `index`,
              three: `int`,
              four: `4`,
            },
          },
        },
        heading_three: `Input`,
        table_two: {
          row_one: {
            column: {
              one: `txid and output index being spent from`,
              two: `outpoint`,
              three: `bytes`,
              four: `36`,
            },
          },
          row_two: {
            column: {
              one: `ScriptSig length (always 0 for Segregated Witness)`,
              two: `length`,
              three: `int`,
              four: `1`,
            },
          },
          row_three: {
            column: {
              one: `Always empty for Segregated Witness`,
              two: `script`,
              three: `bytes`,
              four: `0`,
            },
          },
          row_four: {
            column: {
              one: `Default value is 0xffffffff but can be used for relative timelocks`,
              two: `sequence`,
              three: `int`,
              four: `4`,
            },
          },
        },
        success: `정말 잘했어요! Input 클래스가 멋지게 완성됐네요.`,
      },
    },
    in_out_five: {
      title: `입출금의 흐름`,
      nav_title: `Output 클래스 구현하기`,
      heading: `Output 클래스 구현을 완료해봅시다.`,
      paragraph_one: `Input 클래스처럼, Output 클래스에도 사용자가 입력한 정보로 객체를 만들어주는 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">from_options()</span> 메서드가 필요해요:`,
      paragraph_two: `이 메서드는 비트코인 주소(예: 미카 3000이 준 주소처럼)를 문자열로 받고, 보낼 금액은 정수로 받아요. 이 금액은 '사토시' 단위로 표현됩니다. (1비트코인 = 1억 사토시입니다.) 주소는 다시 bech32 라이브러리를 써서 내부에서 쓸 수 있는 형식으로 바꿔야 해요.
        그리고 명세에 따라 정보를 바이트 배열로 바꿔주는 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">serialize()</span> 메서드도 만들어야 해요.`,
      heading_two: `Output`,
      table: {
        heading: {
          one: `Description(설명)`,
          two: `Name(이름)`,
          three: `Type(타입)`,
          four: `Size(크기)`,
        },
        row_one: {
          column: {
            one: `Number of satoshis being sent.`,
            two: `value`,
            three: `bytes`,
            four: `8`,
          },
        },
        row_two: {
          column: {
            one: `Total length of the following script (the "witness program").`,
            two: `length`,
            three: `int`,
            four: `1`,
          },
        },
        row_three: {
          column: {
            one: `The segregated witness version. Derived from the bech32 address.`,
            two: `version`,
            three: `int`,
            four: `1`,
          },
        },
        row_four: {
          column: {
            one: `Length of the following witness program data.`,
            two: `length`,
            three: `int`,
            four: `1`,
          },
        },
        row_five: {
          column: {
            one: `The data component derived from the bech32 address.`,
            two: `index`,
            three: `bytes`,
            four: `(var)`,
          },
        },
      },
      paragraph_three: `잊지 마세요! 비트코인에선 정수가 리틀 엔디언 방식으로 직렬화돼요. 즉, 바이트 순서가 우리가 평소에 보는 순서랑 반대예요..`,
      success: `Output 클래스도 완벽해요! 정말 잘했어요.`,
    },
    put_it_together_one: {
      title: `전체 내용 통합하기`,
      normal: {
        title: `배운 내용 정리하기`,
        nav_title: `트랜잭션 다이제스트 만들기`,
        heading: `트랜잭션 다이제스트`,
        paragraph_one: `챕터 5에서 우리는 트랜잭션에 서명하려면, 먼저 트랜잭션 데이터를 정리한 다음 해싱해서 ‘메시지’ 형태로 만들어야 한다는 걸 배웠어요. 이 메시지는 서명 알고리즘의 핵심 입력값 중 하나입니다. 이제 우리는 세그윗을 사용하고 있으므로, <Link href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki" target="_blank" className="underline">BIP 143</Link>에 정의된 새로운 방식의 트랜잭션 다이제스트 알고리즘도 함께 구현해야 합니다.`,
        paragraph_two: `모든 트랜잭션 입력값은 각자 고유한 서명이 필요하다는 점을 꼭 기억하세요. 그래서 다이제스트 알고리즘에 들어가는 일부 값들은 캐시해서 다시 쓸 수 있지만, 어떤 부분은 서명할 입력마다 달라져요. 해당 입력의 서명을 위한 32바이트짜리 메시지를 계산하는 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">digest(input_index)</span> 메서드를 완성해봅시다.`,
        list_heading: `참고 사항:`,
        list_one: `Double SHA-256(dSHA256): sha256(sha256(data)) 형식으로 해싱됩니다.`,
        list_two: `value는 쓰려는 출력에 들어 있던 금액이에요. 단위는 사토시예요. 이 값은 2단계에서 Input 클래스에 추가했으며, 지금까지 클래스 안에 보관해 두었습니다.`,
        list_three: `scriptcode는 검증 대상이 되는 비트코인 스크립트입니다. 이것 역시 2단계에서 Input 클래스에 추가해두었습니다.`,
        list_four: `모든 정수는 '리틀 엔디언(little-endian)' 형식으로 인코딩됩니다.`,
        paragraph_three: `다음 섹션에서 좀 더 자세히 알아보겠지만, P2WPKH(지불 대상이 공개키 해시인 세그위트 주소)에서 돈을 쓰려면, 필요한 scriptcode는 다음과 같습니다:`,
        paragraph_four: `...위 스크립트는 아래와 같은 비트코인 스크립트로 해석됩니다.`,
        paragraph_five: `scriptcode에 대해 더 자세히 알고 싶다면 <Link href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki" target="_blank" className="underline">BIP 143</Link>을 참고하세요.`,
        paragraph_six: `트랜잭션 원본 데이터는 아래 항목들을 순서대로 이어 붙여 만든 바이트 배열이에요.`,
        headings: {
          item_one: `Description(설명)`,
          item_two: `Name(이름)`,
          item_three: `Type(타입)`,
          item_four: `Size(크기)`,
        },
        table: {
          row_one: {
            item_one: `Transaction version, default 2`,
            item_two: `version`,
            item_three: `int`,
            item_four: `4`,
          },
          row_two: {
            item_one: `The dSHA256 of all outpoints from all inputs, serialized`,
            item_two: `bytes`,
            item_three: `bytes`,
            item_four: `32`,
          },
          row_three: {
            item_one: `The dSHA256 of all sequence values from all inputs, serialized`,
            item_two: `sequences`,
            item_three: `bytes`,
            item_four: `32`,
          },
          row_four: {
            item_one: `The serialized outpoint of the single input being signed `,
            item_two: `outpoint`,
            item_three: `bytes`,
            item_four: `36`,
          },
          row_five: {
            item_one: `The output script being spent from`,
            item_two: `scriptcode`,
            item_three: `bytes`,
            item_four: `(var)`,
          },
          row_six: {
            item_one: `The value in satoshis being spent by the single input being signed`,
            item_two: `value`,
            item_three: `int`,
            item_four: `8`,
          },
          row_seven: {
            item_one: `The sequence value of the single input being signed`,
            item_two: `sequence`,
            item_three: `int`,
            item_four: `4`,
          },
          row_eight: {
            item_one: `The dSHA256 of all outputs, serialized`,
            item_two: `outputs`,
            item_three: `bytes`,
            item_four: `32`,
          },
          row_nine: {
            item_one: `Transaction locktime, default 0`,
            item_two: `locktime`,
            item_three: `int`,
            item_four: `4`,
          },
          row_ten: {
            item_one: `Signature hash type, we will use 1 to indicate "ALL"`,
            item_two: `sighash`,
            item_three: `int`,
            item_four: `4`,
          },
        },
        paragraph_seven: `마지막으로, 서명에 사용할 메시지는 이 직렬화된 데이터를 더블 SHA-256한 값이에요.`,
        success: `digest() 메서드도 잘 작동해요. 훌륭합니다!`,
      },
      hard: {
        title: `전체 내용 통합하기`,
        nav_title: `Witness 클래스 구현하기`,
        heading: `Witness 클래스를 구현해봅시다.`,
        paragraph_one: `이 클래스에는 바이트 배열을 받아서 witness 스택에 항목을 추가하는 메서드가 필요해요.`,
        paragraph_two: `그리고 witness 스택을 직렬화해서 돌려주는 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">serialize()</span> 메서드도 필요해요.`,
        subheading_one: `Witness stack`,
        headings: {
          item_one: `Description`,
          item_two: `Name`,
          item_three: `Type`,
          item_four: `Size`,
        },
        table_one: {
          row_one: {
            item_one: `The number of items in the witness stack`,
            item_two: `count`,
            item_three: `int`,
            item_four: `1`,
          },
          row_two: {
            item_one: `Serialized stack items`,
            item_two: `items`,
            item_three: `(items)`,
            item_four: `(var)`,
          },
        },
        subheading_two: `Witness stack item`,
        table_two: {
          row_one: {
            item_one: `Total length of the following stack item`,
            item_two: `length`,
            item_three: `int`,
            item_four: `1`,
          },
          row_two: {
            item_one: `The raw bytes of the stack item`,
            item_two: `data`,
            item_three: `bytes`,
            item_four: `(var)`,
          },
        },
        success: `Witness 클래스도 멋지게 완성했어요. 잘하셨습니다.`,
      },
    },
    put_it_together_two: {
      normal: {
        title: `전체 내용 통합하기`,
        nav_title: `Witness 클래스 구현하기`,
        heading: `Witness에 서명하고 값을 채워보세요!`,
        paragraph_one: `지난 챕터에서 ECDSA 서명을 검증하는 데 필요한 핵심 코드를 만들었어요. 이제 실제로 유효한 서명을 만들기 위해, 그 코드를 조금 변형해 사용할 것입니다.`,
        paragraph_two: `이번에는 ECDSA 서명의 수학적인 원리를 직접 구현해볼 거예요. 작동 방식이 궁금하다면 아래 자료들을 참고해보세요:`,
        paragraph_three: `• The Wikipedia page for <Link href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" target="_blank" className="underline">Elliptic Curve Digital Signature Algorithm</Link>`,
        paragraph_four: `• <Link href="https://www.secg.org/sec1-v2.pdf#subsubsection.4.1.3" target="_blank" className="underline">Standards for Efficient Cryptography 1 (SEC 1)</Link>: 44 페이지, 4.1.3절`,
        heading_one: `1단계`,
        paragraph_five: `Transaction 클래스에는 <span className="text-green p-1 text-base font-mono bg-[#0000004D] m-1">compute_input_signature(index, key)</span>라는 메서드가 있습니다. 이 메서드는 입력값의 인덱스 번호와 비밀키(32바이트 정수 또는 JavaScript에서의 BigInt)를 받습니다. 이 메서드를 완성하여, 선택된 입력값에 대한 메시지 다이제스트를 계산하도록 해보세요. 이전 단계에서 만든 <span className="text-green p-1 text-base font-mono bg-[#0000004D] m-1">digest()</span> 메서드를 활용한 뒤, 서명 결과로 두 개의 32바이트 정수 — <span className="italic">r</span>과 <span className="italic">s</span> — 를 반환해야 합니다.`,
        heading_two: `2단계`,
        paragraph_six: `비트코인 프로토콜은 서명 알고리즘에서 한 가지를 더 요구합니다. 바로, <span className="italic">s</span> 값이 '낮은 값'이어야 한다는 것입니다. 여기서 '낮다'는 건 곡선의 순서를 2로 나눈 값보다 작다는 뜻이에요. 이 조건을 <span className="text-green p-1 text-base font-mono bg-[#0000004D] m-1">compute_input_signature()</span> 메서드에 추가해보세요.`,
        paragraph_seven: `더 자세한 내용은 <Link href="https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki#low_s" target="_blank" className="underline">BIP 146</Link>을 참고하세요.`,
        heading_three: `3단계`,
        paragraph_eight: `<span className="text-green p-1 text-base font-mono bg-[#0000004D] m-1">sign_input(index, priv, pub, sighash)</span> 메서드를 완성해보세요. 이 메서드는 내부에서 <span className="text-green p-1 text-base font-mono bg-[#0000004D] m-1"> compute_input_signature(index, key)</span>를 를 호출해야 합니다. 반환된 <span className="italic">r</span>과 <span className="italic">s</span>값은 DER이라는 형식으로 인코딩되어야 합니다. 이 DER 인코딩 기능은 우리가 이미 구현해두었습니다.`,
        heading_four: `4단계`,
        paragraph_nine: `비트코인에서는 DER 서명의 끝에 추가로 1바이트가 더 붙어야 합니다. 이 바이트는 '서명 해시 타입(sighash type)'을 나타냅니다. 지금은 항상 <span className="p-1 text-base font-mono bg-[#0000004D] m-1">0x01</span>을 사용하여 "SIGHASH ALL"을 의미하도록 합니다.`,
        heading_five: `5단계`,
        paragraph_ten: `마지막 단계에서는 두 개의 스택 항목을 담은 Witness 객체를 만들어야 합니다. 하나는 방금 만든 DER 형식의 서명 데이터이고, 다른 하나는 압축된 공개키입니다. 스택에는 먼저 서명을, 그다음엔 공개키를 넣어요.`,
        paragraph_eleven: `이 witness 스택을 트랜잭션의 witnesses 배열에 넣어주세요.`,
        success: `compute_input_signature()와 sign_input() 메서드도 완벽해요! 정말 잘했어요!`,
      },
      hard: {
        title: `전체 내용 통합하기`,
        nav_title: `트랜잭션을 직렬화하기`,
        heading: `트랜잭션 클래스를 구현하기`,
        paragraph_one: `이 클래스에는 전역 속성인 locktime이랑 version이 있어야 해요. 또 입력(inputs), 출력(outputs), 그리고 witness 스택도 배열로 함께 들어가야 해요.`,
        paragraph_two: `또한, 비트코인 P2P 네트워크에서 전송할 수 있도록 트랜잭션 전체를 바이트 형식으로 출력해주는 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">serialize()</span> 메서드도 필요합니다.`,
        headings: {
          item_one: `Description(설명)`,
          item_two: `Name(이름)`,
          item_three: `Type(타입)`,
          item_four: `Size(크기)`,
        },
        table: {
          row_one: {
            item_one: `Currently 2`,
            item_two: `version`,
            item_three: `int`,
            item_four: `4`,
          },
          row_two: {
            item_one: `Must be exactly 0x0001 for segregated witness`,
            item_two: `flags`,
            item_three: `bytes`,
            item_four: `2`,
          },
          row_three: {
            item_one: `The number of inputs`,
            item_two: `in count`,
            item_three: `int`,
            item_four: `1`,
          },
          row_four: {
            item_one: `All transaction inputs,serialized`,
            item_two: `inputs`,
            item_three: `Inputs[]`,
            item_four: `(var)`,
          },
          row_five: {
            item_one: `The number of outputs`,
            item_two: `out count`,
            item_three: `int`,
            item_four: `1`,
          },
          row_six: {
            item_one: `All transaction outputs,serialized`,
            item_two: `outputs`,
            item_three: `Outputs[]`,
            item_four: `(var)`,
          },
          row_seven: {
            item_one: `All witness stacks, serialized`,
            item_two: `witness`,
            item_three: `Witnesses[]`,
            item_four: `(var)`,
          },
          row_eight: {
            item_one: `Setting to 0 indicates finality`,
            item_two: `locktime`,
            item_three: `int`,
            item_four: `4`,
          },
        },
        paragraph_three: `Witnesses에는 '개수(count)' 같은 값이 따로 없어요. Witness 스택 개수는 입력 수와 항상 똑같아야 하거든요.`,
        success: `Serialize() 메서드도 제대로 구현했어요! 정말 잘했어요.`,
      },
    },
    put_it_together_three: {
      normal: {
        title: `전체 내용 통합하기`,
        nav_title: `트랜잭션 서명하기`,
        heading: `트랜잭션 클래스 구현하기`,
        paragraph_one: `트랜잭션을 완성하려면 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">serialize()</span> 기능이 필요해요. 이 기능은 전체 트랜잭션을 바이트 형식으로 바꿔서, 비트코인 P2P 네트워크로 보낼 수 있는 형태로 만들어줘요.`,
        paragraph_two: `우리의 스크립트는 하나의 Transaction 객체(설계도 기반 구조)를 만들고 여기에 서명해야 합니다. 이 객체에는 <span className="underline">입력</span> 하나(이전 단계에서 확인한 UTXO)와 출력 두 개가 포함됩니다.`,
        paragraph_three: `입력도 알고, 출력도 알았으니 이제 트랜잭션을 만들고 서명할 준비가 되었을까요? 아직은 아닙니다. 우리는 1.61 BTC를 입력값으로 가지고 있고, 1 BTC를 누군가에게 보내려고 합니다. 그럼 나머지 0.61 BTC는 대부분 잔돈으로 간주되어 다시 우리 주소로 보내야 합니다.`,
        paragraph_four: `Witnesses에는 개수(count) 값이 없습니다. Witness 스택 수는 항상 입력 수와 같아야 하기 때문입니다.`,
        paragraph_five: `그리고 ‘수수료(fee)’를 잊지 말아야 합니다. 채굴자들이 우리의 트랜잭션을 블록에 포함시키도록 하려면, 잔돈에서 아주 조금을 수수료로 떼어줘야 합니다. 예를 들어, 잔돈을 61,000,000에서 60,999,000 사토시로 줄여서 그 차이를 수수료로 쓰는 거예요.`,
        paragraph_six: `모든 준비가 끝났습니다. 당신의 스크립트는 마지막에 transaction.serialize() 기능 결과를 반환하면 됩니다. 이제 서명이 완료된, 유효한 비트코인 트랜잭션이 만들어졌어요. 이걸 네트워크에 전송하면 미카 3000에게 비트코인을 보낼 수 있어요.`,
        headings: {
          item_one: `Description(설명)`,
          item_two: `Name(이름)`,
          item_three: `Type(타입)`,
          item_four: `Size(크기)`,
        },
        table: {
          row_one: {
            item_one: `Currently 2`,
            item_two: `version`,
            item_three: `int`,
            item_four: `4`,
          },
          row_two: {
            item_one: `Must be exactly 0x0001 for segregated witness`,
            item_two: `flags`,
            item_three: `bytes`,
            item_four: `2`,
          },
          row_three: {
            item_one: `The number of inputs`,
            item_two: `in count`,
            item_three: `int`,
            item_four: `1`,
          },
          row_four: {
            item_one: `All transaction inputs, serialized`,
            item_two: `inputs`,
            item_three: `Inputs[]`,
            item_four: `(var)`,
          },
          row_five: {
            item_one: `The number of outputs`,
            item_two: `out count`,
            item_three: `int`,
            item_four: `1`,
          },
          row_six: {
            item_one: `All transaction outputs, serialized`,
            item_two: `outputs`,
            item_three: `Outputs[]`,
            item_four: `(var)`,
          },
          row_seven: {
            item_one: `All witness stacks, serialized`,
            item_two: `witness`,
            item_three: `Witnesses[]`,
            item_four: `(var)`,
          },
          row_eight: {
            item_one: `Setting to 0 indicates finality`,
            item_two: `locktime`,
            item_three: `int`,
            item_four: `4`,
          },
        },
        bullet_one: `미카 3000은 100,000,000 사토시를 주소 bc1qgghq08syehkym52ueu9nl5x8gth23vr8hurv9dyfcmhaqk4lrlgs28epwj로 받습니다.`,
        bullet_two: `당신은 61,000,000 사토시를 자신의 주소 bc1qm2dr49zrgf9wc74h5c58wlm3xrnujfuf5g80hs로 돌려받습니다.`,
        success: `해냈어요! 트랜잭션을 완성했습니다!`,
      },
      hard: {
        title: `전체 내용 통합하기`,
        nav_title: `트랜잭션 다이제스트 생성하기`,
        heading: `트랜잭션 다이제스트`,
        paragraph_one: `챕터 5에서 우리는 트랜잭션에 서명하려면 먼저 데이터를 정리하고 해시해서 메시지로 바꿔야 한다는 걸 배웠어요. 이 메시지는 서명 알고리즘에 들어가는 주요 입력값이 됩니다. 현재 우리는 세그위트(Segregated Witness)를 사용하고 있기 때문에, <Link href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki" target="_blank" className="underline">BIP 143</Link>에 정의된 업데이트된 트랜잭션 다이제스트 알고리즘을 구현해야 합니다.`,
        paragraph_two: `각 트랜잭션 입력에는 고유한 서명이 필요합니다. 다이제스트 알고리즘 중 일부는 캐시해서 다시 쓸 수 있지만, 서명할 입력마다 달라지는 부분도 있어요. 입력에 대한 32바이트 서명 메시지를 계산하는 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">digest(input_index)</span> 메서드를 완성해봅시다.`,
        list_heading: `참고 사항:`,
        list_one: `‘더블 SHA-256’ 또는 dSHA256은 sha256을 두 번 적용하는 방식이에요.`,
        list_two: `value는 사용하려는 출력에 들어 있는 사토시 양을 나타냅니다. 이 값은 2단계에서 Input 클래스에 추가한 뒤, 지금까지 그 안에 저장만 해두었습니다.`,
        list_three: `scriptcode는 평가 대상이 되는 비트코인 스크립트 원본입니다. 이 역시 2단계에서 Input 클래스에 추가해 두었습니다.`,
        paragraph_three: `다음 섹션에서 더 자세히 살펴보겠지만, pay-to-witness-public-key-hash(P2WPKH) 주소에서 비트코인을 사용할 때 필요한 scriptcode는 다음과 같습니다:`,
        paragraph_four: `...이 코드는 아래와 같은 비트코인 스크립트로 해석됩니다.`,
        paragraph_five: `scriptcode에 대해 더 알고 싶다면 <Link href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki" target="_blank" className="underline">BIP 143</Link>을 참고하세요.`,
        paragraph_six: `트랜잭션 원본 데이터는 다음 항목들을 순서대로 직렬화해서 만든 걸 ‘프리이미지(preimage)’라고 불러요:`,
        headings: {
          item_one: `Description(설명)`,
          item_two: `Name(이름)`,
          item_three: `Type(타입)`,
          item_four: `Size(크기)`,
        },
        table: {
          row_one: {
            item_one: `Transaction version, default 2`,
            item_two: `version`,
            item_three: `int`,
            item_four: `4`,
          },
          row_two: {
            item_one: `The dSHA256 of all outpoints from all inputs, serialized`,
            item_two: `bytes`,
            item_three: `bytes`,
            item_four: `32`,
          },
          row_three: {
            item_one: `The dSHA256 of all sequence values from all inputs, serialized`,
            item_two: `sequences`,
            item_three: `bytes`,
            item_four: `32`,
          },
          row_four: {
            item_one: `The serialized outpoint of the single input being signed `,
            item_two: `outpoint`,
            item_three: `bytes`,
            item_four: `36`,
          },
          row_five: {
            item_one: `The output script being spent from`,
            item_two: `scriptcode`,
            item_three: `bytes`,
            item_four: `(var)`,
          },
          row_six: {
            item_one: `The value in satoshis being spent by the single input being signed`,
            item_two: `value`,
            item_three: `int`,
            item_four: `8`,
          },
          row_seven: {
            item_one: `The sequence value of the single input being signed`,
            item_two: `sequence`,
            item_three: `int`,
            item_four: `4`,
          },
          row_eight: {
            item_one: `The dSHA256 of all outputs, serialized`,
            item_two: `outputs`,
            item_three: `bytes`,
            item_four: `32`,
          },
          row_nine: {
            item_one: `Transaction locktime, default 0`,
            item_two: `locktime`,
            item_three: `int`,
            item_four: `4`,
          },
          row_ten: {
            item_one: `Signature hash type, we will use 1 to indicate "ALL`,
            item_two: `sighash`,
            item_three: `int`,
            item_four: `4`,
          },
        },
        paragraph_seven: `마지막으로, 서명에 쓰이는 메시지는 이 모든 직렬화된 데이터를 더블 SHA-256한 값이에요.`,
        success: `digest() 메서드도 제대로 구현했어요. 멋져요!`,
      },
    },
    put_it_together_four: {
      hard: {
        title: `전체 내용 통합하기`,
        heading: `서명하기`,
        nav_title: `트랜잭션 서명하기`,
        paragraph_one: `이전 챕터에서는 ECDSA 서명 검증 코드를 작성했습니다. 이제 이 코드를 조금 바꿔서 유효한 서명을 만들어야 합니다. Transaction 클래스에 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">compute_input_signature(index: int, key: int)</span> 메서드를 추가하세요. 이 메서드는 입력 인덱스와 32바이트짜리 개인키를 받아요. 그리고 6단계에서 만든 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">digest()</span> 를 이용해 메시지 다이제스트를 계산한 다음, 정수 r과 s로 구성된 ECDSA 서명을 반환하면 돼요.`,
        paragraph_two: `ECDSA 서명 알고리즘에 대해 더 알고 싶다면 <Link href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" target="_blank" className="underline">이 페이지</Link>를 참고하세요. 또한 <Link href="https://www.secg.org/sec1-v2.pdf#subsubsection.4.1.3" target="_blank" className="underline">이 PDF 문서</Link>의 44페이지, 4.1.3절도 도움이 됩니다.`,
        paragraph_three: `비트코인 프로토콜에서는 서명 알고리즘에 한 가지 추가 조건이 있습니다. s 값은 반드시 '낮은 값'이어야 하며, 이는 곡선의 차수(order)를 2로 나눈 값보다 작아야 한다는 뜻입니다. 이 조건에 대해서는 <Link href="https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki#low_s" target="_blank" className="underline">BIP 146</Link> 문서에서 확인할 수 있습니다.`,
        success: `compute_input_signature() 메서드도 잘 만들었어요. 수고했어요!`,
      },
    },
    put_it_together_five: {
      hard: {
        title: `전체 내용 통합하기`,
        heading: `Witness 채우기`,
        nav_title: `Witness 채우기`,
        paragraph_one: `7단계에서 만든 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">sign_input(index: int, key: int)</span>를 호출하고, 반환값을 활용해서 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">compute_input_signature(index, key)</span>를 완성해보세요. 반환된 r, s 숫자는 DER(Distinguished Encoding Rules) 이라는 형식으로 인코딩되어야 하며, 이 인코딩 방식은 이미 구현되어 있습니다.`,
        paragraph_two: `비트코인 DER 서명 끝에 1바이트를 추가로 붙여야 합니다. 이 바이트는 'sighash type'을 나타냅니다. 지금은 항상 0x01을 사용하며, 이는 'SIGHASH ALL'입니다.`,
        paragraph_three: `이제 서명 데이터도 준비됐으니, 두 개 항목을 담은 Witness 객체를 만들어봐요. 하나는 서명 데이터, 다른 하나는 압축된 공개키입니다. 스택에는 서명을 먼저, 그다음 공개키를 넣습니다.`,
        paragraph_four: `이 witness stack 객체는 트랜잭션 객체의 witnesses 배열에 추가하면 됩니다.`,
        success: `sign_input() 메서드도 완벽해요! 정말 잘했어요!`,
      },
    },
    put_it_together_six: {
      hard: {
        title: `전체 내용 통합하기`,
        heading: `배운 내용 조합해보기`,
        nav_title: `배웠던 모든 내용을 합쳐 최종 트랜잭션을 만들어 봅시다!`,
        paragraph_one: `입력도 알고, 출력도 알았으니 이제 트랜잭션을 만들고 서명할 준비가 된 걸까요? 아직은 아니에요. 우리는 1.61 BTC를 입력으로 쓰고 있고, 이 중 1 BTC는 누군가에게 보내려는 거예요. 그럼 남은 0.61 BTC는 잔돈처럼 다시 우리 주소로 돌려보내야 해요.`,
        paragraph_two: `이제 트랜잭션 객체를 만들고, 거기에 서명하는 스크립트를 작성해보세요. 이 트랜잭션에는 입력 하나(1단계에서 확인한 UTXO)와 출력 두 개가 있어야 합니다:`,
        paragraph_three: `수수료(fee) 까먹지 마세요! 채굴자들이 블록에 포함시켜주도록 하려면, 잔돈에서 약간을 수수료로 내야 해요. 예를 들어, 원래 61,000,000 사토시였던 잔돈을 60,999,000 사토시로 줄이면 됩니다.`,
        paragraph_four: `모든 준비가 끝났어요! 마지막엔 <span className="text-green p-1 font-mono bg-[#0000004D] m-0.5 text-sm">serialize()</span> 결과를 반환하면 돼요. 이제 이건 유효하게 서명된 비트코인 트랜잭션이며, 네트워크에 전송해 미카 3000에게 필요한 금액을 보낼 수 있습니다.`,
        bullet_one: `미카 3000은 1 BTC(=100,000,000 사토시)를 주소 bc1qgghq08syehkym52ueu9nl5x8gth23vr8hurv9dyfcmhaqk4lrlgs28epwj로 받아요.`,
        bullet_two: `당신은 61,000,000 사토시를 자신의 주소 bc1qm2dr49zrgf9wc74h5c58wlm3xrnujfuf5g80hs로 돌려 받습니다.`,
        success: `해냈습니다! 드디어 트랜잭션을 완성했어요!`,
      },
    },
    outro_one: {
      title: `마무리`,
      nav_title: `챕터 완료`,
      heading: `해냈습니다!`,
      paragraph_one: `미카 3000에게 보답하기 위해 트랜잭션을 성공적으로 완성했습니다. 이제 이곳에서 할 일은 끝났으니, 반더풀의 섬에서는 어떤 일이 기다리고 있을지 함께 가볼까요?`,
    },
    book_a_call_one: {
      title: 'BDP와 통화 예약',
      nav_title: 'BDP와 통화 예약하기',
      heading: '비트코인 개발 프로젝트(BDP)와 통화해보는 건 어떨까요?',
      paragraph_one:
        '—미카 3000: “트랜잭션을 처음부터 직접 만든 거 정말 인상 깊었어. 공개키-개인키 조합으로 비트코인 주소를 만들고, 반더풀의 서명이 조작된 것임을 밝혀낸 걸 보면, 확실히 실력을 갖추고 있네.”',
      paragraph_two:
        '“혹시 비트코인 오픈소스 소프트웨어(BOSS)에 대해 더 이야기 나눠보고 싶지 않아? 내가 아는 <Link className="!underline" target="_blank" href="https://bitcoindevs.xyz" /> Bitcoin Dev Project </Link> 소속 사람들이 있어. 그들은 너처럼 똑똑한 개발자를 늘 찾고 있어. 함께 비트코인을 개발하고, 더 튼튼하고 안전하게 만들어 ‘단순한 돈 그 이상의 미래’를 지켜나가는 일이지.”',
      paragraph_three:
        '링크를 누르면 실제 Bitcoin Dev Project 멤버와 화상 통화를 예약할 수 있는 캘린더로 이동해요. 통화에서는 비트코인 오픈소스 프로젝트에 더 깊이 참여하는 방법이나 관련 커리어에 대해 이야기 나눌 수 있어요. 이건 Saving Satoshi 게임과는 완전히 별개라, 참여하지 않아도 게임에는 아무 영향 없어요.',
      button_text_one: '통화 예약하기',
      button_text_two: '게임 계속하기',
    },
    resources: {
      in_out: {
        input_class_heading: `입력 클래스`,
        input_class_paragraph_one: `임시 자료`,
        output_class_heading: `출력 클래스`,
        output_class_paragraph_one: `임시 자료`,
      },
      put_it_together: {
        building_a_transaction_heading: `트랜잭션 만들기`,
        building_a_transaction_paragraph_one: `임시 자료`,
      },
    },
  },
  chapter_seven: {
    title: `최고의 방어는 공격`,
    paragraph_one: `당신과 미카 3000은 비행기에서 낙하산으로 내려온 뒤, 듄버기(모래언덕용 경량차량)를 타고 이동하고, 마지막엔 자동 노 젓는 보트를 타고 섬 깊숙이 들어갑니다.`,
    intro_one: {
      title: `들어가며`,
      nav_title: `기지 침투`,
      paragraph_one: `당신은 동료들에게 반더풀의 보안 드론 부대가 걱정되지 않느냐고 물어봅니다.`,
      paragraph_two: `—홀로캣: “15분만 줘. 걔네는 사실상 새고, 나는 고양이야. 상대도 안 돼.”`,
      paragraph_three: `홀로캣은 날카로운 발톱을 뻗으며 반더풀의 드론 부대를 하나씩 처리합니다. 미카 3000은 검은 터틀넥, 장갑, 야간 투시경을 건네줍니다.`,
      paragraph_four: `—미카 3000: “하와이안 셔츠 입고 첩보 활동을 하겠다고? 무슨 생각이었어? 여긴 버려진 창고가 아니라 요새야. 아, 까먹을 뻔했네. 이 갈고리 도구도 가져가.”`,
      paragraph_five: `‘내가 지금 뭘 하고 있는 거지…’라는 생각이 스치는 가운데, 당신과 미카 3000은 성벽을 타고 올라갑니다. 그의 집 안은 비트코인을 주제로 한 예술 작품, 책, 종이 잡지들로 가득했어요. 그는, 아니 과거의 그는 진정한 비트코이너였습니다. 125년 전 채굴기들이 유리 진열장 안에 전시되어 있습니다. 그리고 그 순간 당신은 반더풀 작업실을 발견합니다.`,
    },
    intro_two: {
      nav_title: `제어실`,
      paragraph_one: `방은 엄청나게 넓고 어지럽혀져 있지만 구조는 꽤 체계적입니다. 한때 채굴자들이 빈 블록으로 네트워크를 마비시켰던 사건, 기억하시나요? 펼쳐진 노트들 안에서 반더풀이 사용한 백도어(backdoor) 설계도를 발견합니다. 결국 당신 생각이 맞았어요. 이 모든 건 거짓이었어요. 하지만 음모를 꾸미는 악당이 아닌, 더 이상 경쟁할 수 없었던 한 비트코인 신봉자의 절박한 거짓말이었습니다. 자신의 유산을 지키기 위해 반더풀은 채굴기들에 바이러스를 심었습니다.`,
      paragraph_two: `그 바이러스는 채굴자들이 사용하는 코드 일부를 바꿔칩니다. 채굴 풀이든 솔로든 상관없이 말이죠. 감염 대상은 블록을 구성하는 로직, 즉 트랜잭션을 모아 블록 템플릿을 만드는 부분이에요. 템플릿 자체는 합법적인 해시 연산 코드로 처리되지만, 트랜잭션이 하나도 없는 상태로 블록이 만들어져버리는 거예요.`,
      paragraph_three: `—홀로캣: "안타깝네. 반더풀 가문은 한때 위대했는데... 이렇게까지 무너지는 걸 보게 되다니, 너무 슬퍼."`,
    },
    intro_three: {
      nav_title: `소프트웨어 수정하기`,
      paragraph_one: `하지만 망가진 채굴 코드를 반더풀 서버에 그냥 둘 수는 없어요. 이 코드는 다른 채굴자들까지 계속 감염시킬 거예요. 당신이 직접 고쳐야 해요! 당신이 코드를 살펴보는 동안, 홀로캣은 미확인 트랜잭션으로 가득 찬 mempool 화면을 보여줘요. 이 코드는 하루라도 빨리 고치는 게 좋습니다.`,
    },
    mempool_transaction_one: {
      title: `블록 구성 요소`,
      nav_title: `블록 조립하기`,
      heading: `코드 챌린지`,
      python: {
        paragraph_one: `이 코드는 반더풀 서버에서 발견한 거예요. 지금은 JSON 파일에서 mempool 데이터를 불러와, 모든 미확인 트랜잭션을 MempoolTransaction 클래스 인스턴스로 메모리에 저장해요. 문제가 되는 기능은 <span className="text-green">assemble_block()</span>입니다. 반더풀이 의도적으로 망가뜨린 부분이죠. 코드를 그대로 실행해 보면 뭐가 잘못됐는지 바로 알 수 있어요.`,
      },
      javascript: {
        paragraph_one: `이 코드는 반더풀의 서버에서 발견한 것입니다. 현재 메모리풀을 JSON 파일에서 불러와, 모든 미확인 트랜잭션을 MempoolTransaction 클래스의 인스턴스로 메모리에 저장합니다. 반더풀이 고의로 망가뜨린 기능은 <span className="text-green">assembleBlock()</span>입니다. 이 코드를 그대로 실행해 보면, 문제가 바로 보일 것입니다.`,
      },
      paragraph_two: {
        a: `블록을 만들 땐 단순히 유효하기만 하면 안 돼요. 채굴자가 수수료 수익을 최대한 많이 얻을 수 있도록 구성해야 하죠. 그러려면 비트코인의 합의 규칙을 따라야 해요. 그 중 특히 중요한 두 가지 요소가 있어요:`,
        b: {
          text: `트랜잭션 가중치`,
          href: `https://chat.bitcoinsearch.xyz/?author=holocat&question=what%2520are%2520weighted%2520units`,
          question: `트랜잭션 가중치가 무엇일까요?`,
        },
        c: ` 그리고 `,
        d: {
          text: `트랜잭션의 정렬 순서`,
          href: `https://chat.bitcoinsearch.xyz/?author=holocat&question=what%2520order%2520do%2520transactions%2520need%2520to%2520be%2520in%2520a%2520block`,
          question: `블록 안에서 트랜잭션은 어떤 순서로 들어가야 할까요?`,
        },
        e: ` 이 두 요소는 블록 안에서 정해진 형식을 따라야 합니다.`,
      },
      paragraph_three: `이번 미션에서는 아래 내용을 전제로 해볼게요:`,
      bullet_one: `mempool에 있는 모든 트랜잭션은 이미 유효성 검사를 통과한 상태입니다.`,
      bullet_two: `코인베이스 트랜잭션과 블록 무게는 무시해도 됩니다.`,
      paragraph_four: `전체 mempool 원시 JSON 파일은 <Link href="https://github.com/saving-satoshi/resources/blob/main/chapter-7/mempool.json" target="_blank" className="underline">여기</Link>에서 확인 가능합니다.`,
      paragraph_five: `또는 아래 표에 정리된 데이터를 보면서 기본적인 패턴을 익혀도 좋아요.`,
      headings: {
        item_one: `트랜잭션 ID`,
        item_two: `수수료`,
        item_two_b: `(사토시)`,
        item_three: `무게`,
        item_three_b: `무게 단위(WU)`,
        item_four: `선행 트랜잭션`,
      },
      table_one: {
        footer: `나머지 트랜잭션 데이터를 보려면 <Link href="https://github.com/saving-satoshi/resources/blob/main/chapter-7/mempool.json" target="_blank" className="underline">여기</Link>에서 JSON 파일을 확인하세요.`,
      },
      poor: `블록은 유효하지만 수수료를 더 높일 수 있어요. 한 번 더 도전해보세요!`,
      good: `블록은 유효하지만 아직 최대 수수료는 아닙니다. 계속 도전할 수도 있고, 그냥 넘어가도 괜찮아요. 선택은 당신에게 있어요.`,
      success: `유효한 블록이에요! 수수료 최적화도 완벽하게 해냈어요.`,
    },
    outro_one: {
      title: `마무리`,
      nav_title: `챕터 완료`,
      heading: `해냈습니다!`,
      paragraph_one: `기지에서 무사히 빠져나온 당신은 집으로 돌아갑니다. 스캔들이 터지자 투자자들은 BitRey 주식을 마구 팔아치우고, 반더풀의 자산 가치는 곤두박질칩니다.`,
    },
    resources: {
      mempool_transaction_one: {
        bytes_v_weight_heading: `Bytes vs Weight Units`,
        bytes_v_weight_paragraph_one: `비트코인 블록을 만들 때 사용하는 '가중치 단위(WU)'와 '바이트(bytes)'는 서로 다른 방식으로 크기를 계산합니다.`,
        bytes_v_weight_subheading_bytes: `바이트(Bytes)`,
        bytes_v_weight_paragraph_two: `쉽게 말해, 트랜잭션 데이터를 저장하거나 전송할 수 있도록 바이트 형태로 바꿨을 때의 크기를 뜻해요. 세그위트(SegWit)가 도입되기 전에는 블록 크기가 바이트 기준으로 1MB까지만 허용됐습니다.`,
        bytes_v_weight_subheading_wu: `가중치 단위(Weighted Units)`,
        bytes_v_weight_paragraph_three: `가중치 단위(WU)는 세그위트가 도입될 때 함께 등장한 개념이에요. <Link href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#user-content-Other_consensus_critical_limits" target="_blank" className="undeline">BIP 141</Link>에서 제안됐으며 블록 안 공간을 공평하게 나누기 위해 만들어졌습니다. 특히 위트니스(witness) 데이터는 따로 떼서 계산합니다. 그래서 바이트로만 계산하는 것보다 더 정교합니다.`,
        bytes_v_weight_paragraph_four: `이번 과제에서는 '가중치 단위(WU)'로 블록 최대 크기와 트랜잭션 크기를 계산합니다. 블록 전체 가중치가 4,000,000 WU를 넘지 않도록 주의하세요. 넘으면 블록은 무효가 됩니다.`,
      },
    },
  },

  chapter_eight: {
    title: `2,100만`,
    paragraph_one: `당신의 활약 덕분에 사람들은 당신 이야기에 귀를 기울이기 시작했어요. 홀로캣의 코를 꾹 누르자, 데보라 청크가 직접 LARGE BIG NEWS 스튜디오로 와달라는 초대장을 보냅니다. 진실을 세상에 알리기 위해 버짓콥터를 타고 날아갑니다.`,
    intro_one: {
      title: `들어가며`,
      nav_title: `반더풀의 속임수`,
      paragraph_one: `—데보라 청크: “이 문서들은 토마스 반더풀이 했다고 주장되는 거짓말들을 역사적일 정도로 충격적으로 폭로하고 있어요. 사람들이 가장 궁금해하는 건 두 가지예요. 첫째, 이걸 혼자 해낸 건가요? 둘째, 정보를 어디서 얻었죠?”`,
      paragraph_two: `당신은 홀로캣 이야기만 합니다. 정보는 사토시 나카모토라고 주장하는 누군가가 당신과 미카 3000에게 직접 전달됐다고 설명합니다. 사실 그가 해커 집단일지도 모른다고 생각합니다. 이 마지막 말에 토마스 반더풀이 방송에 직접 전화를 걸어옵니다.`,
    },
    intro_two: {
      title: `들어가며`,
      nav_title: ` 반더풀의 분노`,
      paragraph_one: `—토마스 반더풀: “사토시 나카모토는 우리 가문이야! 방금 저 망나니가 한 말 들었어? 해커들과 한패라고 자백했잖아. 사토시 나카모토라는 이름만 도용해서 내 정당한 유산을 훔치려는 집단이지. 저 사기꾼은 블록 보상 폐지에 분노한 비트코인 지지자들의 정당한 시위를 방해하려고 거짓말을 퍼뜨리고 있어!”`,
      paragraph_two: `반더풀은 고풍스러운 욕까지 동원해가며 욕설을 마구 퍼붓습니다. 당신을 쥐새끼, 악당, 겁쟁이, 풋내기 등 별별 말로 부릅니다. 약간 불쌍하다는 생각도 듭니다. 그의 가문이 비트코인 역사에서 중요한 역할을 했던 건 사실입니다. 비록 사토시에 대한 주장은 뻔히 거짓말이지만요.`,
    },
    intro_three: {
      intro: `들어가며`,
      nav_title: `반더풀에 대한 의혹 제기`,
      paragraph_one: `—데보라 청크: “실례지만, 반더풀 씨. 사람들은 지금 비트코인 공급량이 조작된 건 아닌지 혼란스러워하고 있어요. 당신이 그 조작에 전혀 관여하지 않았다는 걸 증명할 수 있나요? 그리고 수상한 해커분, 당신과 함께한 홀로캣. 반더풀이 비트코인을 상대로 범죄를 저질렀다는 증거를 보여줄 수 있나요?”`,
    },
    building_blocks_one: {
      title: `기본 구성 블록`,
      nav_title: `체인의 끝 찾기`,
      paragraph_one: {
        a: `당신은 반더풀이 허용된 양을 넘겨 비트코인을 생성한 블록들을 채굴해왔다는 사실을 알고 있습니다. 이는 전체 공급량을 부풀리는 결과를 낳습니다. 이런 블록들은 비트코인 프로토콜에 하드코딩된 규칙을 위반하기 때문에 무효입니다. 그럼에도 불구하고 버그가 있거나 악의적으로 조작된 소프트웨어를 사용하는 일부 사용자들, 또는`,
        b: {
          text: `라이트 클라이언트`,
          href: `https://chat.bitcoinsearch.xyz/?author=holocat&question=what%2520are%2520light%2520clients%253F`,
          question: `라이트 클라이언트는 무엇일까?`,
        },
        c: ` 처럼 네트워크 데이터를 완전히 검증하지 않는 사용자들은 여전히 속을 수 있습니다.`,
      },
      paragraph_two: `또한 당신은 네트워크 어딘가에 창세 블록부터 오늘날의 “체인 팁”까지 모든 거래와 블록이 규칙을 정확히 따른 유효한 체인이 존재한다는 것도 알고 있습니다. 이 체인이야말로 진짜이며, 의미 있는 유일한 체인이자, 2,100만 비트코인 공급량이 온전히 보존된 단 하나의 체인입니다.`,
      paragraph_three: `전 세계가 지켜보는 생방송이 진행 중입니다. 당신은 가장 긴 유효한 블록체인을 찾아야 하고, 그 체인을 통해 비트코인 공급이 제대로 유지되고 있다는 걸 증명해야 합니다. 그리고 이 과정에서 반더풀이 어떻게 비트코인 네트워크를 무효 블록 지뢰밭으로 만들어버렸는지도 밝힐 수 있게 될 겁니다.`,
    },
    building_blocks_two: {
      title: `기본 구성 블록`,
      nav_title: `비트코인 블록 트리`,
      paragraph_one: `모든 블록은 하나의 이전 블록을 가지지만, 다음 블록은 여러 개일 수 있습니다. 그래서 비트코인 블록 구조는 ‘체인’이라기보다는 실제로는 ‘나무’처럼 여러 갈래로 뻗어나가는 구조에 가깝습니다. 어떤 가지들은 막다른 길이고, 또 어떤 가지들은 반더풀의 장난질 때문에 무효가 되었습니다. 이제 당신이 그걸 증명해야 합니다.`,
      paragraph_two: `이 복잡한 미로 어딘가에는 창세 블록부터 오늘의 최신 블록까지 이어지는 길이 존재합니다. 그 길을 찾아서, 가장 유효한 체인의 마지막 블록이 어떤 건지 데보라 청크에게 알려줘야 합니다… 다음 광고가 시작되기 전에!`,
      paragraph_three: `이 비트코인 블록체인의 ‘나무’ 구조를 보여주는 시각화는 각 블록이 하나의 부모 블록만 가지지만, 여러 자식 블록을 가질 수 있음을 보여줍니다. 각 블록에는 자신의 해시값과 부모의 (<span className="p-1 font-mono m-0.5 text-sm">해시값(prev)</span>)이 표시됩니다.`,
      paragraph_four: `붉은색으로 표시된 블록들은 무효입니다. 창세 블록에서 시작해서 가장 길게 이어진 초록색 경로는 '가장 많은 작업'이 들어간 체인이자 '가장 유효한' 체인을 뜻합니다. 이 경로에 있는 블록 안 거래만이 진짜 ‘확정된’ 거래입니다. 이외의 유효한 블록들(파란색)은 자식 블록이 적어 메인 체인보다 짧고, 결국 <span className="italic">*스테일 팁(stale tips)*</span>이라 불리는 지점에서 멈추게 됩니다.`,
    },
    building_blocks_three: {
      title: `기본 구성 블록`,
      nav_title: `비트코인 API 살펴보기`,
      heading: `비트코인 API`,
      paragraph_one: `이 질문에 답하려면 비트코인 풀 노드와 JSON-RPC API를 통해 직접 통신해야 합니다. 다행히도 <span className="p-1 font-mono bg-[#0000004D] m-1">bitcoin_rpc</span>라는 라이브러리가 이미 불러와져 있습니다. 이 라이브러리는 스크립트에서 풀 노드로 안전하게 HTTP 연결을 만들고, 명령을 실행하고 결과를 반환합니다. 현재 풀 노드는 '프루닝(pruning)' 모드로 설정되어 있어서 최근 300개의 블록만 확인할 수 있습니다. 반더풀이 벌인 최근 사건들을 조사하기엔 충분합니다.`,
      paragraph_two: `먼저 이 API에 익숙해지는 것부터 시작해봅시다. 이 라이브러리에는 하나의 필수 인자 <span className="p-1 font-mono bg-[#0000004D] m-1">(method)</span> (a string)와 하나의 선택 인자 <span className="p-1 font-mono bg-[#0000004D] m-1">(params)</span>를 받는 함수가 포함되어 있습니다:`,
      paragraph_three: `이 API엔 편리한 'help' 메서드도 있습니다. 사용 가능한 명령어들을 확인하려면 도움말을 요청해보세요. 그리고 현재 네트워크 난이도를 출력해서 이번 과제를 통과해봅시다.`,
      success: `API를 멋지게 탐색했습니다. 이제 다음 단계로 넘어가봅시다.`,
    },
    building_blocks_four: {
      title: `기본 구성 블록`,
      nav_title: `가장 적은 거래가 담긴 블록 찾기`,
      heading: `블록 데이터`,
      paragraph_one: `모든 비트코인 풀 노드는 데이터베이스를 가지고 있습니다. 여기에 블록들이 저장되고, 해시값을 기준으로 인덱싱됩니다. 또, 체인의 각 높이마다 어떤 블록들이 후보인지 추적하기 위해 height -> [block hashes] 형태의 또 다른 인덱스도 사용합니다.`,
      paragraph_two: `JSON-RPC API는 블록 데이터를 JSON 객체 형태로 반환하는데, 그 안에는 <span className="p-1 font-mono bg-[#0000004D] m-1">txs</span>라는 속성이 있습니다. 이 속성은 블록 안에 포함된 거래(트랜잭션) 객체들을 배열로 담고 있습니다.`,
      paragraph_three: `체인 높이 6929996 에 있는 모든 블록 후보를 가져와서, 그 중에서 거래 수가 가장 적은 블록의 해시를 출력하세요.`,
      success: `아주 잘했습니다!`,
    },
    building_blocks_five: {
      title: `기본 구성 블록`,
      nav_title: `거래 수수료 구하기`,
      heading: `거래 데이터`,
      paragraph_one: `블록에 포함된 각 거래는 JSON 형식이며,  'inputs'과 'outputs'은 각각 배열 형태로 구성되어 있습니다. 이 두 배열은 각각 UTXO, 즉 ‘코인’이라고 불리는 객체들의 목록입니다. 각 코인 객체는 사토시 단위로 표현된 value 속성에 포함돼 있습니다.`,
      paragraph_two: `'inputs' 배열은 이 거래에서 ‘소모된’(즉, 없어진) 코인들이고, 'outputs' 배열은 새로 ‘생성된’ 코인들입니다. 챕터 6에서 배운 것처럼, 채굴자가 블록에 거래를 포함하도록 유도하기 위해 수수료를 지불합니다. 이 수수료는 입력 값 전체에서 출력 값 전체를 뺀 차액입니다.`,
      paragraph_three: `즉, 거래 안으로 들어왔지만 다시 나가지 않은 비트코인은 전부 채굴자가 가져갈 수 있다는 뜻입니다.`,
      paragraph_four: `다음 txid를 가진 트랜잭션이 있습니다:`,
      paragraph_five: `이 트랜잭션은 다음 블록 해시에 포함되어 있습니다:`,
      paragraph_six: `해당 트랜잭션의 수수료를 사토시 단위로 출력하세요.`,
      success: `완벽합니다!`,
    },
    building_blocks_six: {
      title: `기본 구성 블록`,
      nav_title: `보조금 구하기`,
      heading: `코인베이스 거래`,
      paragraph_one: `모든 블록에서 첫 번째 거래는 ‘코인베이스 거래’라고 불립니다. 코드에서는 txs[0]으로 표시되고, 보통 '0번 거래'라고도 부릅니다. 이 거래는 몇 가지 특별한 성질이 있습니다. 첫째, 입력값이 없습니다. 기존 코인을 쓰지 않고 새로 만들어지는 비트코인이기 때문입니다. 둘째, 출력값은 프로토콜에 의해 엄격하게 정해져 있습니다 (반더풀이 뭐라 하든 말이죠!). 이 거래를 통해 채굴자는 거래 수수료를 가져가고, 동시에 새로운 비트코인을 생성할 수 있습니다.`,
      paragraph_two: `블록 안의 거래 수수료 총합은 계산하기 쉽습니다. 하지만 ‘보조금(subsidy)’이라는 값은 어디서 나오는 걸까요? 네트워크에 참여하는 모든 노드들은 어떻게 ‘지금 이 시점에 채굴자가 생성할 수 있는 비트코인 양’을 똑같이 알고 있는 걸까요?`,
      paragraph_three: `이건 사토시 나카모토가 설계한 알고리즘입니다. 비트코인 시스템이 시작된 이래로 단 한 번도 바뀌지 않은 핵심 규칙입니다:`,
      list_one: `2009년에 생성된 첫 번째 블록(블록 #1)부터, 보조금은 50 BTC (또는 5,000,000,000 사토시)였습니다.`,
      list_two: `그리고 210,000 블록마다 보조금이 절반으로 줄어듭니다.`,
      paragraph_four: `예를 들어 블록 높이 209,999에서는 보조금이 50 BTC였고, 바로 다음 블록인 210,000에서는 25 BTC로 줄었습니다. 이런 방식으로 총 32번의 '반감기(halving)'를 거치면 마지막에는 보조금이 단 1사토시가 되고, 마지막 반감기 이후에는 완전히 0이 됩니다.`,
      paragraph_five: `그리고 그 마지막 반감기가 바로 어제였습니다!`,
      paragraph_six: `다음 함수를 구현해보세요. 이 함수는 블록 높이를 인자로 받아, 해당 블록의 보조금 값을 사토시 단위로 반환해야 합니다.`,
      success: `get_subsidy 함수가 완벽합니다! 정말 잘하셨습니다!`,
    },
    building_blocks_seven: {
      title: `기본 구성 블록`,
      nav_title: `유효한 블록 찾기`,
      heading: `이 말썽꾸러기 반더풀 같으니!`,
      paragraph_one: `6929851 높이에 있는 블록 후보는 총 4개입니다. 이 중 오직 하나만이 유효한 블록이고, 나머지 셋은 반더풀의 조직이 비트코인 공급량을 무분별하게 늘리려는 시도에서 채굴한 가짜 블록들입니다.`,
      paragraph_two: `이전 과제에서 만든 블록 보조금 계산 함수와 JSON-RPC API를 활용해서, 블록 후보가 유효한지 확인하는 함수를 작성해보세요. 방법은 간단합니다. 코인베이스 출력 값이 올바른지만 확인하면 됩니다. 조건을 만족하면 true를 반환하도록 하세요.`,
      paragraph_three: `6929851 높이에서 유효한 블록을 어떻게 찾아내는지를 아래 예시가 보여줍니다:`,
      success: `validate block 함수가 아주 훌륭해요! 멋지게 해냈어요!`,
    },

    building_blocks_eight: {
      title: `기본 구성 블록`,
      nav_title: `실전 시간!`,
      heading_one: `실전 시간!`,
      paragraph_one: `카메라가 돌아가며 전 세계 20억 명이 생중계를 지켜보고 있습니다. 다음 광고까지 몇 분밖에 남지 않았습니다. 데보라 청크는 땀을 뻘뻘 흘리고 있고, 왠지 모르게 홀로캣도 땀을 흘리고 있습니다. 전화 저편 어딘가에서 반더풀도 땀을 흘리고 있겠죠. 지금이 바로 당신의 순간입니다.`,
      paragraph_two: `6929851 높이에서 찾은 유효 블록 이전 블록부터 시작해서, 가능한 한 가장 긴 유효한 블록 체인을 찾아보세요. 유효한 체인에 포함된 블록 해시들을 배열로 저장하면 됩니다. 동시에 반더풀이 비트코인을 망치려고 얼마나 애썼는지도 보여주기 위해, 발견한 무효 블록들도 배열로 따로 저장하세요. 무효 블록 해시들은 순서가 상관없지만, 유효한 체인은 반드시 6929850 블록의 해시부터 시작해서 블록 높이별로 체인 팁까지 하나씩 연결되어 있어야 합니다.`,
      paragraph_three: `반더풀은 교묘합니다! 무효 블록 위에 유효 블록을 얹기도 하고, 짧은 유효 체인 위에 무효 블록을 덧씌우기도 했습니다. 완전히 미로 같은 지뢰밭입니다. 블록체인 구조를 따라가다 보면 여러 개의 유효한 가지(branch)를 동시에 추적해야 할 수도 있습니다. 유효한 부모 블록을 가진 유효한 블록이라도, 그 체인이 가장 길지 않다면 최종 체인에는 포함되지 않을 수 있습니다. 결국엔, 가장 높은 위치에 있는 유효 블록 하나만 남게 될 겁니다.`,
      paragraph_four: `기억하세요! JSON API가 반환하는 블록 객체에는 'prev'라는 속성이 있는데, 이 속성은 해당 블록의 부모 블록 해시를 알려줍니다:`,
      heading_two: `블록이 유효하다고 인정되려면:`,
      paragraph_five: `그 블록의 코인베이스 출력값이 '보조금 + 총 거래 수수료'와 정확히 일치해야 합니다.`,
      heading_three: `그리고`,
      paragraph_six: `그 블록은 반드시 다른 유효한 블록의 자식 블록이어야 합니다. 그래야 전체적으로 유효한 체인이 되는 겁니다.`,
      paragraph_seven: `마지막에는 'valid'와 'invalid'라는 두 배열을 포함한 JSON 객체를 반환하세요:`,
      success: `showtime 함수가 훌륭하게 작동합니다! 정말 잘하셨습니다!`,
    },
    outro_one: {
      title: `마무리`,
      nav_title: `챕터 완료`,
      heading: `생방송에서 잘 해냈습니다!`,
      paragraph_one: `당신은 가장 긴 체인을 찾아내고, 모두에게 그 진실을 입증했습니다! 무효 블록의 목록도 놀라울 만큼 길었습니다. 반더풀은 자신이 보조금을 몰래 끼워 넣은 블록들을 사람들이 받아들이게 하려고 온갖 술수를 부렸지만, 비트코인의 규칙은 바꿀 수 없었습니다. 우리가 봤듯이, 어떤 블록이 체인에 있다고 해서 반드시 유효하다는 건 아닙니다. 이제 당신은 반더풀의 거짓말을 폭로하는 데 한 걸음 더 다가섰습니다. 물론 반더풀은 데보라 청크의 마지막 질문에 아무 대답도 하지 못했습니다.`,
    },
    resources: {
      building_blocks_three: {
        tip: `사용 가능한 명령어들이 어떤 게 있는지 감을 잡기 위해, 먼저 이 명령어를 실행해보세요.`,
        rpc_heading: `RPC 명령어`,
        rpc_paragraph_one: `RPC 명령어는 클라이언트가 서버에 요청을 보내 프로그램과 상호작용할 수 있게 해주는 인터페이스입니다. 클라이언트는 요청 시 필요한 파라미터를 함께 보내 원하는 작업을 지정할 수 있습니다.`,
      },
      building_blocks_four: {
        block_data_heading: `블록 데이터`,
        block_data_paragraph_one: `비트코인의 본질은 거래 내역을 기록한 장부, 즉 전체 거래 목록입니다. 이 모든 거래는 블록 단위로 정리되어 있고, 각 블록은 창세 블록부터 순서대로 이어져 있습니다.`,
      },
      building_blocks_five: {
        transaction_data_heading: `거래 데이터`,
        transaction_data_paragraph_one: `각 거래에는 고유한 정보들이 담겨 있습니다. 이를 통해 다른 거래들과 구분할 수 있고, 비트코인이 어떤 입력과 출력을 거쳐 얼마나 이동했는지도 명확하게 알 수 있습니다.`,
      },
      building_blocks_six: {
        block_subsidy_heading: `블록 보조금`,
        block_subsidy_paragraph_one: `블록 보조금은 새로 생성된 블록의 코인베이스에서 새롭게 발행되는 비트코인의 양을 의미합니다. 비트코인은 총 발행량이 약 2,100만 개로 제한되어 있기 때문에, 이를 맞추기 위해 보조금이 점점 줄어들도록 수학적으로 설계되어 있습니다. 아래 수식은 비트코인에서 이 보조금이 어떻게 줄어드는지를 시각화한 겁니다.`,
        block_subsidy_paragraph_two: `이 수식이 어떤 의미일까요? 먼저, 창세 블록의 코인베이스 보상은 50 BTC였고, 수식 오른쪽 분자의 숫자가 바로 그 수치를 의미합니다 그리고 분모는 ‘반감기’마다 보상이 얼마나 줄어드는지를 나타내는데, 이 경우 2로 나눠져서 보상이 절반으로 줄어듭니다. 비트코인은 시간 개념이 없고 블록 단위로만 계산하기 때문에, 반감기를 210,000 블록마다 한 번씩으로 설정합니다. 마지막으로, 반감기마다 보조금이 얼마나 줄어드는지를 나타내기 위해 2를 현재 반감기의 지수로 올리는 구조로 되어 있습니다. 이렇게 해서 총 32번의 반감기를 거쳐 보조금은 0이 됩니다.`,
      },
      building_blocks_seven: {
        validating_heading: `블록 검증`,
        validating_paragraph_one: `블록을 검증하는 일은 네트워크의 안정성과 신뢰성을 지키는 데 매우 중요합니다. 각 블록은 이전 블록들의 거래를 기반으로 만들어지기 때문에, 과거 블록 중 하나라도 무효로 밝혀지면 이후에 이어진 수많은 블록들이 전부 의심을 받게 됩니다. 그만큼 검증은 신중하게 이루어져야 합니다.`,
      },
      building_blocks_eight: {
        showtime_heading: `체인 검증하기`,
        showtime_paragraph_one: `비트코인 블록체인을 검증하는 일은 네트워크 전체의 보안과 무결성을 지키는 핵심 과정입니다. 모든 거래는 채굴자들에 의해 검증되어야 하며, 네트워크에서 정한 합의 규칙을 따르는지 확인해야 합니다. 이 과정이 있기 때문에 이중 지불이나 사기를 방지할 수 있고, 중앙 기관 없이도 누구나 시스템을 신뢰할 수 있게 됩니다. 게다가 이 과정을 통해 모든 거래가 공개 장부에 기록되므로, 누구나 거래 내역을 검토하고 감사할 수 있는 투명성도 보장됩니다.`,
      },
    },
  },

  chapter_nine: {
    title: `믿지 말고, 검증하라.`,
    paragraph_one: `정말 아슬아슬한 타이밍에, 당신은 반더풀이 무효 블록들로 비트코인 네트워크를 혼란에 빠뜨리려 했다는 사실을 전 세계에 증명했습니다. 광고가 방송되는 사이, 스튜디오의 방송팀은 다음 코너를 준비하고 있습니다.`,
    intro_one: {
      title: `들어가며`,
      nav_title: `협박`,
      paragraph_one: `모두가 환호하고, 모두가 웃고 있습니다. 하지만 단 한 사람, 전혀 기쁘지 않은 사람이 있습니다. 키가 크고 말쑥하게 차려입은 회색 머리의 남자—당신은 그를 한눈에 알아봅니다. 군중이 갈라지고, 당신은 그를 처음으로 마주하게 됩니다. 바로, 반더풀입니다!`,
      paragraph_two: `그는 주먹을 꽉 쥐고 있습니다. 당신은 그의 사업을 망쳐놨고, 그의 가족이 수년간 벌여온 사기극을 폭로해버렸습니다. 그가 입을 열자마자 내뱉은 첫마디: “남은 평생, 매일 널 고소하겠다. 무한대로 말이지.”`,
    },
    intro_two: {
      title: `들어가며`,
      nav_title: `타협점 찾기`,
      paragraph_one: `반더풀이 소리를 지르고 있는 사이, 한 프로듀서가 다가와 전 세계 시청자들이 당신에게 비트코인과… 칼조네(*이탈리아 요리)를 기부하고 싶어 한다고 전합니다. 데보라는 당신에게 지갑 주소를 알려달라고 요청합니다.`,
      paragraph_two: `이 말에 반더풀은 더욱 분노합니다. 기부금을 자신과 나누지 않으면, 무한대의 소송으로 당신을 질식시키겠다고 협박합니다. (그게 가능한지는 모르겠지만요.)`,
      paragraph_three: `반더풀과 기부금을 나누는 건 말이 안 됩니다. 이 돈은 반더풀이 비트코인을 해치려 한 걸 폭로한 당신에게 고마움을 표하고자 사람들이 보내는 겁니다. 곰곰이 생각해보니, 그는 돈이 필요한 게 아니라, 자신이 졌다는 사실이 받아들이기 힘든 것 같습니다. 순간, 그가 조금 안쓰럽게 느껴지기도 합니다. 이제 그는 완전히 막다른 골목에 몰려버렸습니다.`,
      paragraph_four: `당신의 마음을 읽기라도 한 듯, 데보라 청크가 끼어듭니다. 그녀는 반더풀이 일부 기부금을 보내고 싶은 자선단체가 있는지 묻습니다. 놀랍게도 반더풀은 어린이들을 돕는 비영리 단체인 'Lil Bits 재단'을 열정적으로 설명합니다.`,
      paragraph_five: `반더풀의 얼굴빛은 허옇게 질렸다가 붉어지고, 다시 진한 자줏빛으로 가라앉습니다. 당신은 그와 함께 비트코인 스크립트 계약을 작성하기 시작합니다. 이 계약에서 반더풀은 Lil Bits 재단에 자금을 전달하는 책임을 맡게 되고, 당신과 반더풀이 서로를 신뢰하지 않더라도, 합의된 방식과 시점에 따라 둘 다 이 주소에서 자금을 사용할 수 있도록 설정합니다.`,
    },
    opcodes_one: {
      title: `연산 코드 (OpCodes)`,
      nav_title: `비트코인 스크립트`,
      heading: `비트코인 스크립트`,
      paragraph_one: `챕터 6에서 비트코인 스크립트를 잠깐 언급했었습니다. 당시에는 별도로 깊이 들어가지 않았는데, 그 이유는 당신이 사용했던 코인들이 아주 단순한 구조로 잠겨 있었기 때문입니다—하나의 서명만 있으면 되고, 그걸 공개키로 검증하는 기본적인 스크립트였죠. 그런데 이제부터는 좀 더 흥미로울 겁니다.`,
      paragraph_two: `비트코인 출력(output)에는 두 가지 중요한 요소가 있습니다: 스크립트와 스택입니다.`,
      paragraph_three: `이제 이 두 개념을 먼저 전체적인 관점에서 간단히 살펴볼 겁니다.`,
    },
    opcodes_two: {
      title: `연산 코드 (OpCodes)`,
      nav_title: `비트코인 스택`,
      heading: `스택(Stack)`,
      paragraph_one: `책이 쌓여 있는 더미 📚를 한번 떠올려보세요. 책을 더 추가하고 싶다면 맨 위에 얹는 수밖에 없습니다. 다른 자리는 없어요. 책을 읽고 싶다면 맨 위에 있는 책만 꺼낼 수 있습니다. 여러 권을 읽고 싶어도 꼭 맨 위부터 하나씩 꺼내야 합니다. 컴퓨터에서 말하는 ‘스택’도 비슷한 개념입니다. 데이터를 담은 배열 같은 구조인데, 두 가지 기본 동작을 합니다:`,
      paragraph_two: `<span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_PUSH</span> – 스택 맨 위에 아이템 하나를 추가합니다.`,
      paragraph_three: `<span className="text-[#3DCFEF] w-fit rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_POP</span> – 스택 맨 위에 있는 아이템 하나를 꺼내서 처리합니다.`,
      subheading_one: `예시:`,
      stack_list_one: `현재 스택 상태: <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">[]</span>`,
      stack_list_two: `숫자 1을 푸시하면: <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">[1]</span>`,
      stack_list_three: `숫자 2를 푸시하면: <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">[1, 2]</span>`,
      stack_list_four: `POP을 하면 맨 위 아이템이 빠지고 남은 상태: <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">[1]</span>`,
      paragraph_four: `스택에 먼저 들어간 아이템이 나중에 나옵니다. 그러니까 스크립트가 처리할 때 가장 마지막에 처리되는 겁니다. 그래서 스택은 ‘거꾸로 동작하는’ 느낌이 들죠. 스택에서 제일 먼저 보이는 게, 사실 스크립트의 끝에서 필요하게 되는 정답일 수도 있습니다.`,
      paragraph_five: `비트코인 트랜잭션 출력을 사용할 때, 필요한 정보들은 입력의 witness 섹션에 들어 있습니다 (챕터 6에서 봤죠). 이 정보들은 스크립트가 실행되기 전에 스택에 먼저 푸시됩니다. 우리는 이걸 “초기 스택(INITIAL STACK)”이라고 부릅니다. 왜 중요하냐고요? 이게 바로 스크립트를 해제해서, 코인을 쓸 수 있게 해주는 ‘열쇠’ 역할을 하기 때문입니다!`,
    },
    opcodes_three: {
      title: `연산 코드 (OpCodes)`,
      nav_title: `OpCodes`,
      heading: `OpCodes`,
      paragraph_one: `스크립트는 일련의 명령어들이 순차적으로 실행되며, 스택 위의 데이터들을 조작하는 구조입니다. 스크립트 실행이 끝나면, 스택에는 '정확히 하나의 0이 아닌 값(참 값)'만 남아 있어야 합니다. 그렇지 않으면 스크립트 전체가 무효로 간주되고, 비트코인 거래도 무효가 됩니다. 비트코인 스크립트 언어에는 100개가 넘는 명령어, 즉 “연산 코드(opcode)”가 있습니다. 이번 과제에서는 그중 일부만 사용해볼 겁니다.`,
      paragraph_two: `예를 들어 비트코인을 잠글 때, “1 + 2 = ?” 같은 단순한 수학 문제를 사용한다고 해봅시다. 이 문제의 정답을 아는 사람만이 코인을 쓸 수 있게 되는 겁니다.`,
      paragraph_three: `그럴 때 사용하는 스크립트는 이렇게 생겼습니다:`,
      paragraph_four: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_1 OP_2 OP_ADD OP_EQUAL</span>`,
      paragraph_five: `이 스크립트는 해시된 다음, bech32 형식으로 인코딩되어 주소가 됩니다. 이 주소로 다른 사람이 코인을 보낼 수 있게 되죠.`,
    },
    opcodes_four: {
      title: `연산 코드 (OpCodes)`,
      nav_title: `스택 기반 풀이`,
      heading: `스택 기반 풀이`,
      paragraph_one: `이 스크립트를 풀기 위해 필요한 스택 구성은 다음과 같습니다. 코인을 쓰기 위한 트랜잭션에는 이 모든 요소들이 포함되어 있어야 하고, 해당 입력(input)의 witness 섹션에 들어가게 됩니다. 이제 한 단계씩 함께 살펴보겠습니다:`,
      table_one: {
        headings: {
          item_one: `단계`,
          item_two: `스택 상태`,
          item_three: `스크립트 실행`,
        },
      },
      subheading_one: `설명`,
      stack_list_one: `초기화 단계: 자금을 담고 있는 트랜잭션 출력과, 그 자금을 사용하려는 트랜잭션 입력이 함께 실행됩니다.`,
      stack_list_two: `1단계: <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_1</span>이 숫자 "1"을 스택에 푸시합니다.`,
      stack_list_three: `2단계: <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_2</span>이 숫자 "2"를 스택에 푸시합니다.`,
      stack_list_four: `3단계: <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ADD</span>는 스택에서 두 값을 꺼내 더한 결과를 다시 스택에 푸시합니다.`,
      stack_list_five: `4단계: <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_EQUAL</span>은 스택에서 두 개의 아이템을 꺼내 비교 결과(참/거짓)를 다시 스택에 푸시합니다.`,
      paragraph_two: `스크립트 실행이 끝나면, 스택에는 참(TRUE) 하나만 남습니다. 이걸로 코인을 사용할 수 있게 됩니다!`,
      paragraph_three: `만약 이 예제에서 숫자 4로 시작했다면 어떻게 됐을까요? 그럴 경우 OP_EQUAL이 거짓(FALSE)을 반환하게 되고, 코인을 쓸 수 없게 됩니다. 이번 과제들에서는 아주 제한된 범위의 연산 코드들만 사용할 예정인데, 그 코드를 주제별로 하나씩 소개할 겁니다.`,
    },
    opcodes_five: {
      title: `연산 코드 (OpCodes)`,
      nav_title: `기본 산술 연산`,
      heading: `기본 연산`,
      paragraph_one: `비트코인 스크립트는 간단한 산술 연산을 할 수 있습니다. 수학 문제를 이용해 코인을 잠글 수도 있지만… 계산만 할 수 있다면 누구나 그 코인을 가져갈 수 있어요! 다시 말해, 이런 방식은 메인넷에서는 절대 사용하지 마세요.`,
      subheading_one: `스택에 숫자나 데이터를 푸시하는 연산 코드들`,
      opconstants_list_one_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_0</span>`,
      opconstants_list_one_paragraph: `숫자 0을 스택에 푸시합니다.`,
      opconstants_list_two_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_1</span>`,
      opconstants_list_two_paragraph: `숫자 1을 스택에 푸시합니다.`,
      opconstants_list_three_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_2</span>`,
      opconstants_list_three_paragraph: `숫자 2를 스택에 푸시합니다.`,
      opconstants_list_four_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_3</span>`,
      opconstants_list_four_paragraph: `숫자 3을 스택에 푸시합니다.`,
      opconstants_list_five_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_DUP</span>`,
      opconstants_list_five_paragraph: `스택 맨 위 값을 복사해 같은 값을 하나 더 푸시합니다.`,
      opconstants_list_six_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_PUSH</span>`,
      opconstants_list_six_paragraph: `스크립트에 명시된 값을 스택에 푸시합니다. 예: SIG(alice), PUBKEY(alice), HASH256(secret), secret 등. 여기서 소문자로 된 단어들은 실제 데이터를 의미하고, 해석기(interpreter)에서는 이 값들을 실제 서명, 공개키, 해시, 원본 데이터처럼 처리하게 됩니다.`,
      subheading_two: `산술 연산을 수행하는 연산 코드`,
      oparithmetic_list_one_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ADD</span>`,
      oparithmetic_list_one_paragraph: `스택에서 두 개의 값을 꺼내 더한 뒤, 그 합계를 다시 스택에 푸시합니다.`,
      oparithmetic_list_two_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_EQUAL</span>`,
      oparithmetic_list_two_paragraph: `스택에서 두 개의 값을 꺼내 서로 같은지 비교하고, 비교 결과(참/거짓)를 스택에 푸시합니다.`,
      oparithmetic_list_three_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_EQUALVERIFY</span>`,
      oparithmetic_list_three_paragraph: `OP_EQUAL과 같지만, 두 값이 다르면 곧바로 오류를 내고 스크립트 실행을 중단합니다.`,
      paragraph_two: `코인을 쓰기 위해 필요한 초기 스택 값을 입력해보세요.`,
    },
    opcodes_six: {
      title: `연산 코드 (OpCodes)`,
      nav_title: `암호 기술로 해독하기`,
      heading: `간단한 암호 기술`,
      paragraph_one: `이전 챕터들에서 ‘공개키 해시로 지급(Pay to Public Key Hash)’ 방식을 배웠습니다. 세그윗(SegWit)이 등장하기 전까지 수백만 건의 비트코인 트랜잭션에서 이 방식이 사용되었고, 이후에는 더 간결한 방식으로 바뀌었습니다. 이 방식은, 공개키의 해시값으로 코인을 잠그고, 해당 해시와 일치하는 공개키와 그 공개키로 생성된 서명을 제시함으로써 코인을 사용할 수 있도록 합니다.`,
      subheading_one: `간단한 암호 연산을 위한 연산 코드`,
      opcryptography_list_one_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm h-fit">OP_HASH256</span>`,
      opcryptography_list_one_paragraph: `스택에서 항목 하나를 꺼내 두 번의 SHA256 해시를 수행하고, 그 결과를 다시 스택에 푸시합니다. 이 연산은 예제에서 문자열로 표현됩니다. 예: 스크립트 OP_1 OP_HASH256 → 결과 스택: [HASH256(1)]`,
      opcryptography_list_two_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm h-fit">OP_CHECKSIG</span>`,
      opcryptography_list_two_paragraph: `스택에서 두 항목을 꺼내 서명을 검증합니다. 첫 번째 항목은 PUBKEY(...) 형식의 공개키, 두 번째 항목은 SIG(...) 형식의 서명이어야 합니다. 괄호 안 문자열이 일치하면 유효한 서명으로 간주되어 TRUE가, 다르면 FALSE가 스택에 푸시됩니다.`,
      paragraph_two: `스크립트에서 코인을 사용하기 위해 필요한 초기 스택 값을 입력하세요.`,
    },
    opcodes_seven: {
      title: `연산 코드 (OpCodes)`,
      nav_title: `멀티시그`,
      heading: `멀티시그`,
      paragraph_one: `멀티시그(Multisignature) 방식은 여러 개의 공개키 목록과, 유효한 지출을 위해 필요한 서명 수를 지정하는 정책입니다.흔히 "m-of-n" 방식이라고 부르며, n개의 공개키 중 m개의 서명이 필요하다는 뜻입니다. m, n, 그리고 공개키 목록은 일반적으로 락킹 스크립트에 포함되고, 송금자는 필요한 개수만큼의 올바른 서명만 입력하면 됩니다.`,
      paragraph_two: `이때 홀로캣이 사토시 나카모토의 사전 녹화 메시지를 들고 나타납니다.`,
      paragraph_three: `"안녕하세요. 제가 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_CHECKMULTISIG</span>을 구현할 때 실수로 버그를 남기고 말았어요. 이 명령어는 스택에서 아무 쓸모도 없는 항목을 하나 더 꺼내버립니다. 그러니까… 음, 실수였어요. 하지만 이 코드는 비트코인의 합의 규칙에 영향을 주기 때문에, 과거·현재·미래의 모든 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_CHECKMULTISIG</span> 연산에는 반드시 ‘더미(dummy)’ 항목이 포함돼야 합니다. 이걸 빼먹으면 멀티시그 코인을 쓸 수 없게 되니까 꼭 기억하세요.`,
    },
    opcodes_eight: {
      title: `연산 코드 (OpCodes)`,
      nav_title: `여러 키로 서명하기`,
      heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-1">OP_CHECKMULTISIG</span>`,
      subheading_one: `m-of-n 멀티시그 방식은 다음과 같은 알고리즘으로 처리됩니다.`,
      multisig_list_one: `스택에서 정수 하나를 꺼냅니다. 이 값이 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">n</span> 입니다.`,
      multisig_list_two: `스택에서 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">n</span> 개의 항목을 꺼냅니다. 이 항목들은 모두 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">PUBKEY(...)</span> 형식의 공개키여야 합니다.`,
      multisig_list_three: `다시 정수 하나를 꺼냅니다. 이 값이 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">m</span> 입니다.`,
      multisig_list_four: `스택에서 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">m</span>개의 항목을 꺼냅니다. 이 항목들은 모두 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">SIG(...)</span>형식의 서명이어야 합니다.`,
      multisig_list_five: `의미 없는 항목 하나를 더 꺼냅니다. 특별한 이유는 없습니다.`,
      multisig_list_six: `각 공개키를 순회하면서 다음을 수행합니다: 현재 맨 위에 있는 서명과 비교해 유효하면, 해당 공개키와 서명을 모두 제거하고 다음 공개키로 넘어갑니다. 유효하지 않으면 공개키만 제거하고, 같은 서명을 다음 공개키와 비교합니다.`,
      multisig_list_seven: `모든 공개키를 확인했는데 서명이 남아 있다면, 검증은 실패합니다.`,
      multisig_list_eight: `모든 서명이 처리되고 남은 공개키가 있더라도, 검증은 성공으로 종료됩니다.`,
      paragraph_one: `여기서 m <= n이라는 조건을 꼭 지켜야 합니다. 공개키는 서명보다 많을 수 있지만, 서명이 공개키보다 많아서는 안 됩니다. 또 중요한 점은, 공개키와 서명이 반드시 같은 순서로 정렬돼 있어야 한다는 것입니다. 사용되지 않는 공개키가 있더라도, 그 순서는 맞아야 합니다.`,
      paragraph_two: `이제 이 스크립트를 통해 코인을 쓰기 위한 초기 스택을 준비해보세요.`,
    },
    opcodes_nine: {
      title: `연산 코드 (OpCodes)`,
      nav_title: `잠금 해제를 기다리기`,
      heading: `시간 잠금 (타임락, Time Locks)`,
      paragraph_one: `20세기 말, BIP 65라는 문서가 새로운 연산 코드(opcode)를 비트코인에 제안했고, 이후 이 기능은 합의 규칙(consensus rules)에 추가됐습니다. 이 opcode는 트랜잭션의 nLocktime이 스크립트에서 지정한 값 이상이 되어야 한다는 조건을 요구합니다. 비트코인에서는 nLocktime보다 블록 높이가 낮으면 그 트랜잭션을 블록에 포함할 수 없습니다. 즉, 이 opcode는 특정 블록 높이에 도달하기 전에는 트랜잭션을 사용할 수 없게 만들어 미래 시점까지 잠가 두는 역할을 합니다. 이 opcode는 소프트포크로 추가되었기 때문에 스택에서 항목을 꺼내지 않습니다(pop 동작이 없습니다). 그래서 대부분의 경우 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_DROP</span>과 함께 써야 합니다. 만약 아직 블록 높이가 도달하지 않았으면, 스크립트 실행은 즉시 오류로 종료됩니다.`,
      subheading_one: `블록 시간 잠금용 연산 코드`,
      optimelock_list_one_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_DROP</span>`,
      optimelock_list_one_paragraph: `스택에서 항목 하나를 꺼낸 뒤, 그냥 무시해버리는 연산.`,
      optimelock_list_two_heading: `<span className="flex items-center text-[#3DCFEF] w-fit rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_CHECKLOCKTIMEVERIFY</span>`,
      optimelock_list_two_paragraph: `스택 맨 위 항목을 읽고, 그것을 블록 높이로 해석합니다. 그 값이 다음 블록 높이보다 작으면, 실행은 오류로 실패하고 멈춥니다. 이 opcode는 항목을 꺼내지 않기 때문에, 대부분의 경우 OP_DROP과 같이 사용해야 합니다.`,
      paragraph_two: `이제 이 스크립트로 잠겨 있는 코인을 사용하려면, 초기 스택에 무엇을 넣어야 하는지 생각해봅시다.`,
    },
    opcodes_ten: {
      title: `연산 코드 (OpCodes)`,
      nav_title: `로직 구현하기`,
      heading: `조건문 (Conditionals)`,
      paragraph_one: `다른 프로그래밍 언어들처럼, 비트코인 스크립트도 조건 분기를 지원합니다. 코인을 쓰는 사람이 인증 조건 중 자신에게 맞는 조합을 고를 수 있도록, 분기 경로를 선택하게 되어 있습니다.`,
      paragraph_two: `다음은 조건 분기용 연산 코드들입니다: <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_IF</span> <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ELSE</span> <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ENDIF</span>`,
      paragraph_three: `<span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_IF</span> 는 스택에서 값 하나를 꺼내서 불리언(boolean) 값으로 평가합니다. 만약 참(true)이면 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ELSE</span> 부터 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ENDIF</span> 까지는 건너뜁니다. 반대로 거짓(false)이면, <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ELSE</span>까지 건너 뛰고, <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ENDIF</span>까지 실행합니다. 조건문은 중첩(nested)할 수 있지만, 각 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_IF</span>에는 반드시 짝이 되는 <span className="text-[#3DCFEF] rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_ENDIF</span>가 있어야 합니다. 그렇지 않으면 스크립트 해석기에서 에러가 발생하고 스크립트는 실패하게 됩니다.`,
      paragraph_four: `이제 이 조건문 스크립트를 사용해 코인을 쓰려면, 초기 스택에 어떤 값을 넣을지 잘 고민해봅시다.`,
    },
    proposal_one: {
      title: `심화 학습`,
      nav_title: `다시 스토리로`,
      heading: `다시 스토리로 돌아가기!`,
      paragraph_one: `잘하셨습니다! 이제 기본적인 트랜잭션 스크립트를 만들 때 필요한 대부분의 연산 코드를 살펴봤습니다. 이제 실제로 적용해봅시다!`,
      paragraph_two: `각 계약 조건을 검토하면서, 비트코인 스크립트 하나와 유효한 지불 스택(spending stack)을 하나씩 만들어봅시다.`,
    },
    proposal_two: {
      title: `2 of 2 멀티시그`,
      nav_title: `공동 서명`,
      heading: `2 of 2 멀티시그`,
      paragraph_one: `반더풀은 첫 번째로 2-of-2 멀티시그를 제안합니다. 기부금은 당신과 Lil Bits 재단이 50:50으로 나눠 가지게 되고, 이 주소에서 자금을 출금하려면 반드시 두 사람 모두 서명해야 합니다. 즉, 기부 주소에서 돈을 인출하려면 항상 둘이 합의해야 합니다.`,
      paragraph_two: `반더풀은 자신의 공개키를 내밉니다. 그 키는 PUBKEY(vanderpoole)이고, 당신의 공개키는 PUBKEY(me)입니다.`,
      paragraph_three: `이 스크립트에서 코인을 쓰기 위한 초기 스택을 입력해주세요.`,
      next_step_message: `좋습니다! 이제 당신 서명으로도 한 번 해봅시다.`,
    },
    proposal_three: {
      title: `조건부 시간 잠금 트랜잭션`,
      nav_title: `그를 기다리게 하기`,
      heading: `조건부 시간 잠금 트랜잭션`,
      paragraph_one: `잠깐만, 가만히 생각해 보니… 그 사람하고 평생 엮이고 싶진 않습니다! 그래서 새 제안을 합니다: 지금부터 2시간 동안 방송이 나가는 동안 들어오는 기부금은 전부 당신이 받고, 이후에 들어오는 기부금은 Lil Bits 재단이 가져가게 됩니다. 스튜디오 벽에 걸린 블록 타이머를 보니, 블록 높이 6930300쯤이 2시간 후에 생성될 것으로 보입니다. 그걸 기준으로 삼기로 합니다.`,
      paragraph_two: `참고로 반더풀의 공개키는 PUBKEY(vanderpoole)이고, 당신의 공개키는 PUBKEY(me)입니다.`,
      paragraph_three: `이 조건부 트랜잭션에서 코인을 쓰기 위한 초기 스택을 입력해주세요.`,
      next_step_message: `좋습니다! 이번엔 당신 서명으로도 한 번 해봅시다.`,
    },
    proposal_four: {
      title: `비밀 프리이미지로 잠긴 트랜잭션`,
      nav_title: `오라클과 협력하기`,
      heading: `비밀 프리이미지로 잠긴 트랜잭션`,
      paragraph_one: `반더풀이 또 다시 마음을 바꿨어요. 예측할 수 없는 상황은 싫다며, 이번에는 이런 조건을 제시했죠: 총 기부금 중 처음 1.0 BTC는 Lil Bits 재단이 받고, 그 이후에 들어오는 기부금은 당신이 받도록 합니다.`,
      paragraph_two: `비트코인 스크립트는 여러 UTXO의 총합을 확인할 수 없습니다. 그래서 중립적인 제3자인 데보라 청크를 오라클로 두기로 합의했습니다. 그녀는 블록체인에서 누적 기부금이 1.0 BTC에 도달했는지 직접 모니터링하고, TV 생방송 중에 특정 해시 값의 프리이미지(원래 값)를 공개할 겁니다. 당신은 이 해시 값에 대한 합의를 스크립트에 넣어두고, 그녀가 프리이미지를 밝히는 순간부터 코인을 사용할 수 있습니다.`,
      paragraph_three: {
        a: `그녀는 비공개로 보안 랜덤 난수를 하나 만든 다음, 해시 다이제스트(hash digest)를 당신께 전달했습니다: <span className="text-[#3DCFEF] w-fit rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">HASH256(FD3771E8)</span>. 이 비밀 값이 공개되기 전까지는, 절대 코인에 손댈 수 없습니다. 단 1초라도요!`,
        b: ` `,
      },
      paragraph_four: `반더풀의 공개키는 PUBKEY(vanderpoole)이고, 당신의 공개키는 PUBKEY(me)입니다. 이 점 꼭 기억해 두세요.`,
      paragraph_five: `해당 스크립트에서 코인을 쓰기 위한 초기 스택을 입력하세요.`,
      tooltip_one: {
        question: `사토시란 무엇일까?`,
        link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=What%2520is%2520a%2520satoshi%253F`,
        highlighted: `사토시`,
      },
      next_step_message: `서명과 프리이미지를 제대로 섰는지 확인해 봅시다.`,
    },
    outro_one: {
      title: `마무리`,
      nav_title: `쳅터 완료`,
      heading: `잘 해냈습니다!`,
      paragraph_one: `기부금은 이제 당신과 Lil Bits 재단에 나뉘어 전달되었고, 많은 시청자들이 반더풀의 행동을 밝혀준 당신에게 감사를 전하고 있습니다. 비트코인의 탈중앙화 특성 덕분에 네트워크를 장악하긴 어렵지만, 반더풀 같은 이들이 시도조차 못 하게 만들 순 없습니다. 이 모든 노력을 거쳐 마침내 진실이 드러났다는 사실에 당신도 안도합니다.`,
    },

    resources: {
      opcodes_five: {
        arithmetic_heading: `산술 연산 코드`,
        arithmetic_paragraph: `비트코인 스크립트에서 산술 연산은 수학처럼 입력값을 받아 계산을 수행합니다. 실제 비트코인 스크립트에서는 입력값이 부호 있는 32비트 정수로 제한되지만, 출력값은 오버플로우가 발생할 수 있습니다.`,
        spoiler: `스택에 숫자 두 개를 넣어, 결과가 3이 되도록 해보세요.`,
      },
      opcodes_six: {
        cryptography_heading: `암호 연산 코드`,
        cryptography_paragraph: `이 연산 코드들은 일상적인 트랜잭션에서 매우 중요합니다. 특정 UTXO의 소유자만 서명을 통해 출력값을 사용할 수 있도록 보장해주기 때문이죠. 참고로, 연산 코드들은 공식적으로 분류되어 있는 건 아니며, 헥스 코드 순서로만 정리된 상태입니다.`,
        spoiler: `스크립트는 서명을 해시된 공개키와 대조합니다. 서명을 먼저, 공개키를 나중에 넣어보세요.`,
      },
      opcodes_eight: {
        multisig_heading: `다중 서명 연산 코드`,
        multisig_paragraph: `<span className="text-[#3DCFEF] rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_CHECKMULTISIG</span> 에는 독특한 버그가 있어서, 실제 다중 서명과는 무관한 값을 스택 맨 위에 하나 더 넣어야만 작동합니다.`,
        spoiler: `이 스크립트는 서명 두 개가 필요한 다중 서명(multisig) 스크립트입니다. 스택의 첫 번째 값은 CHECKMULTISIG 연산에서 생기는 이상한 동작 때문에 넣는 자리 표시자입니다.`,
      },
      opcodes_nine: {
        timelock_heading: `시간 잠금 연산 코드`,
        timelock_paragraph: `비트코인 스크립트는 현재 블록 높이를 읽을 수 있어서, 미래의 특정 비트코인 블록을 기준으로 트랜잭션을 잠글 수 있습니다. 실제 <span className="text-[#3DCFEF] rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_CHECKLOCKTIMEVERIFY</span>의 정확한 의미는`,
        timelock_link: `<Link target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki" className="underline">여기</Link>에서 확인할 수 있습니다.`,
        spoiler: ` 이 스크립트는 특정 블록 높아까지 자금 사용을 잠근 후, 초기 스택에 담긴 서명을 검증합니다.`,
      },
      opcodes_ten: {
        conditionals_heading: `조건 분기 연산 코드`,
        conditionals_paragraph: `조건부 연산 코드는 기본적인 분기 로직을 구현할 수 있게 해줍니다. 이러한 조건 로직을 통해 비트코인 스크립트로 다양한 방식의 제어 흐름을 만들 수 있지만, 전통적인 프로그래밍 언어에 비해서는 여전히 제한적입니다.`,
        spoiler: `초기 스택에 있는 앞의 두 값을 더한 결과가 false(거짓)이기 때문에, 스크립트는 OP_ELSE 분기로 이동하게 됩니다.`,
      },
      proposal_two: {
        making_script_heading: `스크립트 만들기`,
        making_script_paragraph: `스크립트가 유효하다고 인정되기 위해서는 마지막에 스택 위에 오직 하나의 true 값만 남아 있어야 스크립트가 유효하다는 걸 기억하세요. 일부 구현에서는 어떤 truthy 값도 허용되지만, 우리가 사용하는 스크립트 편집기에서는 1 또는 true만 허용됩니다.`,
        tip: `<span className="text-[#3DCFEF] rounded-sm px-1.5 h-[28px] font-mono bg-[#0000004D] m-0.5 text-sm">OP_CHECKMULTISIG</span> 연산 코드에는 사용되지 않는 값을 스택에 하나 더 넣어야 하는 버그가 있다는 점을 잊지 마세요!`,
        spoiler: `스크립트 힌트: 이 멀티시그는 두 참여자의 서명이 모두 필요합니다. 스크립트에는 두 개의 서명이 필요하다고 명시되어 있고, 두 개의 공개키가 들어 있습니다.
  스택 힌트: 스크립트를 만족시키기 위해 두 개의 서명을 모두 입력해야 합니다. 스택에 들어가는 0은 CHECKMULTISIG 연산 코드의 특이한 동작을 반영한 것입니다.`,
      },
      proposal_three: {
        tip: `조건문과 타임락을 결합해서 반더풀의 서명과 당신의 서명을 분리해보는 건 어떨까요?`,
        spoiler: `스크립트 힌트: 이 스크립트는 두 가지 조건 중 하나를 만족하면 코인을 쓸 수 있도록 합니다. 블록 높이 6930300 이전이라면 당신이 지출할 수 있고, 이후라면 반더풀이 지출할 수 있습니다.
  
  스택 힌트: 지정된 블록 이전에 지출하려면 당신의 서명이 필요합니다. 이후라면 반더풀의 서명을 사용하고, 스크립트가 이미 락타임 검증을 통과했으므로 스택에 0을 함께 넣어야 합니다.`,
      },
      proposal_four: {
        tip: `프리이미지 공개 시점을 알 수 없기 때문에 타임락은 필요하지 않습니다.`,
        spoiler: `스크립트 힌트: 이 스크립트는 두 가지 조건 중 하나를 만족하면 코인을 쓸 수 있도록 합니다. 비밀이 공개되기 전에는 반더풀이 지출할 수 있고, 공개된 이후에는 당신과 반더풀 모두 지출할 수 있습니다.
  
  스택 힌트: 비밀이 공개되기 전에는 반더풀이 자신의 서명만으로 지출합니다. 비밀이 공개된 이후에는 당신의 서명, 비밀 값, 그리고 0을 입력해야 합니다. 스크립트가 '비밀이 아직 공개되지 않음' 여부를 판단하는 과정을 이미 통과했기 때문입니다.`,
      },
    },
  },

  chapter_ten: {
    title: `100억 개의 연결`,
    paragraph_one: `TV 스튜디오의 ‘방송 중’ 표시등이 꺼집니다. 무대 스태프들이 3D 카메라 전원을 끄고, 길고 다사다난했던 하루를 마무리하며 하나둘 자리를 뜹니다. 미카 3000은 당신을 기다리고 있습니다.`,
    intro_one: {
      title: `축하`,
      nav_title: `축하`,
      paragraph_one: `—미카 3000: “해냈어! 진짜 해냈잖아! 우리 뭐라도 마시면서 축하하자.”`,
      paragraph_two: `당신은 미카와 함께 근처 바 ‘퍼블릭 키 펍’으로 향합니다. 바텐더는 ‘라즐로’라는 이름표를 단 친절한 남자로, 둘을 환하게 반겨줍니다.`,
      paragraph_three: `—미카 3000: “왠지 모르겠는데 지금 칼조네 먹고 싶다.”`,
      paragraph_four: `—라즐로: “그건 없지만, 우리 증조할아버지는 이 집 피자만큼은 최고라고 장담하셨죠. 어떤 사람들은 1만 비트코인어치 맛있다고도 하더군요.”`,
      paragraph_five: {
        a: `—미카 3000: “1만 비트코인이라고? 잠깐만… 혹시 ‘라즐로’라는 이름도 그 `,
        b: ` 의 후손이라서야...?"`,
      },
      paragraph_six: `—라즐로: “그 라즐로 맞아.”`,
      tooltip_one: {
        question: `라즐로와 피자 데이는 왜 중요할까요?`,
        link: `https://chat.bitcoinsearch.xyz/?author=holocat&question=What%2520is%2520the%2520significance%2520of%2520Laszlo%2520and%2520pizza%2520day%253F`,
        highlighted: `라즐로`,
      },
    },
    intro_two: {
      title: `음료 주문하기`,
      nav_title: `음료 주문하기`,
      paragraph_one: `—미카 3000: “진짜 멋지다. 10,000 비트코인만 아니면 피자 하나랑 라이트닝 레모네이드 두 잔 주세요. 칼조네는 아쉽지만 어쩔 수 없죠.”`,
      paragraph_two: `미카 3000과 라즐로는 태양광으로 충전되는 ePhone Infinity를 꺼내 버튼을 두드립니다.`,
      paragraph_three: `—미카 3000: “어이쿠. 너가 아까 벌인 일 때문에 채굴 수수료가 장난 아니게 올랐어. 비트코인 네트워크에 트랜잭션이 몰리면서 수수료가 천정부지로 치솟고 있어! 이건 온체인 결제 말고 오프체인으로 처리해야겠어.”`,
    },
    intro_three: {
      title: `오프체인?`,
      nav_title: `오프체인이라고?`,
      paragraph_one: `‘사토시’에게 처음 연락을 받은 이후로, 지금까지는 온체인 트랜잭션만 사용해왔습니다. 채굴 보상을 청구할 때도, 미카 3000에게 자금을 보낼 때도 말이죠. 하지만 이런 온체인 방식은 일상적으로 자주 쓰기에는 제약이 있습니다. 블록 공간은 제한돼 있고, 채굴 수수료는 상황에 따라 크게 달라질 수 있거든요.`,
      paragraph_two: `그런데도 어떻게 사람들은 매일 비트코인을 실생활에서 쓸 수 있을까요? 해답은 ‘오프체인 결제’입니다. 이건 당신도 수없이 봤을거에요 — 주황색 택시가 손님을 내려주고 쌩 하고 달려가는 장면, 누군가가 할랄 푸드 카트에서 저녁을 사는 모습, 어떤 아이가 홀로독이랑 디지털 밀크를 들고 가게에서 나오는 장면 등. 돈이 쓰이는 방식은 정말 무한하니까요.`,
      paragraph_three: `비트코인이 본래부터 이렇게 많은 활동을 자체적으로 처리하도록 설계된 건 아니지만, 오프체인 결제를 이용하면 그게 가능해집니다.`,
      paragraph_four: `—당신: “그 정도쯤이야 문제 없어. 라즐로한테 라이트닝 레모네이드를 오프체인 결제로 사면 되잖아.”`,
    },
    opening_a_channel_one: {
      title: `초기 자금`,
      nav_title: `초기 자금`,
      heading_one: `초기 자금`,
      paragraph_one: `블록체인에 101,000 사토시가 담긴 확정된 UTXO가 있습니다. 오프체인 결제를 만드는 일, 꽤 간단해 보이지 않나요?`,
    },
    opening_a_channel_two: {
      title: `오프체인 거래`,
      nav_title: `오프체인 거래`,
      heading_one: `오프체인 거래`,
      paragraph_one: `이번엔 유효한 비트코인 트랜잭션을 만들어봅시다. 다만 네트워크에 브로드캐스트(*네트워크에 트랜잭션을 전파하는 행위)하지 않고, 바로 라즐로에게 건네줄 거예요. 그러면 그는 그 대가로 당신에게 라이트닝 레모네이드를 줄 거고요. 왜냐하면 이 트랜잭션은 그가 언제든지 네트워크에 브로드캐스트해서 블록에 포함시키고, 확정되면 돈을 받을 수 있기 때문입니다.`,
      paragraph_two: `지금은 2140년! 라이트닝 레모네이드 한 잔 가격은 0.00001000 BTC예요.`,
      heading_two: `안내사항`,
      off_chain_list_one: `두 개의 출력 금액을 입력해 주세요: 첫 번째 출력에는 라즐로에게 1000 사토시를 보내고, 두 번째 출력에는 나머지 금액을 당신에게 거스름돈으로 설정하세요.`,
      off_chain_list_two: `채굴자 수수료를 반영하세요: 라즐로가 이 트랜잭션으로 돈을 받으려면 네트워크에 브로드캐스트해야 해요. 그러려면 채굴자 수수료가 필요하니, 1000 사토시를 따로 떼어 두고 거스름돈에서 그만큼 빼 주세요.`,
      off_chain_list_three: `두 개의 출력 스크립트를 작성하세요`,
      off_chain_list_four: `<span className="rounded-sm px-1.5 py-1 h-[28px] bg-[#0000004D] m-0.5 text-base">Sign</span> 버튼을 눌러 입력을 서명하세요`,
      // off_chain_list_four: `Send it to Laszlo by clicking "send to bob"`,
      heading_three: `힌트`,
      hint_one: `라즐로는 출력 0을 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> SIG(LASZLO)</span>로 사용합니다.`,
      hint_two: `당신은 출력 1을 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> SIG(YOU)</span>로 사용합니다.`,
      hint_three: `이 서명들은 출력 스크립트의 일부가 아닙니다.`,
    },
    opening_a_channel_three: {
      title: `오프체인 결제의 신뢰 문제`,
      nav_title: `오프체인 결제의 신뢰 문제`,
      paragraph_one: `—라즐로: "잠깐만요, 이건 말이 안 되잖아요. 당신이 그 트랜잭션을 브로드캐스트하지 않으면, 여전히 그 101,000 사토시를 쓸 수 있죠. 라이트닝 레모네이드를 마신 다음, 같은 돈으로 다른 데 결제해버릴 수도 있는 거잖아요. 그러면 전 아무것도 못 받게 되죠!`,
      paragraph_two: `우리가 오프체인으로 거래하려면, 당신이 나에게 오프체인으로 지불한 돈을 온체인에서는 더 이상 쓸 수 없다는 보장이 필요해요."`,
    },
    opening_a_channel_four: {
      title: `멀티시그 (Multisig)`,
      nav_title: `멀티시그`,
      heading_one: `멀티시그`,
      paragraph_one: `라즐로에게 결제하기 전에, 먼저 자금을 블록체인에서 확인 가능한 2-of-2 멀티시그 주소로 옮깁니다. 그런 다음, 하나의 온체인 트랜잭션으로 더 효율적이고 다양한 작업을 처리할 수 있게 구성해봅시다.`,
      heading_two: `안내`,
      multisig_one: `출력 금액과 출력 스크립트를 작성하세요.`,
      multisig_two: `입력을 서명하고 브로드캐스트하려면 <span className="rounded-sm px-1.5 py-1 h-[28px] bg-[#0000004D] m-0.5 text-base">Sign and Broadcast</span>를 클릭하세요.`,
      heading_three: `힌트`,
      hint_one_a: `당신과 라즐로는 향후 함께 출력 0을 다음과 같이 써야 합니다: <br/> `,
      hint_one_b: `<span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> 0 SIG(LASZLO) SIG(YOU) </span>`,
      hint_two: `채굴 수수료를 따로 남겨두는 것 잊지 마세요.`,
    },
    opening_a_channel_five: {
      title: `멀티시그에서의 환불 보호`,
      nav_title: `멀티시그에서의 환불 보호`,
      paragraph_one: `—라즐로: “좋아, 고마워. 지금까지는 좋아보이네. 그런데 내가 자리를 뜨고, 다시는 날 못 보게 되면 어쩔 건데? 내가 그 트랜잭션을 브로드캐스트해버리면, 네 100,000 사토시는 2-key 멀티시그 안에 갇혀서, 다시는 되찾지 못할 수도 있어.”`,
      paragraph_two: `그러니까 혹시 모르니까, 이 트랜잭션에 서명하기 전에 미리 환불 트랜잭션 하나 만들어 둬. 그래야 나중에라도 돈을 되찾을 수 있다는 확신이 생기지.”`,
    },
    updating_the_state_one: {
      title: `환불`,
      nav_title: `환불`,
      heading_one: `환불`,
      paragraph_one: `ePhone Infinity에 새로운 탭이 나타난다: <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">Refund</span> 이 탭은 같은 화면에서 또 다른 거래 템플릿을 열며, <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">Multisig</span> 출력에서 이 환불 트랜잭션 입력으로 화살표가 이어져 있다.`,
      heading_two: `안내`,
      refund_list_one: `출력 금액과 출력 스크립트를 작성하세요.`,
      refund_list_two: `<span className="rounded-sm px-1.5 py-1 h-[28px] bg-[#0000004D] m-0.5 text-base">Send to Laszlo</span> 버튼을 눌러 라즐로에게 전송하세요. 서명할지 말지는 그가 알려줄 거예요.`,
      refund_list_three: `아직 서명하지 마세요! 먼저 라즐로가 뭐라고 하는지 봅시다.`,
      heading_three: `힌트`,
      hint_one: `출력 0은 당신이 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">SIG(YOU)</span>로 사용할 수 있습니다.`,
    },
    updating_the_state_two: {
      title: `결제 보장하기`,
      nav_title: `결제 보장하기`,
      paragraph_one: `—라즐로: “좋아, 이거 서명해서 너한테 다시 보낼게. 그러면 넌 2-of-2 멀티시그 자금 조달 트랜잭션에 서명하면 돼.`,
      paragraph_two: `근데... 잠깐만. 내가 이 환불 트랜잭션에 서명하면, 결국 다시 원점이잖아. 내가 너한테 라이트닝 레모네이드를 준 후에도, 너는 여전히 이 환불 트랜잭션을 브로드캐스트해서 내 돈을 가져갈 수 있잖아.`,
      paragraph_three: `그러니까 서명하기 전에, 이 환불 트랜잭션이 철회 가능하다는 보장이 필요해.`,
      paragraph_four: `네가 실제로 나한테 라이트닝 레모네이드를 결제한 뒤엔, 이 환불 트랜잭션을 더 이상 브로드캐스트할 수 없어야 해. 그리고 만약 너가 철회된 이후에도 이걸 브로드캐스트하려고 하면, 나는 100,000 사토시 <span className="italic">전부</span>를 갖게 되는 거야!”`,
    },
    updating_the_state_three: {
      title: `철회`,
      nav_title: `철회`,
      heading_one: `철회`,
      paragraph_one: `자신에게 보내는 100,000 사토시 출력에 조건을 하나 더 추가하면, 라즐로가 이를 철회할 수 있도록 만들 수 있습니다. 이 조건 분기는 라즐로가 자신의 키와 당신이 새로 생성한 개인 키를 함께 사용해야 이 출력을 쓸 수 있도록 만들어야 합니다. 만약 이 트랜잭션을 철회하고 싶다면, 당신은 그 새로운 개인 키를 라즐로에게 넘겨주면 됩니다. 이건 정말 이례적인 방식이지만, 무려 100,000 사토시가 걸려 있습니다. 이 방법을 사용하면 당신이 철회된 트랜잭션을 나중에 브로드캐스트하려고 할 경우, 라즐로가 그 돈을 전부 가져갈 수 있습니다.`,
      paragraph_two: `당신은 새로운 키조합 하나를 생성합니다. 개인 키는 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">REVOCATION_YOU_1</span> 이며, 공개 키는 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">PUBKEY(REVOCATION_YOU_1)</span> 입니다. 이런 식으로, 결제 채널 상태를 업데이트할 때마다 새로운 키조합을 생성하게 될 겁니다.`,
      heading_two: `안내`,
      revocation_list_one: `스크립트에 IF 조건문을 넣어, 라즐로가 본인 키와 철회용 키 둘 다 가지고 있어야만 이 출력을 사용할 수 있게 해보세요. (이 철회용 키는 실제 철회 시점까지 혼자 비밀로 간직하고 있어야 합니다!)`,
      revocation_list_two: `<span className="rounded-sm px-1.5 py-1 h-[28px] bg-[#0000004D] m-0.5 text-base">Send to Laszlo</span> 버튼을 눌러 이 트랜잭션을 라즐로에게 보내세요. 그러면 그가 서명할 수 있을 겁니다.`,
      revocation_list_three: `아직 당신은 서명하지 마세요!`,
      heading_three: `힌트`,
      paragraph_three: `출력 0은 다음 중 하나의 조건을 만족하면 사용할 수 있습니다:`,
      hint_one: `당신이 자금을 청구할 경우의 초기 스택: <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> SIG(YOU) 1 </span>`,
      hint_two: `라즐로가 자금을 청구할 경우의 초기 스택: <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> 0 SIG(REVOCATION_YOU_1) SIG(LASZLO) 0 </span>`,
    },
    updating_the_state_four: {
      title: `철회 경쟁`,
      nav_title: `철회를 둘러싼 경쟁`,
      paragraph_one: `—라즐로: “음, 이제 확실히 좋아졌는데... 방금 떠올랐어. 내가 철회용 키를 갖고 있어도, 결국 이 출력을 누가 먼저 쓰느냐는 ‘속도 싸움’이 될 수 있단 말이지.`,
      paragraph_two: `내가 너한테 속았다는 걸 눈치채더라도, 그 전에 내가 비트코인을 먼저 쓸 수 있어야 해. 그래야 네가 전액 환불하기 전에, 내가 철회용 키로 자금을 가져갈 수 있지. 네가 전액 환불 받아가기 전에.”`,
    },
    updating_the_state_five: {
      title: `타임락`,
      nav_title: `타임락`,
      heading_one: `타임락`,
      time_lock_list_one: `출력을 사용할 수 있도록 700 블록 지연 조건을 추가하세요.`,
      time_lock_list_two: `<span className="rounded-sm px-1.5 py-1 h-[28px] bg-[#0000004D] m-0.5 text-base">Send to Laszlo</span> 버튼을 눌러 이 트랜잭션을 라즐로에게 보내세요. 그러면 그가 서명할 수 있을 겁니다.`,
      time_lock_list_three: `아직 당신은 서명하지 마세요!`,
      heading_two: `힌트`,
      paragraph_one: `출력 0은 다음 조건 중 하나를 만족할 때만 사용됩니다:`,
      hint_one: `700 블록 이후 당신이 자금을 사용하는 경우의 초기 스택: <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">SIG(YOU) 1</span> `,
      hint_two: `라즐로가 자금을 사용하는 경우의 초기 스택: <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">0 SIG(REVOCATION_YOU_1) SIG(LASZLO) 0 </span> `,
    },
    updating_the_state_six: {
      title: `라즐로와 채널 열기`,
      nav_title: `라즐로와 채널 열기`,
      paragraph_one: `이번엔 트랜잭션을 라즐로에게 건네자, 그는 미소를 지으며 박수를 칩니다! 그는 환불용(자식) 트랜잭션에 서명하고, 이제 당신은 부모 트랜잭션에 서명하고 브로드캐스트할 수 있습니다. 이 트랜잭션은 2-of-2 멀티시그에 자금을 예치합니다. 이제 결제 채널이 열렸어요!`,
    },
    making_a_payment_one: {
      title: `결제하기`,
      nav_title: `결제하기`,
      heading_one: `결제하기`,
      paragraph_one: `지금까지 내용을 다시 정리해봅시다:`,
      list_one: `당신은 라즐로와 당신 사이의 2-of-2 멀티시그 출력으로 100,000 사토시를 보냈습니다.`,
      list_two: `오프라인 상태에서, 해당 출력을 사용하는 환불 트랜잭션을 가지고 있습니다.`,
      list_three: `그 환불 트랜잭션은 두 가지 방식으로 자금을 사용할 수 있도록 조건을 설정했습니다:`,
      list_three_sub_one: `700 블록이 지난 후 수수료를 제외한 99,000 사토시 전부를 당신이 돌려받을 수 있습니다, 또는`,
      list_three_sub_two: `당신이 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">REVOCATION_YOU_1</span> 개인키를 넘겨주면 라즐로가 전액을 가져갈 수 있습니다.`,
      list_four: `라즐로는 이미 이 환불 트랜잭션에 서명했고, 당신은 원할 때 언제든 서명해서 브로드캐스트할 수 있습니다.`,
      list_five: `라즐로가 이 환불(자식) 트랜잭션에 먼저 서명해줬기 때문에, 당신은 안심하고 부모 트랜잭션에 서명하고 브로드캐스트할 수 있었습니다.`,
      paragraph_two: `멀티시그 출력에 자금을 보낸 트랜잭션은 <span className="font-bold">펀딩 트랜잭션</span>이라고 불립니다. 이 트랜잭션이 블록체인에 확정되면, 페이먼트 채널이 <span className="font-bold">열리게</span> 됩니다.`,
      paragraph_three: `펀딩 트랜잭션의 출력을 사용하는 오프라인 환불 트랜잭션은 <span className="font-bold">커밋먼트 트랜잭션</span>이라고 합니다. 이게 블록체인에 확정되면 채널이 <span className="font-bold">닫히게</span> 됩니다. 첫 번째 커밋먼트 트랜잭션은 아직 라즐로에게 아무것도 결제하지 않았기 때문에 당신이 전액 환불받는 구조입니다.`,
      paragraph_four: `채널이 열려 있는 동안에는, 당신과 라즐로가 서로 오프라인으로 결제를 주고받을 수 있습니다. 새로운 커밋먼트 트랜잭션을 서로 협의해 만들고, 이전 것은 철회하는 방식입니다. 음료를 더 많이 살수록 당신의 '환불' 금액은 줄고, 멀티시그에 묶여 있던 100,000 사토시 중 라즐로 몫은 점점 늘어납니다.`,
    },
    making_a_payment_two: {
      title: `라이트닝 레모네이드 사기`,
      nav_title: `라이트닝 레모네이드 사기`,
      heading_one: `라이트닝 레모네이드 사기`,
      paragraph_one: `이제 드디어 비트코인을 라즐로에게 오프체인으로 보낼 시간입니다. 이번에는 업데이트된 커밋먼트 트랜잭션에 라즐로를 위한 1,000 사토시 출력 하나만 '간단히' 추가하면 됩니다. 그리고 라즐로에게 돈이 할당되지 않은 이전 커밋먼트 트랜잭션을 절대 브로드캐스트하지 않겠다는 약속도 해야 합니다. 그 약속은 이제 예전 상태의 커밋먼트 트랜잭션을 철회할 수 있는 철회 키를 라즐로에게 넘김으로써 보장됩니다. 그건 바로 다음 단계에서 하게 될 겁니다.`,
      paragraph_two: `이번 새로운 상태를 위해 철회 키 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">REVOCATION_YOU_2</span>를 하나 더 생성했습니다. 만약 사이클을 반복해서 음료를 한 잔 더 사고 싶다면, <span className="font-bold">이번</span> 트랜잭션을 철회하고, 라즐로에게 두 번째 라이트닝 레모네이드 값을 지급하는 또 다른 새 커밋먼트 트랜잭션을 만들면 됩니다. 어차피 오늘은 파티잖아요!`,
      heading_two: `안내`,
      list_one: `당신 출력에서 1,000 사토시를 빼세요.`,
      list_two: `두 번째 출력에 1,000 사토시를 추가하고, 라즐로를 위한 스크립트를 작성하세요.`,
      list_three: `'Send to Laszlo' 버튼을 눌러 라즐로에게 트랜잭션을 보내세요. 그러면 그가 서명할 수 있을 겁니다.`,
      list_four: `아직 당신은 서명하지 마세요!`,
      heading_three: `힌트`,
      paragraph_three: `출력 0은 다음 두 가지 경우 중 하나로 사용됩니다:`,
      hint_one: `이제 'Refund' 탭은 'Initial Commitment(초기 커밋)'이라는 이름으로 바뀌었습니다. 이전 상태에서 작성한 스크립트를 여기서 확인할 수 있습니다.`,
      hint_two: `당신이 700 블록 이후에 사용할 경우: <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">SIG(YOU) 1 </span>`,
      hint_three: `라즐로가 사용할 경우: <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> 0 SIG(REVOCATION_YOU_2) SIG(LASZLO) 0 </span>`,
      paragraph_four: `출력 1은 라즐로가 사용합니다: <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> SIG(LASZLO) </span>`,
    },
    making_a_payment_three: {
      title: `라즐로의 블록체인 딜레마`,
      nav_title: `라즐로의 블록체인 딜레마`,
      paragraph_one: `라즐로는 트랜잭션을 잠시 바라보다가 바 너머에서 잔을 들었지만, 라이트닝 레모네이드는 따르지 않습니다.`,
      paragraph_two: `—라즐로: “잠깐만. 네가 이 트랜잭션에 서명하지 않으면 난 아무것도 받지못해. 넌 이 라이트닝 레모네이드를 마시고 사라질 수도 있는데, 나는 온체인에서 아무것도 증명할 수 없어. 우리 둘 다 트랜잭션 사본을 가질 수 있게, 네가 먼저 서명한 다음 나한테 보내는 게 어떨까?”`,
    },
    making_a_payment_four: {
      title: `홀로캣의 신뢰 없는 경고`,
      nav_title: `홀로캣의 신뢰 없는 경고`,
      paragraph_one: `그때, 홀로캣이 탁자 위에 뿅 하고 나타나 앞발을 쭉 내밀며 뒷다리로 서서 “야옹!” 하고 웁니다.`,
      paragraph_two: `—홀로캣: “잠깐만! 라즐로한테 이 트랜잭션에 대한 네 서명을 넘기면 안 돼! 다음 번에 결제를 할 땐 그에게 철회 키인 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">REVOCATION_YOU_2</span>도 주게 될 텐데, 그러면 그는 100,000 사토시 전부를 가져갈 수 있는 조건이 완성되는 거야!”`,
      paragraph_three: `상황이 점점 복잡해지고 있습니다. 라즐로는 라이트닝 레모네이드를 주기 전에 반드시 본인이 돈을 받게 될 거라는 보장이 필요합니다. 하지만 그에게 트랜잭션 전체를 넘겨주면, 오히려 당신이 가진 모든 돈에 접근할 수 있게 됩니다! 라즐로는 좋은 사람입니다. 그의 바가 이 도시 최고인 건 사실이지만, 굳이 그를 전적으로 믿지 않아도 되는 방법이 있다면 더 좋겠죠.`,
    },
    making_a_payment_five: {
      title: `비대칭`,
      nav_title: `비대칭`,
      heading_one: `비대칭 트랜잭션`,
      paragraph_one: `우리는 라즐로가 첫 번째 트랜잭션에 서명하길 바라지만, 그가 우리 서명을 가지게 되는 건 원하지 않습니다. 그래서 라즐로에게는 우리 서명이 포함된 <span className="font-bold">또 다른</span> 트랜잭션을 따로 만들어줘야 합니다. 물론 그걸로는 돈을 마음대로 가져갈 수 없도록 해야 합니다.`,
      paragraph_two: `라즐로가 자기만의 커밋먼트 트랜잭션을 가지게 될 거라면, 그 트랜잭션도 철회 가능하게 만들어야 하지 않을까요? 맞습니다! 사실 라즐로의 커밋먼트 트랜잭션은 우리 것과 거의 똑같은 대칭 구조입니다. 철회 가능한 타임락 스크립트는 라즐로의 첫 번째 철회 키인 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">PUBKEY(REVOCATION_LASZLO_1)</span> 를 사용하고, 큰 금액의 환불 출력은 조건 없이 곧바로 당신에게 돌아옵니다.`,
      heading_two: `안내`,
      list_one: `라즐로의 커밋먼트 트랜잭션에 들어갈 금액과 출력 스크립트를 작성하세요.`,
      list_two: `여기에 먼저 서명한 뒤 라즐로에게 보내세요. 그러면 라즐로가 당신의 커밋먼트 트랜잭션에 서명해서 다시 보내줄 겁니다.`,
      heading_three: `힌트`,
      hint_one: `'Commitment_you' 탭으로 전환하면 당신이 작성한 커밋먼트 트랜잭션 스크립트를 확인할 수 있습니다.`,
      paragraph_three: `출력 0은 다음 두 가지 중 하나로 사용됩니다:`,
      hint_two: `라즐로가 700 블록 이후 사용할 경우: <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">SIG(LASZLO) 1 </span>`,
      hint_three: `당신이 사용할 경우: <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> 0 SIG(REVOCATION_LASZLO_1) SIG(YOU) 0 </span>`,
      paragraph_four: `출력 1은 당신이 사용합니다: <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> SIG(YOU) </span>`,
    },
    making_a_payment_six: {
      title: `결제 완료`,
      nav_title: `결제 완료`,
      heading_one: `결제 완료`,
      paragraph_one: `한 번 더 정리해볼게요.`,
      list_one: `2-of-2 출력이 블록체인에 확인됐습니다.`,
      paragraph_two: `이 100,000 사토시가 잠겨 있는 2-of-2 멀티시그 출력은, 여러 개의 오프체인 트랜잭션으로 사용될 수 있어요:`,
      paragraph_three: `당신이 갖게 될 트랜잭션들은 다음과 같습니다:`,
      paragraph_four: `Commitment 1 (당신)`,
      commitment_one_you: {
        list_one: `<span className="font-semibold">입력 0:</span> 라즐로가 서명함`,
        list_two: `<span className="font-semibold">출력 0:</span> 700 블록 이후 당신에게 99,000 사토시, 혹은 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">REVOCATION_YOU_1</span>키를 가진 라즐로에게`,
        list_three: `<span className="font-semibold">채굴자 수수료:</span> 1,000 사토시`,
      },
      commitment_two_you: {
        list_one: `<span className="font-semibold">입력 0:</span> 라즐로가 서명함`,
        list_two: `<span className="font-semibold">출력 0:</span> 700 블록 이후 당신에게 98,000 사토시, 혹은 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">REVOCATION_YOU_2</span> 키를 가진 라즐로에게`,
        list_three: `<span className="font-semibold">출력 1:</span> 라즐로에게 1,000 사토시`,
        list_four: `<span className="font-semibold">채굴자 수수료:</span> 1,000 사토시`,
      },
      paragraph_five: `Commitment 2 (당신)`,
      paragraph_six: `라즐로는 다음 트랜잭션을 가지게 됩니다:`,
      paragraph_seven: `Commitment 2 (라즐로)`,
      commitment_two_laszlo: {
        list_one: `<span className="font-semibold">입력 0:</span> 당신이 서명함`,
        list_two: `<span className="font-semibold">출력 0:</span> 700 블록 이후 라즐로에게 1,000 사토시, 혹은 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">REVOCATION_LASZLO_1</span> 키를 가진 당신에게`,
        list_three: `<span className="font-semibold">출력 1:</span> 당신에게 98,000 사토시`,
        list_four: `<span className="font-semibold">채굴자 수수료:</span> 1,000 사토시`,
      },
      paragraph_eight: `이 세 개의 트랜잭션은 모두 서명되었고 유효하지만, 라즐로는 아직 라이트닝 레모네이드를 건네주지 않았습니다. 왜일까요? 아직 마지막 단계가 남아 있거든요. 이전 철회용 키 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base">REVOCATION_YOU_1</span>을 라즐로에게 보내세요!`,
      success_bar: `라즐로에게 REVOCATION_YOU_1 키 보내기`,
    },
    making_a_payment_seven: {
      title: `🍋🍹 아~~~ 좋습니다.`,
      nav_title: `아~~~ 좋습니다.`,
      paragraph_one: `🍋🍹 아~~~ 좋습니다.`,
    },
    making_a_payment_eight: {
      title: `결제 한 번 더 하기`,
      nav_title: `결제 한 번 더 하기`,
      heading_one: `결제 한 번 더 하기`,
      paragraph_one: `밤은 길고, 오늘은 버짓콥터를 타고 집에 갈 계획도 없습니다. 라이트닝 레모네이드 한 잔 더 마실 시간은 충분합니다! 이제 당신과 라즐로는 비대칭 트랜잭션 방식도 익혔고, 철회 키를 활용한 흐름도 제대로 파악했으니, 이 프로토콜을 다시 한번 실행해봅시다.`,
      paragraph_two: `1,000 사토시로 결제한 상태를 보여주는 두 개의 커밋먼트 트랜잭션이, 지금 당신의 ePhone Infinity 화면에 떠 있습니다.`,
      heading_two: `안내`,
      list_one: `라즐로의 새로운 커밋먼트 트랜잭션에 들어갈 금액과 출력 스크립트를 업데이트해 줍니다.`,
      list_two: `트랜잭션에 먼저 서명한 뒤 라즐로에게 보냅니다.`,
      list_three: `이제 당신의 커밋먼트 트랜잭션을 업데이트할 차례입니다. 라즐로는 이전 상태를 철회하면서 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap">REVOCATION_LASZLO_1</span>키를 당신에게 보낼 겁니다. 그걸 받은 뒤, 금액과 출력 스크립트를 새롭게 반영해 줍니다.`,
      list_four: `그 트랜잭션을 라즐로에게 보내면, 라즐로가 서명할 수 있습니다.`,
      list_five: `그리고 마지막으로, 당신의 이전 철회 키 <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base"> REVOCATION_YOU_2 </span>를 라즐로에게 보냅니다. `,
      paragraph_three: `오늘도 한 잔, 맛있게 즐기세요 🍋🍹`,
      heading_three: `힌트`,
      paragraph_four: `채굴자 수수료 1,000 사토시는 미리 따로 떼어두세요.`,
      paragraph_five: `출력 0은 다음 두 가지 방법 중 하나로 사용할 수 있습니다:`,
      step_one: {
        hint_one: `700 블록이 지난 후 라즐로가 사용하는 경우:  <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> SIG(LASZLO) 1 </span>`,
        hint_two: `당신이 사용하는 경우: <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> 0 SIG(REVOCATION_LASZLO_2) SIG(YOU) 0 </span> `,
        hint_three: `출력 1은 당신이 사용합니다: <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> SIG(YOU) </span> `,
      },
      step_two: {
        hint_one: `700 블록이 지난 후 당신이 사용하는 경우: <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> SIG(YOU) 1 </span>`,
        hint_two: `라즐로가 사용하는 경우: <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> 0 SIG(REVOCATION_YOU_3) SIG(LASZLO) 0 </span> `,
        hint_three: `출력 1은 라즐로가 사용합니다: <span className="rounded-sm px-1.5 py-1 h-[28px] font-mono bg-[#0000004D] m-0.5 text-base whitespace-nowrap"> SIG(LASZLO) </span> `,
      },
    },

    outro_one: {
      title: `마무리`,
      nav_title: `밤새도록 계속하기`,
      paragraph_one: `이건 밤새도록 계속할 수 있어요! 물론, 당신의 100,000 사토시가 전부 라즐로에게 넘어가기 전까지만요.`,
      paragraph_two: `물도 꼭 마셔주세요! 홀로그램 핫도그랑 나쵸도 있어요.`,
    },

    outro_two: {
      title: `마무리`,
      nav_title: `집으로 가는 길`,
      paragraph_one: `길고도 기묘했던 하루가 끝나고, 당신은 음료값을 치르고 집으로 향합니다. 그런데 3D 프린터로 지은 당신의 방갈로 문을 여는 순간—세상에, 또 반더풀이잖아요! 진짜일까요, 아니면 밈풀 마가리타를 너무 많이 마신 탓일까요? 사방을 둘러싼 홀로캣 무리를 대동하고 있음에도, 그는 싸우러 온 건 아닌 듯합니다.`,
      paragraph_two: `—반더풀: “우린 잘 아는 사이도 아니지만, 우리 할아버지 말로는 운명에는 낯선 이들도 종종 얽혀있다더군. 내 얘기 좀 들어줘. 사토시 나카모토에 관한 모든 건… 우리 가족의 사업을 구하려던 내 마지막 몸부림이었어. 채굴이 우리에게 얼마나 큰 의미였는지 너는 상상도 못 할 거야. 나는 그저 변화가 두려웠고, 모든 걸 예전 그대로 두고 싶었던 것뿐이야.”`,
    },

    outro_three: {
      title: `마무리`,
      nav_title: `비트코인 커뮤니티`,
      paragraph_one: `당신은 그에게 왜 사토시 나카모토라는 이름이 그토록 중요했는지를 물어봅니다.`,
      paragraph_two: `—반더풀: “비트코인에서 사토시 나카모토 다음으로 큰 이름은 BitRey랑 반더풀뿐이거든. 언젠가 누군가가 사토시 나카모토라는 이름으로 내게 말하더군. 비트코인은 이미 100년도 전에 창시자의 손을 떠났다고. 그래서 반더풀 가문의 이름을 살리기 위해, 나는 더 강력한 이름을 차지하려 했던 거야. 새 코인을 찍어낼 때의 전율, 너는 그걸 몰라. 그건 나에게 마법이었고, 지금도 그래.”`,
      paragraph_three: `—반더풀: “내가 설령 사토시의 증손자라고 해도, 비트코인을 움직이는 건 리더가 아니란 걸 이제는 알아. 비트코인을 정의하는 건 바로 커뮤니티지. 심지어 사토시조차 지금의 비트코인을 바꿀 수 없어. 그게 바로 비트코인의 위대함이고, 수많은 다른 코인들이 비트코인을 따라하려다 실패한 이유야.”`,
    },

    outro_four: {
      title: `마무리`,
      nav_title: `반더풀의 악행`,
      paragraph_one: `반더풀은 당신의 홀로캣을 들어 올립니다. 고양이는 부드럽게 가르릉거리기 시작하죠. 사람은 참 복잡한 존재입니다. 그리고 그걸 가장 잘 아는 건—홀로그램이든 실제든—고양이들이죠.`,
      paragraph_two: `—홀로캣: “당신은 악당이 아니야, 반더풀 씨. 하지만 어쩌면, 정말 어쩌면… 너무 많이 신경 썼던 것뿐일지도.”`,
      paragraph_three: `—반더풀: “그 말, 딱 맞는구먼.”`,
    },

    outro_five: {
      title: `마무리`,
      nav_title: `해냈습니다!!!`,
      heading_one: `해냈습니다!!!`,
      paragraph_one: `사토시도 그랬듯, 당신도 처음엔 아무도 주목하지 않던 사람이었습니다. 하지만 당신의 아이디어에는 힘이 있었고, 사람들이 따르기 시작했죠. 사토시는 사라졌지만 그의 정신과 철학은 여전히 계속 살아 있습니다. 이제 당신은 새롭게 익힌 비트코인 개발 실력과 겸손함, 그리고 끈기를 무기로 이 우아한 시스템에 의미 있는 흔적을 남길 준비가 됐습니다. 이 시스템은 100년 넘게 검열에 저항하는 화폐로 세계를 하나로 연결해 왔습니다.  비트코인이 계속 살아남을 수 있는 이유는, 바로 당신처럼 무언가를 기꺼이 나누려던 사람들이 있었기 때문입니다. 그러므로 우리는 모두 사토시입니다.`,
    },

    outro_six: {
      title: `Saving Satoshi 그 너머로`,
      nav_title: `Saving Satoshi 그 이후의 여정`,
      heading: `비트코인은 여전히 당신의 도움이 필요합니다...`,
      paragraph_one: `2139년이라는 미래가 멀게 느껴질 수 있지만, 비트코인의 사명은 변하지 않습니다—공정하고, 개방적이며, 정직한 화폐를 만드는 것. 그러나 이 비전을 실현하려면 모두의 노력이 필요하고, 그 안에는 당신도 포함되어 있습니다.`,
      paragraph_two: `당신은 이제, 비트코인을 제대로 이해하고 있다는 걸 증명했습니다. 그 지식을 이제는 행동으로 보여줄 차례입니다. 인류 역사상 가장 중요한 기술 중 하나에 기여할 완벽한 순간이에요.`,
      paragraph_three: `<Link className="underline" href="https://bitcoindevs.xyz/">Bitcoin Dev Project</Link>는 미래 세대의 오픈소스 기여자들을 위한 길잡이 역할을 합니다. 지금 이 순간, 단 한 번의 클릭이면 비트코인의 다음 영웅이 될 수 있습니다.`,
      paragraph_four: `우리는 모두 사토시입니다.`,
    },
    tab_data: {
      signed: `서명 완료`,
      pending: `보류 중`,
      deposit: `이건 당신 지갑에 있는 101,000 사토시짜리 출력이에요. 라즐로와의 오프체인 결제에 사용할 예정입니다.`,
      payment: `이건 라즐로에게 보내는 당신의 오프체인 결제입니다.`,
      multisig: `이 트랜잭션은 당신과 라즐로 사이의 멀티시그 출력에 자금을 입금합니다.`,
      refund_0: `이 트랜잭션은 라즐로가 사라지더라도 자금이 사라지지 않도록 보장합니다.`,
      refund_1: `이 트랜잭션은 라즐로가 사라지더라도 자금이 사라지지 않도록 보장합니다. 그리고 당신이 라이트닝 레모네이드를 결제한 뒤에도 이 트랜잭션을 브로드캐스트하지 않겠다는 신뢰를 라즐로에게 줍니다.`,
      refund_2: `이 트랜잭션은 라즐로가 사라지더라도 자금이 사라지지 않도록 보장합니다. 또한 라이트닝 레모네이드를 결제한 직후에 당신이 곧바로 환불받지 못하게 막습니다. 결제한 1,000 사토시까지 포함해서 전액 환불을 시도하면, 700 블록 지연 덕분에 라즐로가 며칠 안에 그걸 알아챌 수 있습니다.`,
      commitment_you: `이건 이번 결제를 위한 두 번째 커밋먼트 트랜잭션으로, 라즐로에게 1,000 사토시를 지급합니다.`,
      commitment_laszlo: `이건 라즐로 버전의 커밋먼트 트랜잭션입니다.`,
    },
    resources: {
      output_zero_sig: `출력 0에 대한 서명`,
      output_one_sig: `출력 1에 대한 서명`,
      sats_distribution: `라즐로는 라이트닝 레모네이드 값만큼 사토시를 받아야 하며, 1,000 사토시 채굴 수수료는 당신이 부담해야 합니다. 수수료는 당신의 거스름돈에서 빠져나갑니다.`,
      output_script: `출력에 걸린 락킹 스크립트에는 서명 (i.e. <span className="rounded-sm px-1.5 py-1 font-mono bg-[#0000004D] m-1 text-base whitespace-nowrap">OP_PUSH SIG()</span>)이 포함되면 안 됩니다. 만약 스크립트에 이런 부분이 들어 있다면, 그냥 제거해 주세요.`,
      miner_fees_basic: `채굴 수수료 1,000 사토시를 따로 확보해 두는 걸 잊지 마세요.`,
      miner_fees: `채굴 수수료 1,000 사토시는 당신의 거스름돈에서 빠져나간다는 걸 잊지 마세요.`,
    },
  },

  ///CHALLENGE PAGE
  challenge_list: {
    coming_soon: `곧 업데이트됩니다. 조금만 기다려 주세요.`,
  },

  chapter: {
    chapter_locked_one: `챕터 완료`,
    chapter_locked_two: `잠금을 해제하려면`,
    coming_soon: `곧 업데이트됩니다. 조금만 기다려 주세요.`,
    description: `사토시의 미스터리를 탐험하며 비트코인을 배워보세요.`,
  },

  hero: {
    title: `Saving Satoshi`,
    description: `코드로 비트코인의 미스터리를 풀어보세요.`,
    start_journey: `시작하기`,
    tell_more: `자세히 보기`,
  },

  footer: {
    paragraph_one: `비트코인 커뮤니티가 제작한 오픈소스 프로젝트입니다.`,
    link: `코드 보기`,
  },

  navbar: {
    intro: `들어가며`,
    chapter: `챕터`,
    chapter_complete: `챕터 완료`,
    challenge: `과제`,
    help_tooltip: `도움이 필요하세요?`,
    your_language: `언어 설정`,
  },

  modal_signin: {
    heading: `서명하기`,
    pre_signin_paragraph_one: `개인 키를 입력하여 계정과 진행 상황을 복원하세요.`,
    post_signin_paragraph_one: `다시 Satoshi를 구하러 오셨군요! 마지막으로 하던 곳에서 이어서 시작할 수 있어요.`,
    prompt: `개인 키를 입력하세요`,
    confirm: `서명하기`,
    create_account: `계정이 없으신가요?`,
    login: `로그인`,
    welcome_back: `돌아오신 걸 환영합니다!`,
    progress_redirect: `마지막으로 진행한 위치로 이동하기`,
  },

  modal_logout: {
    heading: `로그인 완료`,
    paragraph_one: `아래 버튼을 누르면 로그아웃하기 전까지 세션이 유지됩니다.`,
    private_key: `당신의 개인 키`,
    signout: `로그아웃`,
  },

  modal_signup: {
    heading: `진행 사항 저장`,
    paragraph_one: `간단한 코드를 복사해두면 이 브라우저에서 진행 상황을 저장하고 나중에 다시 불러올 수 있습니다. 이미 코드가 있다면 여기서 불러올 수 있어요.`,
    subheading_one: `아바타 선택하기`,
    subheading_two: `개인 키 백업하기`,
    generate: `모든 준비가 끝났나요? 코드를 복사해 백업했는지 꼭 확인하세요. 이 코드를 잃어버리면 복구할 수 없습니다.`,
    confirm: `완료`,
    acknowledged: `개인 키를 안전하게 저장했으며, 앞으로 진행 상황을 복원하려면 이 키가 꼭 필요하다는 걸 알고 있습니다.`,
  },

  difficulty_selection: {
    NORMAL: `하드 모드를 켜면 도전 과제가 더 어려워집니다.`,
    HARD: `하드 모드를 끄면 도전 과제가 더 쉬워집니다.`,
  },

  social: {
    twitter_share: `X(구 트위터)로 공유하기`,
    nostr_share: `nostr로 공유하기`,
    sharing: `공유 중...`,
    shared: `공유 완료!`,
    share_error: `공유에 실패했습니다`,
  },

  disclaimer: {
    description: `함께하게 되어 정말 반갑습니다! 일부 과제는 기본적인 프로그래밍 지식이 필요할 수 있지만, 힌트도 제공되니 걱정하지 말고 도전해보세요. <Link href="https://docs.google.com/forms/d/e/1FAIpQLSf1xpNqUYJyvYL5IZDnxy78273pkqzfYW2Hf91H4Do4KHgy9g/viewform?usp=sf_link" className="underline">피드백</Link>도 꼭 남겨주세요!`,
  },

  opcode: {
    run: `스크립트 실행하기`,
    reset: `초기화`,
  },

  status_bar: {
    begin_message: `위의 과제를 완료하면 다음으로 넘어갈 수 있습니다...`,
    error_message: `음... 아직 완벽하진 않은 것 같아요.`,
    in_progress_message: `지금까지는 잘하고 있어요...`,
    success_message: `아주 잘했습니다!`,
    next_step_message: `좋습니다! 이제 다음 단계로 넘어가겠습니다.`,
    im_stuck: `잘 모르겠어요`,
    try_again: `다시 시도하기`,
    next: `다음`,
    skip_challenge_first: `첫 번째 과제로 바로 가볼까요?`,
    skip_challenge_last: `마지막 과제로 바로 가볼까요?`,
  },

  hasher: {
    placeholder: `여기에 입력하세요...`,
    return_hash: `입력값이 해시로 변환되어 아래에 표시됩니다.`,
  },

  hashrate: {
    start: `시작`,
    running: `해싱 중`,
    blocks_found: `발견된 블록 수`,
    hashrate: `해시레이트`,
    partial_solutions: `셰어 제출 결과`,
  },

  runner: {
    run: `스크립트 실행`,
    running: `실행 중`,
    pause: `일시 정지`,
    result: `결과`,
    computing: `계산 중...`,
    evaluation: `평가`,
    script_output: `스크립트 출력`,
    waiting: `위 입력을 기다리는 중...`,
    poor: `코드는 유효하지만 기대한 결과와는 조금 다릅니다. 다시 시도해 보세요.`,
    good: `괜찮습니다! 완벽하진 않지만 정답으로 인정됩니다. 계속 개선하거나 다음으로 넘어가도 됩니다..`,
    success: `아주 잘했어요! 코드가 완벽합니다.`,
    language_tabs: {
      locked: `이 챕터를 시작한 이후로 해당 언어는 비활성화되었습니다`,
      reset: `터미널 초기화`,
    },
  },
  notfound: {
    first: `흠... 여기가 어디죠?`,
    second: `여기가 정확히 어디인지 잘 모르겠어요.`,
    third: `공간… 아니면 시간 속에서 길을 잃은 걸지도요.`,
    back_safety: `안전한 곳으로 돌아가기`,
  },
  error: {
    first: `뭔가 잘못됐습니다!`,
    second: `또 홀로캣이 케이블을 씹었나 봐요. 나쁜 고양이네요!`,
    reload: `다시 시도하기`,
  },
  help_page: {
    main_heading: `학습 자료`,
    main_subheading: `더 깊이 있는 학습을 위해 어떤 정보와 자료가 도움이 될까요?`,
    tips_heading: `팁`,
    tips_subheading: `진행과정에 막혔을 때 사용자에게 주고 싶은 구체적인 팁이 있다면 무엇일까요?`,
    spoilers_heading: `정답 공개`,
    spoilers_confirm: `네, 정답을 보고 싶어요`,
    pseudo_confirm: `네, 슈도코드를 보고 싶어요`,
    solution: `이 과제의 정답`,
    pseudo_solution: `이 과제의 슈도코드 정답`,
    solution_one: `이 과제의 첫 번째 부분에 대한 정답`,
    feedback: `이 과제의 첫 번째 부분에 대한 정답 <a href="https://docs.google.com/forms/d/e/1FAIpQLSf1xpNqUYJyvYL5IZDnxy78273pkqzfYW2Hf91H4Do4KHgy9g/viewform" target="_blank" rel="noreferrer">이 링크</a>를 통해 의견을 남겨주세요.`,
    help_suggestion: `막히는 부분이 있다면 오른쪽 위에 있는 '?' 버튼을 눌러보세요. 유용한 정보와 팁이 준비되어 있습니다.`,
  },
}
export default translations
